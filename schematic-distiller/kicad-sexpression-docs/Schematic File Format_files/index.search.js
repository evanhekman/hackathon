var relearn_search_index = [
  {
    "breadcrumb": "",
    "content": " Contributing to KiCad (application) development Developer mailing list The first thing to do before anything is to join the KiCad Developers Mailing List. Here you can ask broad questions and present your ideas or plans if it’s beyond a bug fix.\nObtaining the code KiCad uses Git for source control.\nIf you are new to git, it is highly suggested you find and follow the many tutorials available online like this one and/or read the git documentation.\nWe also are dedicated to using GitLab as our primary hosting platform for our Git repositories.\nAll repos can be found here.\nThe repository for the main application can be found here\nCompiling the code Follow the instruction in the documentation corresponding to your platform to set up a working build environment and successfully build KiCad from source.\nCode Documentation To familiarize yourself with the code base you can read the documentation generated by Doxygen. When submitting new code, please remember to update the documentation descriptions. You can run make doxygen-docs to generate the documentation locally.\nThe latest version of the same docs are also available on the Jenkins server, see KiCad Developer Docs for the C++ API.\nYou can also find various developer notes in the Doxygen docs, see the related pages.\nBefore you submit After you make changes, please ensure your code meets the KiCad Coding Style Policy.\nYour commit messages should follow the rules stated in the KiCad Commit Message Format Policy\nIf you feel like working on the user interface, you will find useful reading the User Interface Guidelines.\nIt’s important for us to keep the codebase readable by all developers. Your patches will not be accepted until they adhere to the rules set forth in these policies.\nProgramming is an iterative process, don’t worry if you have to go back and make changes to your patches, we all do.\nSubmitting the code All patches should be submitted as a merge request on GitLab. See this How to create a merge request for new users on how.\nNote: There is a GitHub mirror of KiCad but all pull requests are ignored, we only accept changes on GitLab\nFix any CI issues The GitLab repository has Continous Integration (CI) enabled. This means it automatically runs processing steps on incoming commits to do a few tasks from making sure the code can compile to coding style policy.\nYou can find the status of the CI job on the merge request page and see its output. If you need help, you may ask in the merge request for a developer to comment on what to do to resolve it.\nStarter / Beginner Patches Don’t have any ideas in general on what to do but want to help?\nYou might want to look into issues labeled as 'starter'.\nOr for example if you are an macOS user, you might want to check the following issues tagged as 'macos'.\nHelp If you encounter any problems with building or developing KiCad, you may ask for guidance on our mailing list. If you prefer real-time communication, you may also ask on our unofficial developer help channel on Discord.",
    "description": "Contributing to KiCad (application) development Developer mailing list The first thing to do before anything is to join the KiCad Developers Mailing List. Here you can ask broad questions and present your ideas or plans if it’s beyond a bug fix.\nObtaining the code KiCad uses Git for source control.\nIf you are new to git, it is highly suggested you find and follow the many tutorials available online like this one and/or read the git documentation.",
    "tags": [],
    "title": "Getting Started",
    "uri": "/en/getting-started/index.html"
  },
  {
    "breadcrumb": "Rules and Guidelines",
    "content": " 1. Introduction The purpose of this document is to provide a reference guide for KiCad developers about how source code should be styled and formatted in KiCad. It is not a comprehensive programming guide because it does not discuss many things such as software engineering strategies, source directories, existing classes, or how to internationalize text. The goal is to make all of the KiCad source conform to this guide.\n1.1 Why Coding Style Matters You may be thinking to yourself that using the style defined in this document will not make you a good programmer and you would be correct. Any given coding style is no substitute for experience. However, any experienced coder will tell that the only thing worse than looking at code that is not in your preferred coding style, is looking at twenty different coding styles that are not your preferred coding style. Consistency makes a) problems easier to spot, and b) looking at code for long periods of time more tolerable.\n1.2 Enforcement The KiCad coding police are not going to break down your door and beat you with your keyboard if you don’t follow these guidelines (although there are those who would argue that they should). However, there are some very sound reasons why you should follow them. If you are contributing patches, you are much more likely to be taken seriously by the primary developers if your patches are formatted correctly. Busy developers don’t have the time to go back and reformat your code. If you have a desire to become a regular KiCad developer with commit access to the development branch, you’re not likely to get a glowing recommendation by the lead developers if you will not follow these guidelines. It is just good programming courtesy to follow this policy because it is respectful of the investment already made by the existing developers. The other KiCad developers will appreciate your effort.\nWarning\nDo not modify this document without the consent of the project leader. All changes to this document require approval.\n1.3 Tools There are some tools that can help you format your code easily.\nclang-format is a formatting tool that can both be used to provide code-style automation to your editor of choice, as well as allow git to check formatting when committing (using a \"Git hook\"). You should install this program to be able to use the Git hooks.\nThe style config file is _clang-format, and should be picked up automatically by clang-format when the --style=file option is set.\nTo enable the Git hooks (only needs to be done once per Git repo):\ngit config core.hooksPath .githooks Set the git clang-format tool to use the provided _clang-format file:\ngit config clangFormat.style file Then, to enable the format checker, set the kicad.check-format Git config to \"true\" for the KiCad repo:\ngit config kicad.check-format true Without this config, the format checker will not run on commit, but you can still check files staged for commit manually (see below).\nIf the hook is enabled, when you commit a change, you will be told if you have caused any style violations (only in your changed code). You can then fix the errors, either manually, or with the tools below.\nIf you are warned about formatting errors, but you are sure your style is correct, you can still commit:\ngit commit --no-verify 1.3.1 Correcting Formatting Errors There is a Git aliases file that provides the right commands to show and correct formatting errors. Add to your repository config by running this command from the source directory:\ngit config --add include.path $(pwd)/tools/git/format_alias Then you can use the following aliases:\ngit check-format: show any formatting warnings (but make no changes)\ngit fix-format: correct formatting (you will need to git add afterwards)\nThese aliases use a script, tools/check_coding.sh, which takes care of only checking the formatting for files that should be formatted. This script has other uses:\nMake (or see only) violations in files modified in the previous commit (useful when interactive-rebasing):\ncheck_coding.sh --amend [--diff]\n2. Naming Conventions Before delving into anything as esoteric as indentation and formatting, naming conventions need to be addressed. This section does not attempt to define what names you use for your code. Rather, it defines the style for naming. See the references section for links to some excellent coding references. When defining multiple word names use the following conventions for improved readability:\nUse underscores for all upper and all lower case variables to make multiple word names more readable.\nUse camel case for mixed case variable names.\nAvoid mixing camel case and underscores.\nExamples\nCamelCaseName // if camelcase, then no underscores all_lower_case_name ALL_UPPER_CASE_NAME 2.1 Class, Type Definitions, Name Space, and Macro Names Class, typedef, enum, name space, and macro names should be comprised of all capital letters.\nExamples\nclass SIMPLE #define LONG_MACRO_WITH_UNDERSCORES typedef boost::ptr_vector\u003cPIN\u003e PIN_LIST; enum KICAD_T {...}; 2.2 Local, Private and Automatic Variables The first character of automatic, static local, and private variable names must be lower case. This indicates that the variable will not be “visible” outside of the function, file, or class where they are defined, respectively. The limited visibility is being acknowledged with the lowercase starting letter, where lowercase is considered to be less boisterous than uppercase.\nExamples\nint i; double aPrivateVariable; static char* static_variable = NULL; Private class and struct members must be prefixed with m_ and the first character after the m_ prefix must also be lowercase:\nprivate: int m_privateData; 2.3 Public and Global Variables The first character of public and global variable names must be uppercase. This indicates that the variable is visible outside the class or file in which it was defined. (An exception is the use of prefix g_ which is also sometimes used to indicate a global variable.)\nExample\nchar* GlobalVariable; In general, classes should not use public member variables, and instead should use getter/setter methods to access private members. The exception is classes that are essentially data structures with some helper methods. For example, the SEG class is used frequently as a data structure representing a line segment between two points. This class has public member variables A and B storing those points. This is acceptable because the SEG class meets that definition of being essentially a data structure, and because there is no need for side-effects when changing A or B.\n2.4 Local, Private and Static Functions The first character of local, private, and static functions should be lower case. This indicates that the function is not visible outside the class or file where it is defined.\nExample\nbool isModified(); static int buildList( int* list ); 2.5 Function Arguments Function arguments are prefixed with an 'a' to indicate these are arguments to a function. The 'a' stands for “argument”, and it also enables clever and concise Doxygen comments.\nExample\n/** * Copy aFoo into this instance. */ void SetFoo( int aFoo ); Notice how the reader can say “a Foo” to himself when reading this.\n2.6 Pointers It is not desired to identify a pointer by building a 'p' into the variable name. The pointer aspect of the variable pertains to type, not purpose.\nExample\nMODULE* module; The purpose of the variable is that it represents a MODULE. Something like p_module would only make that harder to discern.\nUse smart pointers where it makes sense to simplify memory management. Where using smart pointers, the STL types std::shared_ptr / std::unique_ptr are preferred. Do not use Boost smart pointers.\n2.7 Accessing Member Variables and Member Functions We do not use this→ to access either member variables or member functions from within the containing class. We let C++ perform this for us.\n2.8 Use of 'auto' We do -not- use auto to reduce repetition. We do use it to increase readability. This generally means -only- use auto where std::lib gets overly verbose (such as iterators or std::make_shared), or when not using auto would cause line-wraps that can’t otherwise be avoided.\nExample\nauto board = m_frame-\u003eGetBoard(); // Not permitted, use the actual type name BOARD* board = m_frame-\u003eGetBoard(); // OK auto it = someComplexSTLType.begin(); // OK, improves readability for( auto\u0026 item : container ) // Discouraged where the actual type name isn't very long for( TYPE\u0026 item : container ) // Preferred for( auto\u0026 [key, value] : map ) // C++17 structured binding; acceptable when readable 2.9 Casting In most circumstances, use of C-style casting is not permitted. Explicit C++-style casting should be used instead.\nExample\nPCB_TRACK* track = ( PCB_TRACK* )item; // Not permitted PCB_TRACK* track = static_cast\u003cPCB_TRACK*\u003e( item ); // OK (when used safely) PCB_TRACK* track = dynamic_cast\u003cPCB_TRACK*\u003e( item ); // OK 3. Commenting Comments in KiCad typically fall into two categories: in line code comments and Doxygen comments. In line comments have no set formatting rules other than they should have the same indent level as the code if they do not follow a statement. In line comments that follow statements should not exceed 119 columns unless absolutely necessary. This prevents word wrapping in an editor when the viewable columns is set to 120. In line comments can use either the C++ or the C commenting style, but C++ comments are preferred for single line comments or comments consisting of only a few lines.\nAvoid stating the obvious in comments. Adding a comment that states this is a dtor, ctor, function, iterator, etc. just adds noise to the comment. Any sufficiently experience developer can recognize this. Avoid comments that state what code does. It should be obvious what code does or it should be rewritten so that it is obvious.\n3.1 Blank Lines Above Comments If a comment is the first thing on a line, then that comment should have one or more blank lines above them. One blank line is preferred.\n3.2 Doxygen Doxygen is a C++ source code documenting tool used by the project. Descriptive *.html files can be generated from the source code by installing Doxygen and building the target named doxygen-docs.\ncd \u003ckicad_build_base\u003e make doxygen-docs The generated source *.html files will be placed into \u003ckicad_project_base\u003e/Documentation/doxygen/html/.\nDoxygen comments are used to build developer documentation from the source code. They should normally be only placed in header files (.h) and not in source files (.cpp). This eliminates the obligation to keep two comments in agreement with each other. If the class, function, or enum, etc. is only defined in a source file and not present in any header file, in which case the Doxygen comments should go into the source file. Again, avoid duplicating the Doxygen comments in both the header and source files.\nKiCad uses the JAVADOC comment style defined in the doccode section of the Doxygen manual. Don’t forget to use the special Doxygen tags : bug, todo, deprecated, etc., so other developers can quickly get useful information about your code. It is good practice to actually generate the Doxygen *.html files by building target doxygen-docs, and then to review the quality of your Doxygen comments with a web browser before submitting a patch.\nAvoid defining class and function names and argument and return data types. This redundant information can easily be read by other developers and shows up as redundant information in the generated documentation.\nMany legacy Doxygen comments in KiCad start with the function name on a blank line before the rest of the comment. This style is no longer acceptable, and modifications to those legacy function signatures is a good opportunity to remove these lines from the Doxygen comments. Use Doxygen’s markdown syntax where possible instead of HTML tags. Markdown makes for more readable comments than mark up languages.\nUse Doxygen links when referring to other code in Doxygen comments. This makes information easier to find for other developers.\nGroup related sections of comments together as much as possible using the Doxygen grouping commands. This makes finding related information easier than having it spread across multiple document pages.\n3.2.1 Function Comments These go into a header file, unless the function is a private (i.e. static) function known only to a source file. The format of a function comment is chosen to serve a dual purpose role: delineation of the function declaration within the source code and to create a consistent leading sentence in the Doxygen html output. The chosen format is to use a descriptive single line sentence, followed by a blank line, followed by an optional detailed description as the shown in the example below.\nExample\n/** * Format and write text to an output stream. * * A really detailed description goes here if it's needed. * * @param aNestLevel is the multiple of spaces to precede the output with. * @param aFmt is a printf() style format string. * @param ... is a variable list of parameters that will get blended into * the output under control of the format string. * @return the number of characters output. * @throw IO_ERROR, if there is a problem outputting. */ int PRINTF_FUNC Print( int aNestLevel, const char* aFmt, ... ); The single line description goes on the 2nd line of the comment. The @return keyword if present, should describe the return value followed by a hyphen. The @param keyword names a function parameter and the text following should flow like a normal English sentence including proper punctuation.\n3.2.2 Class Comments A class comment describes a class declaration by giving the purpose and use of the class. Its format is similar to a function comment. Doxygen can use the html \\\u003cp\\\u003e (paragraph designation) to begin a new paragraph in its output. So if the text of the comment is large, break it put into multiple paragraphs as required.\nExample\n/** * An interface (abstract) class used to output UTF8 text in a * convenient way. * * The primary interface is \"printf() like\" but with support for * indentation control. The destination of the 8 bit wide text is * up to the implementer. * \u003cp\u003e * The implementer only has to implement the write() function, but * can also optionally re-implement GetQuoteChar(). * \u003cp\u003e * If you want to output a wxString, then use CONV_TO_UTF8() on it * before passing it as an argument to Print(). * \u003cp\u003e * Since this is an abstract interface, only classes derived from * this one may actually be used. */ class OUTPUTFORMATTER { 4. Formatting This section defines the formatting style used in the KiCad source.\n4.1 Indentation The indentation level for the KiCad source code is defined as four spaces. Please do not use tabs.\n4.1.1 Defines There should be only one space after a #define statement.\n4.1.2 Column Alignment Please try to align multiple consecutive similar lines into consistent columns when possible, such as #define lines which can be thought of as containing 4 columns: #define, symbol, value, and comment. Notice how all 4 columns are aligned in the example below.\n#define LN_RED 12 // my favorite #define LN_GREEN 13 // eco friendly Another common case is the declaration of automatic variables. These are preferably shown in columns of type and variable name.\n4.2 Blank Lines 4.2.1 Function Declarations There should be 1 blank line above a function declaration in a class file if that function declaration is presented with a Javadoc comment. This is consist with the statement above about blank lines above comments.\n4.2.2 Function Definitions Function definitions in *.cpp files will not typically be accompanied by any comment, since those are normally only in the header file. It is desirable to set off the function definition within the *.cpp file by leaving two blank lines above the function definition.\n4.2.3 Control Statements There should be one blank line before the opening statement and after the closing curly brace or statement for all control statement blocks so that it is easy to see where control blocks begin and end. This includes if, for, while, do, and switch control blocks.\nFor example, a blank line is required here between the variable declaration and the if statement:\nbool isTrue = checkSomething(); if( isTrue ) doSomething(); Curly braces themselves count as blank lines for the purposes of this style rule. For example, a nested control statement may be written as:\nwhile( aCondition ) { if( checkSomething() ) { break; } } 4.3 Line Length The maximum line width is 120 columns. An exception to this is a long quoted string such as the internationalized text required to satisfy MSVC++, described below.\n4.4 Line-breaking Strings The KiCad project team no longer supports compiling with Microsoft Visual C++. When you need to break long strings into smaller substrings, please use the C99 compliant method for improved readability. Using any of previously accepted methods defined below for breaking long internationalized strings will no longer be accepted.\nExamples\n// This works with C99 compliant compilers is the **only** accepted method: wxChar* foo = _( “this is a long string broken ” “into pieces for readability.” ); // This works with MSVC, breaks POEdit, and is **not** acceptable: wxChar* foo = _( “this is a long string broken ” L“into pieces for readability” ); // This works with MSVC, is ugly, and is **not** accepted: wxChar* foo = _( “this is a long string \\ broken into pieces for readability” ); A second acceptable solution is to simply put the text all on one line, even if it exceeds the 99 character line length limit. However, the preferred method is to break strings within the 99 character limit whenever possible to prevent wrapping.\n4.5 Line-breaking Expressions When line breaking expressions the operators should appear at the beginning of a line, not at the end.\nif( SomeMethodCall( some_parameter, other_parameter ) || some_local_variable == foo ) 4.6 Trailing Whitespace Many programming editors conveniently indent your code for you. Some of them do it rather poorly and leave trailing whitespace. Thankfully, most editors come with a remove trailing whitespace macro or at least a setting to make trailing whitespace visible so you can see it and manually remove it. Trailing whitespace is known to break some text parsing tools. It also leads to unnecessary diffs in the version control system. Please remove trailing whitespace.\n4.7 Multiple Statements per Line It is generally preferred that each statement be placed on its own line. This is especially true for statements without keywords.\nx=1; y=2; z=3; // Bad, should be on separate lines. 4.8 Braces Braces should be placed on the line proceeding the keyword and indented to the same level. It is not necessary to use braces if there is only a single line statement after the keyword. In the case of if..else if..else, indent all to the same level.\nvoid function() { if( foo ) { statement1; statement2; } else if( bar ) { statement3; statement4; } else statement5; } Braces are required if the control statement spans more than one line, even if the control block is a single line. This makes it easier to visually parse.\nif( GetSomeProperty( parameter ) == SOME_CONSTANT_VALUE || GetSomeProperty( parameter ) == SOME_OTHER_CONSTANT_VALUE ) { single_statement; } 4.9 Parenthesis Parenthesis should be placed immediately after function names and keywords. Spaces should be placed after the opening parenthesis, before the closing parenthesis, and between the comma and the next argument in functions. No space is needed if a function has no arguments.\nvoid Function( int aArg1, int aArg2 ) { while( busy ) { if( a || b || c ) doSomething(); else doSomethingElse(); } } 4.10 Switch Formatting The case statement is to be indented to the same level as the switch.\nswitch( foo ) { case 1: doOne(); break; case 2: doTwo(); // Fall through. default: doDefault(); } It is preferred to place all cases on a single line when that makes the code more readable. This is often done for look-ups or mapping functions. In this case, you will have to manually align for readability as appropriate and reject clang-format’s suggested changes, if you use it:\nswitch( m_orientation ) { case PIN_RIGHT: m_orientation = PIN_UP; break; case PIN_UP: m_orientation = PIN_LEFT; break; case PIN_LEFT: m_orientation = PIN_DOWN; break; case PIN_DOWN: m_orientation = PIN_RIGHT; break; } 4.11 Lambdas The braces and statements of the body should be indented as you would a method, with the braces lined up under the capture block:\nauto belowCondition = []( const SELECTION\u0026 aSel ) { return g_CurrentSheet-\u003eLast() != g_RootSheet; }; or:\nauto belowCondition = []( const SELECTION\u0026 aSel ) { return g_CurrentSheet-\u003eLast() != g_RootSheet; }; 4.12 Class Definition Layout When defining classes, member variables should be placed at the bottom and methods should be placed above the member variables. The scope ordering of the class should be public, protect, then private. Do not redefine the same scope multiple times in a row. Here is an example class definition:\nclass FOO { public: FOO(); void FooPublicMethod(); protected: void fooProtectedMethod(); private: void fooPrivateMethod(); // Private not redefined here unless no private methods. int m_privateMemberVariable; }; 4.13 Getters and Setters Class methods used to read and write from private class members without any other side effects are permitted to violate several of the normal formatting rules in order to improve legibility. These methods can exist all on one line, with no blank line between:\npublic: wxString GetFoo() const { return m_foo; } void SetFoo( const wxString\u0026 aFoo ) { m_foo = aFoo; } 5. License Statement There is a file called copyright.h, which you can copy into the top of your new source files and edit the \\\u003cauthor\\\u003e field. KiCad depends on the copyright enforcement capabilities of copyright law, and this means that source files must be copyrighted and not be released into the public domain. Each source file has one or more owners.\n6. Debugging Output Debugging output is a common method for validating code. However, it should not always active in debug builds. This makes it difficult for other developers to see their debugging output and can have a significant impact on the performance of debug builds. If you need to use debugging output, use wxLogDebug instead of printf or C++ output stream. If you accidentally leave the debugging output in the source, it will expand to nothing on release builds. All debugging output code should be removed from the source tree before pushing changes to the main KiCad repo. Do not comment out debugging output. This just adds more cruft to the code base. If you need to leave debugging output on, for future testing, use tracing output (see 6.1).\n6.1 Using Tracing for Debugging Output There are occasions when you want to see debugging output to ensure existing code performs as expected. In this case, use wxLogTrace which allows debugging output to be controlled by the WXTRACE environment variable. When using wxLogTrace, the trace environment variable string should be documented by either adding it to the trace_helper.{h/cpp} source files or locally using the Doxygen comment \\ingroup trace_env_vars. To prevent WXTRACE name space conflicts, all trace variable strings should be prefixed with \"KICAD_\".\n7. Header Files Project *.h source files should:\ncontain a license statement\ncontain a nested include #ifndef\nbe fully self-contained and not depend on other headers that are not included within it.\nThe license statement was described above.\n7.1 Nested Include #ifndef Each header file should include an #ifndef which is commonly used to prevent compiler errors in the case where the header file is seen multiple times in the code stream presented to the compiler. Just after the license statement, at the top of the file there should be lines similar to these (but with a file name specific token other than RICHIO_H_):\n#ifndef RICHIO_H_ #define RICHIO_H_ And at the very bottom of the header file, use a line like this one:\n#endif // RICHIO_H_ The #ifndef wrapper begins after the license statement, and ends at the very bottom of the file. It is important that it wrap any nested #include statements, so that the compiler can skip them if the #ifndef evaluates to false, which will reduce compilation time.\n7.2 Headers Without Unsatisfied Dependencies Any header file should include other headers that it depends on. (Note: KiCad is not at this point now, but this section is a goal of the project.)\nIt should be possible to run the compiler on any header file within the project, and with proper include paths being passed to the compiler, the header file should compile without error.\nExample\n$ cd path_to_kicad_source/include $ g++ `wx-config --cxxflags` -I . xnode.h -o /tmp/junk Such structuring of the header files removes the need within a client *.cpp file to include some project header file before some other project header file. (A client *.cpp file is one that intends to use, not implement, the public API exposed within the header file.)\nClient code should not have to piece together things that a header file wishes to expose. The exposing header file should be viewed as a fully sufficient ticket to use the public API of that header file.\nThis is not saying anything about how much to expose, only that that which is exposed needs to be fully usable merely by including the header file that exposes it, with no additional includes.\nFor situations where there is a class header file and an implementation *.cpp file, it is desirable to hide as much of the private implementation as is practical and any header file that is not needed as part of the public API can and should be included only in the implementation *.cpp file. However, the number one concern of this section is that client (using) code can use the public API which is exposed in the header file, merely by including that one header file.\n8. When in Doubt…​ When editing existing source code files and there are multiple acceptable code formatting options or no formatting is defined, follow the existing formatting in the file.\n9. I Wrote X Lines of Code Before I Read This Document It’s OK. We all make mistakes. Fortunately, KiCad provides a configuration file for the code beautifier uncrustify. Uncrustify won’t fix your naming problems but it does a pretty decent job of formatting your source code. There are a few places where uncrustify makes some less than ideal indentation choices. It struggles with the string declaration macros wxT(“”) and \\_(“”) and functions used as arguments to other functions. After you uncrustify your source code, please review the indentation for any glaring errors and manually fix them. See the uncrustify [website][uncrustify] for more information.\n[uncrustify]: http://uncrustify.sourceforge.net/\n10. Show Me an Example Nothing drives the point home like an example. The source file richio.h below was taken directly from the KiCad source.\n/* * This program source code file is part of KICAD, a free EDA CAD application. * * Copyright (C) 2007-2010 SoftPLC Corporation, Dick Hollenbeck \u003cdick@softplc.com\u003e * Copyright (C) 2007 KiCad Developers, see AUTHORS.txt for contributors. * * This program is free software; you can redistribute it and/or * modify it under the terms of the GNU General Public License * as published by the Free Software Foundation; either version 2 * of the License, or (at your option) any later version. * * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with this program; if not, you may find one here: * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html * or you may search the http://www.gnu.org website for the version 2 license, * or you may write to the Free Software Foundation, Inc., * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA */ #ifndef RICHIO_H_ #define RICHIO_H_ // This file defines 3 classes useful for working with DSN text files and is named // \"richio\" after its author, Richard Hollenbeck, aka Dick Hollenbeck. #include \u003cstring\u003e #include \u003cvector\u003e // I really did not want to be dependent on wxWidgets in richio // but the errorText needs to be wide char so wxString rules. #include \u003cwx/wx.h\u003e #include \u003ccstdio\u003e // FILE /** * A class used to hold an error message and may be used to throw exceptions * containing meaningful error messages. */ struct IOError { wxString errorText; IOError( const wxChar* aMsg ) : errorText( aMsg ) { } IOError( const wxString\u0026 aMsg ) : errorText( aMsg ) { } }; /** * Read single lines of text into a buffer and increments a line number counter. */ class LINE_READER { public: /** * @param aFile is an open file in \"ascii\" mode, not binary mode. * @param aMaxLineLength is the number of bytes to use in the line buffer. */ LINE_READER( FILE* aFile, unsigned aMaxLineLength ); ~LINE_READER() { delete[] line; } /* int CharAt( int aNdx ) { if( (unsigned) aNdx \u003c capacity ) return (char) (unsigned char) line[aNdx]; return -1; } */ /** * Read a line of text into the buffer and increments the line number * counter. * * @return is the number of bytes read, 0 at end of file. * @throw IO_ERROR when a line is too long. */ int ReadLine(); operator char* () { return line; } int LineNumber() { return lineNum; } unsigned Length() { return length; } protected: FILE* fp; int lineNum; unsigned maxLineLength; unsigned length; char* line; unsigned capacity; }; /** * An interface (abstract class) used to output ASCII text in a convenient way. * * The primary interface is printf() like with support for indentation control. * The destination of the 8 bit wide text is up to the implementer. If you want * to output a wxString, then use CONV_TO_UTF8() on it before passing it as an * argument to Print(). * \u003cp\u003e * Since this is an abstract interface, only classes derived from this one * will be the implementations. * \u003c/p\u003e */ class OUTPUTFORMATTER { #if defined( __GNUG__ ) // The GNU {cpp} compiler defines this // When used on a {cpp} function, we must account for the \"this\" pointer, // so increase the STRING-INDEX and FIRST-TO_CHECK by one. // See http://docs.freebsd.org/info/gcc/gcc.info.Function_Attributes.html // Then to get format checking during the compile, compile with -Wall or -Wformat #define PRINTF_FUNC __attribute__ ((format (printf, 3, 4))) #else #define PRINTF_FUNC // nothing #endif public: /** * Format and write text to the output stream. * * @param nestLevel is the multiple of spaces to preceed the output with. * @param fmt is a printf() style format string. * @param ... is a variable list of parameters that will get blended into * the output under control of the format string. * @return the number of characters output. * @throw IO_ERROR if there is a problem outputting, such as a full disk. */ virtual int PRINTF_FUNC Print( int nestLevel, const char* fmt, ... ) = 0; /** * Return the quoting character required for aWrapee. * * Return the quote character as a single character string for a given * input wrapee string. If the wrappee does not need to be quoted, * the return value is \"\" (the null string), such as when there are no * delimiters in the input wrapee string. If you want the quote character * to be assuredly not \"\", then pass in \"(\" as the wrappee. * \u003cp\u003e * Implementations are free to override the default behavior, which is to * call the static function of the same name. * \u003c/p\u003e * * @param aWrapee is a string that might need wrapping on each end. * @return the quote character as a single character string, or \"\" * if the wrapee does not need to be wrapped. */ virtual const char* GetQuoteChar( const char* aWrapee ) = 0; virtual ~OUTPUTFORMATTER() {} /** * Get the quote character according to the Specctra DSN specification. * * @param aWrapee is a string that might need wrapping on each end. * @param aQuoteChar is a single character C string which provides the current * quote character, should it be needed by the wrapee. * * @return the quote_character as a single character string, or \"\" * if the wrapee does not need to be wrapped. */ static const char* GetQuoteChar( const char* aWrapee, const char* aQuoteChar ); }; /** * Implement an OUTPUTFORMATTER to a memory buffer. */ class STRINGFORMATTER : public OUTPUTFORMATTER { public: /** * Reserve space in the buffer */ STRINGFORMATTER( int aReserve = 300 ) : buffer( aReserve, '\\0' ) { } /** * Clears the buffer and empties the internal string. */ void Clear() { mystring.clear(); } /** * Remove whitespace, '(', and ')' from the internal string. */ void StripUseless(); std::string GetString() { return mystring; } //-----\u003cOUTPUTFORMATTER\u003e------------------------------------------------ int PRINTF_FUNC Print( int nestLevel, const char* fmt, ... ); const char* GetQuoteChar( const char* wrapee ); //-----\u003c/OUTPUTFORMATTER\u003e----------------------------------------------- private: std::vector\u003cchar\u003e buffer; std::string mystring; int sprint( const char* fmt, ... ); int vprint( const char* fmt, va_list ap ); }; #endif // RICHIO_H_ 11. Resources There are plenty of excellent resources on the Internet on C++ coding styles and coding dos and don’ts. Here are a few useful ones. In most cases, the coding styles do not follow the KiCad coding style but there is plenty of other good information here. Besides, most of them have some great humor that makes them enjoyable to read. Who knows, you might even learn something new.\nC++ Coding Standard\nLinux Kernel Coding Style\nC++ Operator Overloading Guidelines\nWikipedia’s Programming Style Page",
    "description": "The code style guidelines that must be met for any contribution to KiCad’s application codebase.",
    "tags": [],
    "title": "Code Style Policy",
    "uri": "/en/rules-guidelines/code-style/index.html"
  },
  {
    "breadcrumb": "Rules and Guidelines",
    "content": " Commit Message Format Policy Commit messages must begin with a brief subject line. The subject line limit is 72 characters. If there is a body message, it must be separated from the subject line by a blank line and wrapped at 75 characters.\nThe body of a commit message should explain what the commit does and why. Do not explain how the changes work as the code itself should do that.\nLinking a Commit to an Issue If your commit fixes an issue that has been reported in the issue tracker, add a blank line after the subject line or message body and add a line indicating the fixed issue number to your commit message. In such cases, GitLab will automatically close the issue and add a link to the commit in the issue.\nFor example, the following line will automatically close issue #1234567:\nFixes https://gitlab.com/kicad/code/kicad/issues/1234567 There is an alias to simplify this step. Read more about automatic issue closing in the GitLab documentation.\nChangelog Tags To facilitate following the code changes, include a changelog tag to indicate modifications noticeable by the users. There are three types of changelog tags:\nADDED to denote a new feature.\nCHANGED to indicate a modification of an existing feature.\nREMOVED to inform about removal of an existing feature.\nThere is no need to add changelog tags for commits that do not modify the way the users interact with the software, such as code refactoring or a bug fix for unexpected behavior. The purpose of the changelog tags is to generate release notes and notify the documentation maintainers about changes.\nMaking the Documentation Developers Aware of Changes When a commit with changelog tag is pushed, the committer should create a new issue in the documentation repository to notify the documentation maintainers. Include a link to the commit containing the reported changes.\nExtracting Changelogs Thanks to the changelog tags, it is easy to extract the changelog using git commands:\ngit log -E --grep=\"ADD[ED]?:|REMOVE[D]?:|CHANGE[D]?:\" --since=\"1 Jan 2017\" git log -E --grep=\"ADD[ED]?:|REMOVE[D]?:|CHANGE[D]?:\" \u003ccommit hash\u003e KiCad provides an alias to shorten the changelog extraction commands.\nExample Following is an example of a properly formatted commit message:\nEeschema: Adding line styling options ADDED: Add support in Eeschema for changing the default line style, width and color on a case-by-case basis. CHANGED: \"Wire\" lines now optionally include data on the line style, width and color if they differ from the default. Fixes https://gitlab.com/kicad/code/kicad/issues/594059 Fixes https://gitlab.com/kicad/code/kicad/issues/1405026 Git Aliases File There is a file containing helpful git aliases located at tools/git/fixes_alias. To install it, run in the source repository:\ngit config --add include.path $(pwd)/tools/git/fixes_alias 'fixes' Alias Once the alias configuration file is installed, it may be used to amend the most recent commit to include the bug report link:\ngit fixes 1234567 For example, the command below will append a line to the last commit message:\nFixes https://gitlab.com/kicad/code/kicad/issues/1234567 'changelog' Alias With the alias configuration file installed, changelogs can be extracted by running the following:\ngit changelog --since=\"1 Jan 2017\" git changelog \u003ccommit hash\u003e ",
    "description": "The guidelines describing how git commit messages should be formatted.",
    "tags": [],
    "title": "Commit Message Format Policy",
    "uri": "/en/rules-guidelines/commit/index.html"
  },
  {
    "breadcrumb": "Rules and Guidelines",
    "content": " 1 Introduction The purpose of this document is to provide the guidelines for creating releases for the KiCad project.\nThis document is applicable to all stable releases after version 6.0.0. Do not modify this document without the consent of the project leader. All changes to this document require approval. 1.1 Versioning Scheme KiCad uses a typical [major].[minor].[bug fix] versioning scheme. Each new version is a simple incremental integer of the previous version. New major releases will reset the minor and bug fix version back to 0.\n1.2 Restrictions No board, schematic, footprint library, symbol library, or project file format changes are allowed during a major release cycle except to fix known bugs. Changes to configuration files are acceptable.\nMinor and bug fix releases are only valid for the current stable major release. Once a new stable major version is released, the previous stable version is considered a no longer supported (dead) branch.\n2 Major Release Policy Major releases will occur annually by January 31st of a given calendar year. This corresponds with the annual FOSDEM conference. The following table outlines the release schedule dates.\nTable 1. Major Release Schedule Date Milestone February 1st\nNew feature merge window opens.\nSeptember 30th\nNew feature merge window closes.\nBug fixing only period begins.\nDecember 1st\nString freeze begins.\nDecember 15th\nRelease candidate 1 tagged.\nJanuary 14th\nLibrary, documentation, and, translation repository freeze.\nBug fix freeze.\nJanuary 15th\nSource code repository tagged with next major version and branched.\nBegin package build and upload to website.\nJanuary 31st\nNew version release announcement.\nFeatures not ready by the merge window close will have to wait until the next merge window. No exceptions. Only the source code repository branch is mandatory. All other repositories are branched if the development team determines it is necessary. 3 Minor Release Policy Features from the current development branch of KiCad can be back ported to the current stable branch provided the following criteria is met:\nThe the last feature commit was pushed to the development branch at least 60 days prior to merging into the current stable branch.\nThe the last known issue filed against the feature occurred at least 30 days prior to merging into the current stable branch.\nThe cherry pick to current stable can be performed without pulling any other dependent code that does meets the file format change criteria above.\nA new minor release will include all of the bug fixes included in the current bug fix release so the bug fix version will be reset to 0 for new minor version releases.\nBack ports from the development branch can only be applied to the current stable branch. Back porting to older stable versions is not allowed. 4 Bug Fix Release Policy Bug fix releases are at the discretion of the lead development team.\nBug fix releases will be announced 14 days in advance of the release by the project manager to allow time for all required release actions to be completed.\nA release candidate -rc1 tag will be created a minimum of three days before the final release. The release candidate will be announced by the project leader on the KiCad blog along with the usual KiCad social media sites.\nDuring the release candidate period, only regression fixes since the last bug fix release are allowed. All other bug fixes must wait until after the bug fix release period and release announcement are completed.\nIf a regression is fixed in the release candidate before the three day minimum testing period ends, a new incremental release candidate will be created and the three day minimum testing period begins from the date of the new release candidate. This process repeats until no new regressions are found in a release candidate. Multiple regressions may be fixed between release candidates.\nThe final bug fix release will be tagged if no new regressions occur within three days of the last release candidate.\nBug fixes cannot contain translatable string changes except for spelling and grammar errors. New strings are allowed assuming they do not clash with any existing strings. Bug fixes can only applied to the current stable release. ",
    "description": "The stable release policy provides guidelines for stable releases provided by the KiCad project.",
    "tags": [],
    "title": "Stable Release Policy",
    "uri": "/en/rules-guidelines/release-policy/index.html"
  },
  {
    "breadcrumb": "",
    "content": " Building KiCad from Source If you are a user and not a developer, please consider using one of the prebuilt packages of KiCad which can be found at the download page on the KiCad website. This document contains the instructions on how to build KiCad from source on the supported platforms. It is not intended as a guide for installing or building library dependencies. Please consult your platforms documentation for installing packages or the source code when building the library dependencies. Currently the supported platforms are Windows Versions 7-10, just about any version of Linux, and macOS 10.14 or newer. You may be able to build KiCad on other platforms but it is not supported. On Windows and Linux the GNU GCC is the only supported compiler and on macOS Clang is the only supported compiler.\nPages Getting StartedDevelopment Tools Before you begin building KiCad, there are a few tools required in addition to your compiler. Some of these tools are required to build from source and some are optional. CMake Build Configuration Tool CMake is the build configuration and makefile generation tool used by KiCad. It is required. Git Version Control System The official source code repository is hosted on GitLab and requires git to get the latest source.\nLinuxInstructions for Linux using gcc\nmacOSInstructions for macOS using cmake and clang\nWindows (MSYS2)Guide on building KiCad using MSYS2\nWindows (Visual Studio)Guide on building KiCad using Microsoft Visual Studio and vcpkg\nBuild OptionsSummary of CMake build configuration options.",
    "description": "Building KiCad from Source If you are a user and not a developer, please consider using one of the prebuilt packages of KiCad which can be found at the download page on the KiCad website. This document contains the instructions on how to build KiCad from source on the supported platforms. It is not intended as a guide for installing or building library dependencies. Please consult your platforms documentation for installing packages or the source code when building the library dependencies.",
    "tags": [],
    "title": "Build",
    "uri": "/en/build/index.html"
  },
  {
    "breadcrumb": "Rules and Guidelines",
    "content": " 1. Introduction The purpose of this document is to provide a guide for KiCad developers about source code dos and don’ts in KiCad. It is not a comprehensive guide because it does not cover all topics. However, it is expected that all of the topics covered by this document are followed by all developers contributing code to the KiCad project.\n2. Library Dependencies KiCad is a cross platform project. Therefore, all dependency libraries must be packaged for all supported platforms. If packages are not available on a given platform, it is the responsibility of the developer introducing any new dependencies to ensure that they are packaged before submitting the new dependency. Platform specific features will not be accepted.\n3. Low Level Object Design All KiCad low level objects not directly related to user interface design must be free of user interface code dependencies. This includes all SCH_*, LIB_*, PCB_*, FP_*, and I/O plugin objects.\nThe only exception is the wxWidgets Debugging Macros. The reason for this is that the wxWidgets user interface code is only used in debug builds. This has the advantage of developers being made aware of coding issues without having to run from the command line or in a debugger to see assertion messages. ",
    "description": "The code design guidelines are rules that must be met for any contribution to KiCad’s application code base.",
    "tags": [],
    "title": "Code Design Guidelines",
    "uri": "/en/rules-guidelines/code-policy/index.html"
  },
  {
    "breadcrumb": "Rules and Guidelines",
    "content": " 0. Community Contributions In general, KiCad does not accept contributions of graphic assets (icons, etc.) from the community directly. The lead development team may make small tweaks to icons themselves, but aims to employ professional graphic designers for larger changes and development of new assets.\nCommunity contributors looking to add new features to KiCad that require new art assets (for example, adding a tool that requires a toolbutton icon) may create placeholder art to be used until a final asset can be created. This placeholder art may be modified or replaced at the discretion of the KiCad lead development team in coordination with an external designer.\nThis policy is aimed at achieving a consistent and unified look and feel for KiCad and also removing debate over art assets from the review process for community contributions. We still welcome feedback and suggestions related to art assets from the community, and will consider this type of input when discussing changes or additions to KiCad’s art assets.\nThe following guidelines are presented for reference and represent the current consensus of the lead development team. New placeholder art assets should attempt to follow these guidelines.\n1. Look and Feel The KiCad icon design guidelines are intended to create a consistent visual style for icons across KiCad. The visual style is intended to provide a balance between each icon being unique enough that it is easy to locate, but not so unique that there is no consistent theme among all the icons and it looks like each was designed by a different person. The general principles of that visual style are:\nFlat design: icons should not use gradients, shadows, or other “3D” effects.\nStandard color palette: icons should make use of a restricted color palette, listed in this document. Additions to or changes to this color palette must be discussed with the lead development team, as it could require changing many icons for the sake of consistency.\nUse color sparingly where shape is sufficient: color should be used to clarify differences between icons that have similar shapes. Icons that can convey their meaning through shape alone (and not be confused with other icons) should be monochrome, just using the primary color (Dark Grey in the light theme)\nPixel alignment: icons are designed as vectors but used as bitmaps. Vector graphics must be designed for proper pixel alignment at the target icon size(s) to prevent blurriness.\nConsistency: icons describing the same concept should be consistent in their use of color and shape to describe that concept. For example, all icons that include control points should make those control points Blue in color.\nMinimalism: not much detail is preserved in a 24x24 icon. Be sparing with the use of fine features, especially when those fine features are all that tell one icon apart from another.\nWindow theme aware: even setting aside those operating systems with “dark modes”, the window background color of KiCad can vary quite a lot across operating systems. Be careful when using colors in ways that may disappear against the window background. In particular, Accent Gray, White, and Schematic Tan will be very hard to see against the window background. Only use these colors on top of a background of a different color to create sufficient contrast.\n2. Technical Requirements and Licensing Icons must be developed as SVG files. Building and testing icon changes requires you to have Inkscape and pngcrush installed, as detailed in the CMakeLists.txt file in the bitmaps_png source directory. If your version of pngcrush does not match that used by the lead development team (1.8.13), you will see a large number of differences in your source tree.\nIcons must be licensed as Creative Commons Attribution-ShareAlike (CC-BY-SA) using an embedded license in the SVG file. This can be added in Inkscape using the Document Properties dialog.\n3. Authoring Software SVG files must be edited in Inkscape 1.0 or higher. While other packages such as Adobe Illustrator are able to export SVG files, they export only the look of the icon. They frequently skip other details such as layers, hidden lines, clipping, grids and licenses that make the file easier to edit in the future. We recommend making use of the Icon Preview feature in Inkscape to make sure your vector graphics are properly aligned to the pixel grid and will be clear at the target size.\n4. Grids The icon file must have a grid set in the Inkscape SVG file. The grid units must be px with an origin at 0,0 and spacing of 0.5 px. The Minor grid line color should be #ceceff20 and the major grid line color should be #3f3fff40. There should be a major grid line every 2 lines.\nThis allows both even and odd sized line widths to be pixel aligned on the grid. This is set in the Document Properties window as follows:\n5. Icon Sizes Size Uses 16x16\nSome UI buttons\nAppearance panel visibility toggles\nFile icons\n24x24\nAll toolbar buttons\nAll menu icons (at the moment)\n48x48\nMain program icons in KiCad manager\n128x128\nMain program icons (ico files)\n6. Colors With few exceptions, only use the colors in these tables for SVG objects (additional colors will exist in the generated bitmaps due to blending).\n6.1. Light Theme Color Name Color Value Uses/Notes Primary Gray\n#545454\nThis is the default color to use for all strokes.\nNote that in dense fills (e.g. Save, Print, Paste icons) it will appear darker than the identical grey in other icons. For these cases we use #606060.\nMedium Grey\n#848484\nUsed for inactive objects to reduce contrast compared to Dark Grey\nAccent Grey\n#B9B9B9\nUsed for the hole inside a via and the fill inside graphic shapes\nPrimary Blue\n#1A81C4\nUsed to accentuate certain details and for \"back copper\" in PcbNew\nAccent Blue\n#39B4EA\nUsed to show zone fill in some places, and as an accent color\nPrimary Red\n#BF2641\nUsed for accents, badges, and \"front copper\" in PcbNew\nGold\n#F29100\nUsed for via copper, and (rarely) as an accent\nPCB Green\n#489648\nUsed in the PcbNew program icon for traces\nPCB Dark Green\n#006400\nUsed in the PcbNew program icon for soldermask\nSchematic Tan\n#D0C5AC\nUsed in the Eeschema icon and to represent schematic sheets\nPure White\n#FFFFFF\nUsed for contrast against dark colors and separation between objects\nArea Fill\n#F3F3F3\nUsed for large fills of white (e.g. New) instead of Pure White\n6.2. Dark Theme Color Name Color Value Uses/Notes Primary Gray\n#DED3DD\nThis is the default color to use for all strokes.\nNote that in dense fills (e.g. Save, Print, Paste icons) it will appear darker than the identical grey in other icons. For these cases we use #606060.\nMedium Grey\n#848484\nUsed for inactive objects to reduce contrast compared to Dark Grey\nAccent Grey\n#E0E0E0\nUsed for the hole inside a via and the fill inside graphic shapes\nPrimary Blue\n#42B8EB\nUsed to accentuate certain details and for \"back copper\" in PcbNew\nAccent Blue\n#1A81C4\nUsed to show zone fill in some places, and as an accent color\nPrimary Red\n#F2647E\nUsed for accents, badges, and \"front copper\" in PcbNew\nGold\n#F29100\nUsed for via copper, and (rarely) as an accent\nPCB Green\n#489648\nUsed in the PcbNew program icon for traces\nPCB Dark Green\n#006400\nUsed in the PcbNew program icon for soldermask\nSchematic Tan\n#D0C5AC\nUsed in the Eeschema icon and to represent schematic sheets\nPure White\n#FFFFFF\nUsed for contrast against dark colors and separation between objects\nArea Fill\n#545454\nUsed for large fills of white (e.g. New) instead of Pure White\n7. Lines and Fills Line weights in SVG files should usually be 1.5px or heavier, to ensure that in the final bitmap, there are pixels with the true color no matter the placement of the line with regards to the pixel grid. Horizontal and vertical lines should usually be 2px where they convey the main meaning of the image. 1px lines are OK when part of a larger whole.\nLine weights representing certain concepts should be kept consistent throughout the icon set where practical. For example, graphical shape drawing tools use 2px lines always.\nIn general the icon set uses \"flat filled\" shapes where applicable. Maintain this visual style when creating new icons. Note that not all shapes must be filled — stroked shapes with no fill can be used (along with the window background color) to create a contrasting filled area. Strokes should be constant-width in general to avoid looking like hand-drawn brush strokes (\"cartoon style\").\nFills should use solid colors in almost all instances. Gradients should be used sparingly, and generally not to create \"3D\" effects or the appearance of lighting/shadows.\n8. Fonts We use two fonts in the icons: Noto Sans and Tiresias LPFont Bold. Noto Sans is used by default for all text. Tiresias is used for the “Ki” logo.\nNoto Sans may be used in different weights and spacing, e.g. Noto Sans Bold, Semi-condensed, if needed for spacing or line weight.\nTiresias LPFont Bold may only be used as Tiresias LPFont Bold without substitution.\n9. Badges Badges are symbols that overlay other icons to add meaning. These symbols come from a shared library (badges.svg in the sources directory). Always use the appropriate badge with consistent placement (you can copy/paste from the badges SVG) rather than creating new artwork that conveys the same meaning as a badge.\nBadges should generally be used without modification, but in some cases it is helpful to add a 1px-1.5px stroke border (in Pure White for the light theme) to the outside of the badge to ensure visual separation between the badge and the icon content underneath.",
    "description": "The style guidelines that should be used for visual asset (icon, etc.) changes or additions.",
    "tags": [],
    "title": "Icon Design Guidelines",
    "uri": "/en/rules-guidelines/icon-design/index.html"
  },
  {
    "breadcrumb": "Rules and Guidelines",
    "content": " Purpose This document lays out the desired ways of working for the KiCad lead development team. It is meant to provide a basic introduction for new developers as well as a reference for current lead developers in how to manage and resolve uncertainty and conflicts.\nBase Guidelines We are a team of equals.\nWe respect our userbase.\nWe respect each others’ contributions.\nThe code we contribute belongs to everyone.\nIn a disagreement, everyone gives a little.\nWe prioritize our families, our health and our offline lives ahead of KiCad.\nDiscussion We are a team of equals This means that your opinions will be given equal weight with every other person on the lead developer team.\nIn the event a decision is deadlocked after multiple developers have weighed in, the resolution will be made by the Project Lead. This is, however, an outcome to be avoided if at all possible.\nWe also recognize that we each bring different experiences to the team. We will try to give weight to the lead developers who actively use a particular feature when deciding on implementation issues.\nWe respect our userbase We all come to this project, developers and users, with differing expectations, experiences and english fluency. When dealing with each other, it is inevitable that these differences will lead to conflict over politeness, appropriate expectations or any of the myriad other impedance mismatches we might have in our communications.\nAs lead developers, our behavior in public project spaces reflects on the project as a whole. We will hold ourselves to a higher standard in our behavior than the standard to which we hold the end users.\nWe will not respond to any issue report, merge request or forum post when we feel annoyed or irritated by the person posting or by the content of the post. We provide a Zulip channel where lead developers can tag others to take on the burden of calmly responding. We will do the following:\nPost a link to the page in question\n(optional) Express any frustrations we have\nSay why this content is wrong\n(1) and (3) are required. (2) is optional but available if it helps to diffuse the emotion around the content. At this point, another, disinterested lead developer will take on the task of responding. You get to go back to coding other things.\nFailing to follow this guideline will inevitably lead to drama. And drama sucks time from both you, the other person and the rest of the lead developer team as we end up dealing with the response and not the actual content.\nWe respect each others’ contributions While we all make mistakes, we will not revert the contributions of other developers without their explicit consent, even when we think that they might not have implemented something in accordance with our views of the policies.\nWe each are responsible for the quality of our own contributions. If there is a disagreement over a commit, it must be worked out over e-mail/Zulip/video call/etc with the person committing the code. We do not fight in the code base.\nIn the event that a problematic commit has been made to the codebase and the person responsible is not available to discuss it, then the commit can be reverted after publicly (either on GitLab or Zulip) discussing and agreeing on this with the rest of the lead development team.\nWhen we disagree with a contribution made by another developer, we will address it directly with them politely. Examples of polite feedback might include:\nThis code doesn’t work for me when I…\nOr\nI think that this code will cause problems because…\nExamples of rude feedback that we will avoid include:\nThis code stinks/sucks/is really bad/etc\nOr\nWhoever screwed up this part of the codebase…\nNaturally, we are all welcome to provide ourselves with as much impolite feedback on code we have written as we can handle. :)\nThe code we contribute belongs to everyone We are a free/libre open source community. Everything that we contribute to the KiCad project belongs to and is the responsibility of the whole KiCad development team. Copyrights on new files will be assigned to the KiCad Development team. They may be additionally assigned to a primary author or sponsor of the code that is written, but this does not mean that the original author has veto power or even greater weight in the discussions of how the code develops.\nWhen we commit code to the KiCad codebase, we are standing on the shoulders of everyone who has done so before us. Our contribution will be changed, updated, refined and polished in ways that we did not anticipate and that we might not even agree with. That process is a compliment to the author of the original code because the changes would not have been possible without the original work.\nIn a disagreement, everyone gives a little We will frequently come to a point in discussion of either the specification document or code itself where we each have a different opinion about the direction of a particular feature or other implementation detail. When this happens, we work to prioritize the elements that are most important to each developer.\nWe decide which parts of a feature are more important to us and ask for those parts to exist, giving up on the parts that, while still very important, are less critical than others. Everyone is expected to moderate their positions to come to a consensus.\nWe offer our opinions in ways that make it known how important the opinion is and why. For example:\nIt is very important that I am able to modify the start point of lines and arcs in the same way because I need this to be a unified interface for XYZ\nOr\nI have a preference for the print dialog being non-modal so that I can see the preview update in real time but it is not a strong one.\nIt is important to assess our own priorities when entering a conversation with other developers. Not every opinion can be the top, number 1 priority.\nEach developer on the team is highly skilled and if more than one is disagreeing with you, it is always a good idea to step back and examine if your opinion might be out of place or need to be changed. We will give extra consideration to the concerns raised by the developers who actively use a feature and those that are willing to implement their own vision.\nIf the developers involved in the discussion cannot agree, after each has moderated their position to accommodate an agreement, the final decision will be made by the project lead. Involving the project lead in resolving disputes is to be avoided if at all possible.\nWe prioritize our families, our health and our offline lives ahead of KiCad KiCad is a wonderful place to contribute to the community. We strive to be open and engaged with each other. We try to laugh with each other and support one another. But we are still just an online group of like-minded people. We will not place pressure on each other to work more or longer. We will encourage each other to take breaks from coding. We will watch for signs of overwork or stress and encourage each other to care for our own wellbeing before the wellbeing of the codebase.\nWe will design our systems and procedures in such a way that facilitates anyone needing to take an unexpected leave of absence.",
    "description": "The guidelines describing how the lead developer team interacts with each other.",
    "tags": [],
    "title": "KiCad Developer Culture",
    "uri": "/en/rules-guidelines/culture/index.html"
  },
  {
    "breadcrumb": "",
    "content": " Code Style PolicyThe code style guidelines that must be met for any contribution to KiCad’s application codebase.\nCommit Message Format PolicyThe guidelines describing how git commit messages should be formatted.\nStable Release PolicyThe stable release policy provides guidelines for stable releases provided by the KiCad project.\nCode Design GuidelinesThe code design guidelines are rules that must be met for any contribution to KiCad’s application code base.\nIcon Design GuidelinesThe style guidelines that should be used for visual asset (icon, etc.) changes or additions.\nKiCad Developer CultureThe guidelines describing how the lead developer team interacts with each other.\nUser Interface PolicyRules on how the user interface elements should be implemented.\nAnti-PatternsAnti-pattern guidelines for writing code for the KiCad project.",
    "description": "Code Style PolicyThe code style guidelines that must be met for any contribution to KiCad’s application codebase.\nCommit Message Format PolicyThe guidelines describing how git commit messages should be formatted.\nStable Release PolicyThe stable release policy provides guidelines for stable releases provided by the KiCad project.\nCode Design GuidelinesThe code design guidelines are rules that must be met for any contribution to KiCad’s application code base.\nIcon Design GuidelinesThe style guidelines that should be used for visual asset (icon, etc.",
    "tags": [],
    "title": "Rules and Guidelines",
    "uri": "/en/rules-guidelines/index.html"
  },
  {
    "breadcrumb": "",
    "content": " Settings FrameworkThe settings framework manages application settings, as well as projects. This document explains how to make use of the framework as well as some of its inner workings. Source Code Guide Most of the relevant code is in common/settings and common/project. C++ Class Description SETTINGS_MANAGER Loads and unloads settings files and projects JSON_SETTINGS The base class for all settings objects. Represents a single JSON file. NESTED_SETTINGS A JSON_SETTINGS object stored within another (i.\nTool FrameworkThis document briefly outlines the structure of the tool system in the GAL canvases. Introduction The GAL (Graphics Abstraction Layer) framework provides a powerful method of easily adding tools to KiCad. Compared to the older \"legacy\" canvas, GAL tools are more flexible, powerful and much easier to write. A GAL \"tool\" is a class which provides one or more \"actions\" to perform. An action can be a simple one-off action (e.\nPlugins FrameworkThe KiCad plugin system is a framework for extending the capabilities of KiCad using shared libraries. One of the main advantages of using a plugin is that it is not necessary to rebuild the KiCad suite while developing a plugin; in fact, plugins can be built with the aid of a very small set of headers from the KiCad source tree. Removing the requirement to build KiCad during plugin development greatly increases productivity by ensuring that the developer only compiles code directly related to the plugin which is being developed and thus reducing the time required for each build and test cycle.\nTestingUnit tests KiCad has a limited number of unit tests, which can be used to check that certain functionality works. Tests are registered using CTest, part of CMake. CTest gathers all the disparate test programs and runs them. Most C++ unit tests are written using the Boost Unit Test framework, but this is not required to add a test to the testing suite. The test CMake targets generally start with qa_, the names of the tests within CTest are the same but without the qa_ prefix.\nS-ExpressionsAn s-expression is a text stream or string, in the same vein as XML, consisting of a sequence of elements. Each element is either an atom or list. An atom corresponds to a string, while a list corresponds to an s-expression. The following grammar represents our definition of an s-expression: sexpr ::= ( sx ) sx ::= atom sxtail | sexpr sxtail | NULL sxtail ::= sx | NULL atom :: quoted | value quoted :: \"ws_string\" value :: nws_string An atom can either be a quoted string, which is a string containing whitespace surrounded by double quotes, or a non-whitespace string that does not require surrounding quotes.",
    "description": "Settings FrameworkThe settings framework manages application settings, as well as projects. This document explains how to make use of the framework as well as some of its inner workings. Source Code Guide Most of the relevant code is in common/settings and common/project. C++ Class Description SETTINGS_MANAGER Loads and unloads settings files and projects JSON_SETTINGS The base class for all settings objects. Represents a single JSON file. NESTED_SETTINGS A JSON_SETTINGS object stored within another (i.",
    "tags": [],
    "title": "Components",
    "uri": "/en/components/index.html"
  },
  {
    "breadcrumb": "",
    "content": " Pages KiCad IPC APIKiCad IPC API The IPC API is an interface that can be used to remotely control a running instance of KiCad. This can be used to implement KiCad plug-ins as well as to interface KiCad with external software. The API is currently under development, with the plan of stabilizing the first version for KiCad 9.0. Overall Design Principles The KiCad API is implemented using Protocol Buffers to define the structure and contents of messages, and NNG to transport messages between processes using UNIX sockets.\nHTTP LibrariesHTTP Libraries HTTP libraries are a type of KiCad symbol library that sources data about parts for an external source such an ERP system. They do not contain any symbol or footprint definitions as standard KiCad libraries do. Instead, they reference to symbols and footprints found in other KiCad libraries. HTTP libraries are read only for now but will eventually support read/write in the future. At the moment only REST or REST-Like APIs are supported but support for other libraries could be added easily.\nPCB Python BindingsDeprecation notice The SWIG-based Python bindings in KiCad are deprecated as of KiCad 9.0 and will be removed in a future version. They will be replaced by the IPC API, which is a stable interface that is accessible from many languages including Python. The current plan is to remove the SWIG bindings in KiCad 10.0. This plan is subject to delay based on development timelines and community feedback. KiCad 10.",
    "description": "Pages KiCad IPC APIKiCad IPC API The IPC API is an interface that can be used to remotely control a running instance of KiCad. This can be used to implement KiCad plug-ins as well as to interface KiCad with external software. The API is currently under development, with the plan of stabilizing the first version for KiCad 9.0. Overall Design Principles The KiCad API is implemented using Protocol Buffers to define the structure and contents of messages, and NNG to transport messages between processes using UNIX sockets.",
    "tags": [],
    "title": "APIs and Bindings",
    "uri": "/en/apis-and-binding/index.html"
  },
  {
    "breadcrumb": "Build",
    "content": " Development Tools Before you begin building KiCad, there are a few tools required in addition to your compiler. Some of these tools are required to build from source and some are optional.\nCMake Build Configuration Tool CMake is the build configuration and makefile generation tool used by KiCad. It is required.\nGit Version Control System The official source code repository is hosted on GitLab and requires git to get the latest source. If you prefer to use GitHub there is a read only mirror of the official KiCad repository. The previous official hosting location at Launchpad is still active as a mirror. Changes should be submitted as merge requests via GitLab. The development team will not review changes submitted on GitHub or Launchpad as those platforms are mirrors only.\nDoxygen Code Documentation Generator The KiCad source code is documented using Doxygen which parses the KiCad source code files and builds a dependency tree along with the source documentation into HTML. Doxygen is only required if you are going to build the KiCad documentation.\nSWIG Simplified Wrapper and Interface Generator SWIG is used to generate the Python scripting language extensions for KiCad. SWIG is not required if you are not going to build the KiCad scripting extension.\nLibrary Dependencies This section includes a list of library dependencies required to build KiCad. It does not include any dependencies of the libraries. Please consult the library’s documentation for any additional dependencies. Some of these libraries are optional depending on you build configuration. This is not a guide on how to install the library dependencies using you systems package management tools or how to build the library from source. Consult the appropriate documentation to perform these tasks.\nwxWidgets Cross Platform GUI Library wxWidgets is the graphical user interface (GUI) library used by KiCad. As of version 7.0, KiCad is developed and tested against wxWidgets 3.2. The KiCad team will not perform testing or bugfixing against older versions of wxWidgets, and may inadvertently introduce changes that break compilation or function when building against older versions. We welcome patches to fix build issues against earlier versions of wxWidgets as long as these patches do not change functionality when compiling against more modern versions. These patches should be the minimum necessary to get KiCad working, rather than attempting to backport functionality from the newer wxWidgets API (unless doing so is trivial).\nOn macOS we use a custom fork of wxWidgets — see the macOS build instructions for details.\nBoost C++ Libraries The Boost C++ library version 1.71 or greater is required to build KiCad.\nGLEW OpenGL Extension Wrangler Library The OpenGL Extension Wrangler is an OpenGL helper library used by the KiCad graphics abstraction library (GAL) and is always required to build KiCad.\nZLib Library The ZLib development library is used by KiCad to handle compressed 3d models (.stpz and .wrz files) and is always required to build KiCad.\nGLM OpenGL Mathematics Library The OpenGL Mathematics Library is an OpenGL helper library used by the KiCad graphics abstraction library (GAL) and is always required to build KiCad.\nGLUT OpenGL Utility Toolkit Library The OpenGL Utility Toolkit is an OpenGL helper library used by the KiCad graphics abstraction library (GAL)and is always required to build KiCad.\nCairo 2D Graphics Library The Cairo 2D graphics library is used as a fallback rendering canvas when OpenGL is not available and is always required to build KiCad.\nPython Programming Language The Python programming language is used to provide scripting support to KiCad. It is always required to build KiCad.\nwxPython Library The wxPython library is used to provide a scripting console for Pcbnew. It needs to be installed unless the wxPython scripting build configuration option is disabled. When building KiCad with wxPython support, make sure the version of the wxWidgets library and the version of wxPython installed on your system are the same. Mismatched versions have been known to cause runtime issues.\nCurl Multi-Protocol File Transfer Library The Curl Multi-Protocol File Transfer Library is used to provide secure internet file transfer access for the Plugin and Content Manager.\nOpenCascade Library Open CASCSADE Technology (OCC) is used to provide support for loading and saving 3D model file formats such as STEP. KiCad requires OCC 7.5.0 or higher. When building OCC locally, use the option BUILD_MODULE_Draw=OFF to make building easier\nNgspice Library The Ngspice Library is used to provide Spice simulation support in the schematic editor. Make sure the the version of ngspice library used was built with the—​with-ngshared option. This library needs to be installed unless the Spice build option is disabled.\nProtocol Buffers (protobuf) The protobuf library is used to provide structured serialization of KiCad data for the IPC API. It is required even when the IPC API is not enabled, as it is also used as part of QA testing and is likely to be used in other applications in the future. KiCad requires protobuf version 3.x, and must be built with the same version of protobuf that is deployed as a library on the target system.\nNanomsg Next Generation (nng) The nng library is used to provide a communications channel between KiCad and third-party plugins and applications for the IPC API. It is required when KICAD_IPC_API is enabled.\nKiCad Build Configuration Options KiCad has many build options that can be configured to build different options depending on the availability of support for each option on a given platform. This section documents these options and their default values.\nIPC API The KICAD_IPC_API option is used to enable the experimental IPC API server. When this option is enabled, the NNG library must be available.\nwxPython Scripting Support The KICAD_SCRIPTING_WXPYTHON option is used to enable building the wxPython interface into Pcbnew including the wxPython console.\nIntegrated Spice simulator The KICAD_SPICE option is used to control if the Spice simulator interface for Eeschema is built. When this option is enabled, it requires Ngspice to be available as a shared library. This option is enabled by default.\nSTEP/IGES support for the 3D viewer The KICAD_USE_OCC is used for the 3D viewer plugin to support STEP and IGES 3D models. Build tools and plugins related to OpenCascade (OCC) are enabled with this option. When enabled it requires OpenCascade to be available. This option is enabled by default.\nWayland EGL support The KICAD_USE_EGL option switches the OpenGL backend from using X11 bindings to Wayland EGL bindings. This option is only relevant on Linux when running wxWidgets 3.1.5+ with the EGL backend of the wxGLCanvas (which is the default option, but can be disabled in the wxWidgets build).\nBy default, setting KICAD_USE_EGL will use a in-tree version of the GLEW library (that is compiled with the additional flags needed to run on an EGL canvas) staticly linked into KiCad. If the system version of GLEW supports EGL (it must be compiled with the GLEW_EGL flag), then it can be used instead by setting KICAD_USE_BUNDLED_GLEW to OFF.\nWindows HiDPI Support The KICAD_WIN32_DPI_AWARE option makes the Windows manifest file for KiCad use a DPI aware version, which tells Windows that KiCad wants Per Monitor V2 DPI awareness (requires Windows 10 version 1607 and later).\nDevelopment Analysis Tools KiCad can be compiled with support for several features to aid in the catching and debugging of runtime memory issues\nValgrind support The KICAD_USE_VALGRIND option is used to enable Valgrind’s stack annotation feature in the tool framework. This provides the ability for Valgrind to trace memory allocations and accesses in the tool framework and reduce the number of false positives reported. This option is disabled by default.\nC++ standard library debugging KiCad provides two options to enable debugging assertions contained in the GCC C++ standard library: KICAD_STDLIB_DEBUG and KICAD_STDLIB_LIGHT_DEBUG. Both these options are disabled by default, and only one should be turned on at a time with KICAD_STDLIB_DEBUG taking precedence.\nThe KICAD_STDLIB_LIGHT_DEBUG option enables the light-weight standard library assertions by passing _GLIBCXX_ASSERTIONS into CXXFLAGS. This enables things such as bounds checking on strings, arrays and vectors, as well as null pointer checks for smart pointers.\nThe KICAD_STDLIB_DEBUG option enables the full set of standard library assertions by passing _GLIBCXX_DEBUG into CXXFLAGS. This enables full debugging support for the standard library.\nAddress Sanitizer support The KICAD_SANITIZE_ADDRESS option enables Address Sanitizer (ASan) support to trace memory allocations and accesses to identify problems. This option is disabled by default. The Address Sanitizer contains several runtime options to tailor its behavior that are described in more detail in its documentation.\nAnalogously, the KICAD_SANITIZE_THREADS option enables Thread Sanitizer (TSan). Its runtime options are described here.\nThese options are not supported on all build systems, and are known to have problems when using MinGW. They may also cause errors when using a linker other than the GNU linker, for example Gold, Lld, Mold.\nDemos and Examples The KiCad source code includes some demos and examples to showcase the program. You can choose whether install them or not with the KICAD_INSTALL_DEMOS option. You can also select where to install them with the KICAD_DEMOS variable. On Linux the demos are installed in $PREFIX/share/kicad/demos by default.\nQuality assurance (QA) unit tests The KICAD_BUILD_QA_TESTS option allows building unit tests binaries for quality assurance as part of the default build. This option is enabled by default.\nIf this option is disabled, the QA binaries can still be built by manually specifying the target. For example, with make:\nBuild all QA binaries: make qa_all\nBuild a specific test: make qa_pcbnew\nBuild all unit tests: make qa_all_tests\nBuild all test tool binaries: make qa_all_tools\nFor more information about testing KiCad, see [this page](testing.md).\nKiCad Build Version The KiCad version string is defined by the output of git describe --dirty when git is available or the version string defined in CMakeModules/KiCadVersion.cmake with the value of KICAD_VERSION_EXTRA appended to the former. If the KICAD_VERSION_EXTRA variable is not defined, it is not appended to the version string. If the KICAD_VERSION_EXTRA variable is defined it is appended along with a leading '-' to the full version string as follows:\n(KICAD_VERSION[-KICAD_VERSION_EXTRA]) The build script automatically creates the version string information from the Git repository information as follows:\n(5.0.0-rc2-dev-100-g5a33f0960) | output of \"git describe --dirty\" if git is available. KiCad Config Directory The default KiCad configuration directory is kicad. On Linux this is located at ~/.config/kicad, on MSW, this is C:\\Documents and Settings\\username\\Application Data\\kicad and on MacOS, this is ~/Library/Preferences/kicad. Inside the configuration directory, subdirectories will be created for each KiCad minor version, meaning that multiple versions of KiCad can share the same directory.\nThe base configuration directory can be overridden by specifying the KICAD_CONFIG_DIR string at compile time.\nSetting KICAD_CONFIG_DIR should be considered deprecated as of KiCad 5.99, as the config directory is versioned and there should not be any need to set a custom directory. Running from the Build Directory Normally, KiCad needs to be installed before running in order to locate data files and shared libraries. Developers may be interested in running specific KiCad binaries from inside the build directory instead of installing, as this can sometimes be a faster way to test things. The environment variable KICAD_RUN_FROM_BUILD_DIR can be set in order to change how KiCad looks up paths for shared libraries, resources, and other data files. Note that setting this variable does not change how KiCad looks for symbol/footprint/3D model libraries.\nSetting the path to Python KiCad relies on a specific Python version on Windows and macOS. Normally, the path to this Python installation is set by the corresponding packaging scripts for those platforms, but in some situations, it can be preferable to set a custom Python interpreter for development or testing purposes. On Windows, you must set the environment variable KICAD_USE_EXTERNAL_PYTHONHOME in order for KiCad to use the PYTHONHOME environment variable instead of the default (hard-coded) path to Python. This is so that PYTHONHOME set on user machines does not inadvertently break KiCad. See the Windows build instructions for details on how to use this variable to run KiCad from the build directory.\nGetting the KiCad Source Code There are several ways to get the KiCad source. If you want to build the stable version you can down load the source archive from the GitLab repository. Use tar or some other archive program to extract the source on your system. If you are using tar, use the following command:\ntar -xaf kicad_src_archive.tar.xz If you are contributing directly to the KiCad project on GitLab, you can create a local copy on your machine by using the following command:\ngit clone https://gitlab.com/kicad/code/kicad.git Here is a list of source links:\nStable release archives: https://kicad.org/download/source/\nDevelopment branch: https://gitlab.com/kicad/code/kicad/tree/master\nGitHub mirror: https://github.com/KiCad/kicad-source-mirror",
    "description": "Development Tools Before you begin building KiCad, there are a few tools required in addition to your compiler. Some of these tools are required to build from source and some are optional.\nCMake Build Configuration Tool CMake is the build configuration and makefile generation tool used by KiCad. It is required.\nGit Version Control System The official source code repository is hosted on GitLab and requires git to get the latest source.",
    "tags": [],
    "title": "Getting Started",
    "uri": "/en/build/getting-started/index.html"
  },
  {
    "breadcrumb": "Components",
    "content": " The settings framework manages application settings, as well as projects. This document explains how to make use of the framework as well as some of its inner workings.\nSource Code Guide Most of the relevant code is in common/settings and common/project.\nC++ Class Description SETTINGS_MANAGER\nLoads and unloads settings files and projects\nJSON_SETTINGS\nThe base class for all settings objects. Represents a single JSON file.\nNESTED_SETTINGS\nA JSON_SETTINGS object stored within another (i.e. without its own file)\nPARAM\nA parameter: helper class for storing data inside a JSON_SETTINGS\nAPP_SETTINGS_BASE\nBase class for application (frame) settings\nCOLOR_SETTINGS\nA subclass of JSON_SETTINGS designed for storing color themes\nCOMMON_SETTINGS\nThe settings available to every part of KiCad\nPROJECT_FILE\nA JSON_SETTINGS representing a project (.kicad_pro) file\nPROJECT_LOCAL_SETTINGS\nA JSON_SETTINGS representing a project local state (.kicad_prl) file\nWhere Settings are Stored There are four main places a setting might be stored:\nIn COMMON_SETTINGS: this is a setting that is shared between all parts of KiCad.\nIn an application settings object (subclass of APP_SETTINGS_BASE). These objects, such as EESCHEMA_SETTINGS and PCBNEW_SETTINGS, store settings that are specific to a portion of KiCad. In particular, these objects are compiled inside the context of their respective application, so they have access to data types that may not be part of common.\nIn the PROJECT_FILE, where they will be specific to a loaded project. This is true of most of the settings found in the Board / Schematic Setup dialogs. Currently, KiCad only supports having one project loaded at a time, and a number of places in the code expect that a PROJECT object will always be available. Because of this, the SETTINGS_MANAGER will always ensure that a \"dummy\" PROJECT_FILE is available even when no project has been loaded by the user. This dummy project can be modified in memory but not saved to disk.\nIn the PROJECT_LOCAL_SETTINGS object, where they will be specific to a loaded project. This file is for settings that are \"local state\", such as which board layers are visible, that should (for many users, at least) not be checked in to source control. Any setting here should be transient, meaning there will be no ill effect if the entire file is deleted.\nJSON_SETTINGS The JSON_SETTINGS class is the backbone of the settings infrastructure. It is a subclass of the nlohmann::json::basic_json class provided by thirdparty/nlohmann_json/nlohmann/json.hpp. As such, anytime raw manipulation of the underlying JSON data is needed, you can use the standard nlohmann::json API. The JSON contents represent the state of the file on disk, not the state of the data exposed to C++. Synchronization between the two is done via parameters (see below) and takes place right after loading from disk and right before saving to disk.\nParameters Parameters establish the link between C++ data and content in the JSON file. In general, parameters consist of a path, pointer, and default value. The path is a string of the form \"x.y.z\", where each component represents a nested JSON dictionary key. The pointer is a pointer to the C++ member variable that holds the data accessible to consumers of the JSON_SETTINGS. The default value is used to update the pointer when the data is missing from the JSON file.\nParameters are subclasses of PARAM_BASE in include/settings/parameters.h. There are a number of helpful subclasses created to make it easier to store complex data in JSON files.\nThe basic PARAM class is templated and is useful for storing any data type can be serialized to JSON automatically. A basic instantiation of a PARAM might look like:\nm_params.emplace_back( new PARAM\u003cint\u003e( \"appearance.icon_scale\", \u0026m_Appearance.icon_scale, 0 ) ); Here, m_Appearance.icon_scale is a public member of the settings object (an int inside a struct). \"appearance.icon_scale\" is the path to store the value in the JSON file, and 0 is the default value. This would result in JSON looking like this:\n{ \"appearance\": { \"icon_scale\": 0 } } Note that it is possible to use custom types with PARAM\u003c\u003e as long as they have a to_json and from_json defined. See COLOR4D for an example of this.\nFor storing complex data types, it is sometimes easiest to use PARAM_LAMBDA\u003c\u003e, which allows you to define a \"getter\" and \"setter\" as part of the parameter definition. You can use this to build a nlohmann::json object and store it as the \"value\" of your parameter. For examples of how this is done, see NET_SETTINGS.\nNESTED_SETTINGS The NESTED_SETTINGS class is like a JSON_SETTINGS but instead of a file for a backing store, it uses another JSON_SETTINGS object. The entire contents of a NESTED_SETTINGS are stored as the value of a particular key in the parent file. This has two key benefits:\nYou can split up large sets of settings in to more manageable pieces\nYou can hide knowledge about the nested settings from the parent settings object\nFor example, many portions of the project file are stored as NESTED_SETTINGS objects inside the PROJECT_FILE. These objects, including SCHEMATIC_SETTINGS, NET_SETTINGS, and BOARD_DESIGN_SETTINGS, are compiled as part of eeschema or pcbnew, so they have access to data types not available in common (where PROJECT_FILE is compiled).\nWhen the outer file is loaded, all of the data for the nested settings is there in the underlying nlohmann::json data store — it’s just not used until the appropriate NESTED_SETTINGS is loaded.\nNESTED_SETTINGS objects can have shorter lifecycles than the parent. This is required because in some cases (such as with the project file), the parent can stay resident in one frame (the KiCad manager, for example) while a frame that uses a nested settings inside it can be created and destroyed. When the nested settings is destroyed, it ensures that its data is stored to the JSON data of the parent. The parent JSON_SETTINGS can then be saved to disk, if desired.\nSchema Version and Migrations Settings objects have a schema version, which is a const integer that can be incremented when a migration is needed. The schema version in the code is compared to that in the loaded file, and if the file version is lower (older), migrations are run to bring the data in the file up to date.\nMigrations are functions that are responsible for making the necessary changes from one schema version to another. They act on the underlying JSON data, before parameter loading has taken place.\nMigrations are not always needed when changing a settings file. You are free to add or remove parameters without changing the schema version or writing migrations. If you add parameters, they will be added to the JSON file and initialized to their default value. If you remove parameters, they will be silently dropped from the JSON file the next time the settings are saved. Migration is only needed when you need to make changes to the JSON file that depend on the current state. For example, if you decide to rename a settings key, but want to preserve the user’s present setting.\nIf you need to make a \"breaking change\" to a settings file:\nIncrement the schema version\nWrite a migration that makes the necessary changes to the underlying nlohmann::json object\nCall JSON_SETTINGS::registerMigration in the constructor for the object",
    "description": "The settings framework manages application settings, as well as projects. This document explains how to make use of the framework as well as some of its inner workings.\nSource Code Guide Most of the relevant code is in common/settings and common/project.\nC++ Class Description SETTINGS_MANAGER\nLoads and unloads settings files and projects\nJSON_SETTINGS\nThe base class for all settings objects. Represents a single JSON file.\nNESTED_SETTINGS\nA JSON_SETTINGS object stored within another (i.",
    "tags": [],
    "title": "Settings Framework",
    "uri": "/en/components/settings/index.html"
  },
  {
    "breadcrumb": "",
    "content": " Redirecting to Doxygen...\nIf the redirect does not occur, you can click here ",
    "description": " Redirecting to Doxygen...\nIf the redirect does not occur, you can click here ",
    "tags": [],
    "title": "Source Code Docs",
    "uri": "/en/source-doxygen/index.html"
  },
  {
    "breadcrumb": "",
    "content": " Translating the KiCad GUI KiCad translations are managed by Weblate. The Weblate project is periodically synchronized with the KiCad source code repository on GitLab to apply newly-created translations and to import new or changed source (English) text into Weblate so that it can be translated.\nPlease see the Weblate documentation for details on how to use the Weblate interface to translate KiCad.\nAt this time, the French translation of KiCad is managed outside of Weblate by Jean-Pierre Charras, so French is not available as one of the translated languages to edit in Weblate.\nPlease use the developers email list for any questions or issues relating to translating KiCad.",
    "description": "Translating the KiCad GUI KiCad translations are managed by Weblate. The Weblate project is periodically synchronized with the KiCad source code repository on GitLab to apply newly-created translations and to import new or changed source (English) text into Weblate so that it can be translated.\nPlease see the Weblate documentation for details on how to use the Weblate interface to translate KiCad.\nAt this time, the French translation of KiCad is managed outside of Weblate by Jean-Pierre Charras, so French is not available as one of the translated languages to edit in Weblate.",
    "tags": [],
    "title": "Translation",
    "uri": "/en/translation/index.html"
  },
  {
    "breadcrumb": "Rules and Guidelines",
    "content": " Introduction This document defines the guidelines for user interface development in KiCad. Developers are expected to following these guidelines as closely as possible when contributing user interface code to the KiCad project.\nFollow platform-specific guidelines Except for the cases listed below, KiCad follows the platform-specific user interface guidelines for each supported platform on that platform. This means there may be differences in UI behavior/look-and-feel between the platforms where their guidelines differ.\nThe user interface guidelines for each supported platform are:\nGNOME (GTK): https://developer.gnome.org/hig/stable/\nmacOS: https://developer.apple.com/design/human-interface-guidelines/macos/overview/themes/\nWindows: https://docs.microsoft.com/en-us/windows/win32/uxguide/guidelines\nUI behavior that is inconsistent with the platform default or that would override platform defaults/theme settings must be avoided. Text and strings Text Capitalization For all visible text used within KiCad, follow recommendations in the capitalization section in the writing style section of the GNOME User Interface Guidelines. This applies to all Menus, Titles, Labels, Tooltips, Buttons, etc.\nThe capitalization for the application names is KiCad, Eeschema, CvPcb, GerbView, and Pcbnew. All strings that have application names that are visible to the user should be capitalized this way. It’s also a good idea use this capitalization in source code comments as well to prevent confusion of new contributors.\nCapitalization Styles There are two styles of capitalization used in the user interface elements: header capitalization and sentence capitalization. This section defines the capitalization style and when each type of capitalization should be used.\nHeader Capitalization When using header capitalization all words are capitalized with the following exceptions:\nArticles: a, an, the.\nConjunctions: and, but, for, not, so, yet …​\nPrepositions of three or fewer letters: at, for, by, in, to …​\nSentence Capitalization When capitalizing sentences, capitalize the first letter of the first word, and any other words normally capitalized in sentences such as proper nouns.\nCapitalization Table The following table indicates the capitalization style to use for each type of user interface element.\nElement Style Check box labels\nSentence\nCommand button labels\nHeader\nColumn heading labels\nHeader\nDesktop background object labels\nHeader\nDialog messages\nSentence\nDrop-down combination box labels\nSentence\nDrop-down list box labels\nSentence\nField labels\nSentence\nGroup box and window frame labels\nHeader\nHypertext links\nSentence\nItems in drop-down and list controls\nSentence\nList box labels\nSentence\nMenu items\nHeader\nMenu items in applications\nHeader\nMenu titles in applications\nHeader\nProperty names displayed in the Properties Panel\nHeader\nRadio button labels\nSentence\nSlider labels\nSentence\nSpin box labels\nSentence\nTabbed section titles\nHeader\nText box labels\nSentence\nText on web pages\nSentence\nTitlebar labels\nHeader\nToolbar button labels\nHeader\nTooltips\nSentence\nWebpage titles and navigational elements\nHeader\nTrailing Periods Phrases, such as checkbox labels, button labels, dialog box titles, etc., should not have trailing periods.\nFully-formed sentences, such as error messages, should have trailing periods.\nThere are some edge-cases:\nTooltips are generally phrases and therefore have no trailing periods. However, when they are multiple sentences, each sentence in the tooltip should have a period, including the last one.\nERC and DRC messages are often sentences, but should NOT have trailing periods. This makes them easier to scan.\nEllipses in menu entries Menu entries which open a dialog to collect more information before performing an action should have an ellipsis at the end. Menu entries whose action is to open a window or dialog should not. e.g.:\nSave As…​\nChange Symbols…​\nClearance Resolution\nCalculator Tools\nQuoting Often text strings will be quoted for display which may be used in controls that render HTML. Using angle brackets will cause grief for HTML rendering controls so text should be quoted with single quotes ''. e.g.:\n'filename.kicad_pcb'\n'longpath/subdir'\n'FOOTPRINTNAME'\n'anything else'\nAbbreviations All user interface strings should be spelled out for translation purposes. The only exceptions are units such as mm, in, etc. or universally accepted abbreviations across languages such as PCB.\nDialogs This section defines how dialog boxes should be designed. The KiCad project uses the GNOME User Interface Guidelines for laying out dialogs. When designing dialogs, follow the visual layout section of the GNOME User Interface Guidelines. KiCad’s dialogs may either be designed with wxformbuilder or created by hand. Existing dialogs must be maintained in the same way as they have been implemented. Please use the latest wxformbuilder release to avoid version mismatch between developers.\nEscape Key Termination Please note that the escape key termination only works properly if there is a dialog button defined with an ID of wxID_CANCEL or setting the escape button ID using wxDialog::SetEscapeID( MY_ESCAPE_BUTTON_ID ) is called during dialog initialization. The former is the preferred method for handling escape key dialog termination. There is a checkbox in wxFormBuilder for setting the \"default\" control, and this is the one fired when the \"enter\" key is pressed.\nDialog Layout with Sizers Use wxWidgets \"sizers\" in all dialogs, no matter how simple they are. Using absolute sizing in dialogs is forbidden in KiCad. See the wxWidgets sizer overview for more information on using sizers. Configure the sizers so that as the dialog window is expanded, the most sensible use of the increased dialog window occurs automatically by the sizers. For example, in the DRC dialog of Pcbnew, sizers should be used to expand the text control to use the full available free window area, so that the user’s view of the items in the text control is maximized as he/she expands the dialog window, making it easier to read more DRC error messages. In other dialogs without one component more important than the others, the sizers might be configured to position the controls to sensible positions near the perimeter of the increasingly larger dialog box, not necessarily leaving them all bundled tightly together. The dialog box should look nice at any size large enough to show all the user interface elements.\nAvoid defining initial dialog sizes if possible. Let the sizers do their job. After the dialog is fit to the sizers, set the minimum size to the current size to prevent the dialog controls from being obscured when resizing the dialog. If the labels or text of the dialog controls are, set or changed at run time. Rerun wxWindow::Fit() to allow the dialog to re-size and adjust for the new control widths. This can all be done after the dialog is created but before it is shown or use class methods to re-size the dialog as required. Reset the minimum size to the updated dialog size.\nDialog windows should not exceed 1024 x 768 when displayed in a 13 point font. Note that the font used by end users is not something that you control from within the dialog, but for testing purposes please do not exceed this dialog size should the user have selected a font size of 13 points. If your dialog exceeds this limit, please redesign the dialog using tabs or some other paging method to reduce the size of the dialog.\nDialog Base Class The KiCad project has a base class which most if not all dialogs should be derived from. When using wxFormBuilder, please add the following settings to the \"Dialog\" tab:\nsubclass.name ← DIALOG_SHIM\nsubclass.header ← dialog_shim.h\nThis will provide for an override of the Show( bool ) wxWindow() function and provide retentive size and position for the session. For more information, see the DIALOG_SHIM class source code.\nUse tooltips to explain the functionality of each non-obvious control. This is important because the help files and the wiki often lag behind the source code.\nTransferring Data To and From Controls Dialog data must be transferred to the dialog controls on dialog initialization and transferred from controls when the dialog is dismissed by the default affirmative action (typically clicking the wxID_OK button) or the clicking the wxID_APPLY button. The wxWidgets dialog framework has support for this by using validators. Please read the wxValidator Overview in the wxWidgets documentation. In the past, data transfer was handled in various default button handlers virtually all of which were broken. Do not implement default button handlers in your dialog code. Use validators to transfer data to and from controls and allow the default dialog button handlers work the way they were designed.\nInternationalization To generate a list of strings occurring in a dialog, one needs to enable 'internationalize' checkbox in the project properties when using wxFormbuilder. Otherwise, it will not be possible to translate the dialog.",
    "description": "Rules on how the user interface elements should be implemented.",
    "tags": [],
    "title": "User Interface Policy",
    "uri": "/en/rules-guidelines/ui/index.html"
  },
  {
    "breadcrumb": "Rules and Guidelines",
    "content": " Introduction The purpose of this document is to provide the guidelines for how not to write code for the KiCad project. Anti-patterns are code practices that seem to occur often but shouldn’t. If your code contains any of these patterns, please fix them.\nDo not modify this document without the consent of the project leader. All changes to this document require approval. Bare Enumerations Bare enums are declared like this\nenum LAST_LAYOUT { NONE, ALIAS, PARENT }; These are problematic because they declare the simple keywords NONE, ALIAS and PARENT into the global scope. These then clash with enums or worse, defines, that exist in other header or source files used in the project.\nThe solution is to use scoped enums. In this form, the enum is\nenum class LAST_LAYOUT { NONE, ALIAS, PARENT }; LAST_LAYOUT l = LAST_LAYOUT::NONE; switch(l) { case LAST_LAYOUT::NONE : std::cout \u003c\u003c \"NONE\\n\"; break; case LAST_LAYOUT::ALIAS : std::cout \u003c\u003c \"ALIAS\\n\"; break; case LAST_LAYOUT::PARENT : std::cout \u003c\u003c \"PARENT\\n\"; break; } Dereferencing Pointers Dereferencing an invalid pointer almost always results in a crash. Never assume a pointer is valid. Even if the code in question has never crashed before, that doesn’t mean that someone wont break something in the future. Use assertions to help developers catch invalid pointers during development. Even better than assertions, you can use the wxWidgets debugging macros which can raise assertions on debug builds and gracefully handle run time issues in release builds. If you are concerned about pulling in wxWidgets user interface code, there are header only C++ assertion libraries available.\nAvoid the temptation to silently hide potentially bad pointers. The following code:\nvoid SomeFunction( SomeObject* somePointer ) { if( somePointer ) { somePointer-\u003eDeReferencedMethod(); } } should be replaced with:\nvoid SomeFunction( SomeObject* somePointer ) { // This will trigger a wxWidgets assertion dialog in debug builds and silently // return in release builds which is far better than crashing. wxCHECK( somePointer, /* void */ ) somePointer-\u003eDeReferencedMethod(); } wxUpdateUIEvent Abuse Avoid using wxUpdateUIEvent for anything other than the methods provided by the event object. Updating controls in a wxUpdateUIEvent handler will typically trigger other control events that in turn will fire more wxUpdateUIEvents which results in an infinite event loop that can cause the user interface to become less responsive.\nIf you are not sure you are abusing wxUpdateUIEvent, the advanced configuration setting UpdateUIEventInterval allows you to set the time in milliseconds which the update events are generated or -1 to disable all update events. If slowing or disabling the update events makes the user interface more responsive, a wxUpdateUIEvent handler is the problem.\nTranslating Partial Sentences Never break an translated sentence into multiple _() tags. This prevents translations from understanding your intention and from creating grammatically correct sentences in languages other than English.\nFor example the following is incorrect:\nShowReport( _( \"Duplicate instances of \" ) + m_changeArray[j].NewRefDes ); This should be replaced by the following:\nShowReport( wxString::Format( _( \"Duplicate instances of %s\" ), m_changeArray[j].NewRefDes ) ); The new formulation allows a translator to move the object of the sentence. In the original formulation, the object (the NewRefDes string) would always appear at the end of the sentence, which may not be grammatically correct in non-English languages.\nSimilarly, do not break sentences into parts like this:\nwxString verb = updateMode ? _( \"Update\" ) : _( \"Change\" ); wxString warning = _( \"%s all items on the board?\" ); wxMessageBox( wxString::Format( warning, verb ) ); In English, the word Update is both a noun and a verb. Without context, the translator will not know which version to use. Additionally, it will not be clear to the translator that the verb string is used by the warning string as they will not appear together in the translation file.\nInstead, we must write the sentences explicitly:\nwxString msg = updateMode ? _( \"Update all items on the board?\" ) : _( \"Change all items on the board?\" ); wxMessageBox( msg ); Dialogs Breaking Close Event Handling Modal and Quasi-modal dialog windows closure is handled automatically when the standard button IDs (wxID_OK, wxID_CANCEL, wxID_CLOSE, etc.) as well as the close button title bar decorator. There is no need to handle wxCloseEvent directly unless the dialog has special requirement such as vetoing the event. Very few dialogs require any special handling of close event. For more information see the wxWidgets closing windows documentation. If you do not fully understand the default dialog close event handling, do not implement one in your dialog. Doing so will most likely break the default handling.\nAvoid Direct Access of Parent Avoid passing a specific parent window pointer type to the dialog and saving it for use dialog methods. At best, this is a bad coding practice as it limits the re-usability of the dialog to a given parent window type. At worst, it can cause crashes in mode-less dialog windows when accessing the point in the dialog object destructor.\nIf you need to pass information to the parent window, use the wxWidgets events instead.\nThis:\nMY_DIALOG::MY_DIALOG( SCH_EDIT_FRAME* aParent ) { m_frame = aParent; } void MY_DIALOG::SomeMethod() { m_frame-\u003eSomeFrameMethod(); } should be replaced with this:\nMY_DIALOG::MY_DIALOG( wxWindow* aParent ) { } void MY_DIALOG::SomeMethod() { wxWindow* parent = GetParent(); if( parent ) { SOME_EVENT evt(); // If the parent doesn't handle this event it goes into the bit bucket. parent-\u003eHandleWindowEvent( evt ); } } Object Property Modifiers Modal and Quasi-modal dialog windows should be implemented as simple object property modifiers. Avoid modifying properties of live objects. Make a copy of the object being modified to transfer property information between the dialog controls and the object properties.\nMY_DIALOG::MY_DIALOG( wxWindow* aParent, const LIB_PIN\u0026 aPin ) { m_pinCopy( m_Pin ); // Make a copy of the LIB_PIN object to modify. } Handling the OK Button Dismissing a modal or quasi-model dialog window by clicking on the \"OK\" button does not indicate that any of the object properties have been changed. Always compare the properties from the dialog object against the properties of the original object. Only set the document modified flag if the object properties have been modified.\nMY_DIALOG dlg( this, m_somePin ); if( dlg.ShowQuasiModal() == wxID_OK \u0026\u0026 dlg.GetPin() != m_somePin ) { // Update the undo/redo handling here. m_somePin = dlg.GetPin(); // Set modified flag here. } Mode Specific Coding Avoid adding mode specific code to dialogs. The dialog cannot know how it is going to be shown in advance. Making assumptions about how the dialog is shown from within the dialog can lead to unexpected bugs.\nvoid MY_DIALOG::OnCloseEvent( wxCloseEvent\u0026 aEvent ) { // The code will clean up the dialog when it is mode-less but it also will // completely bypass the automatic data transfer handling for modal and // quasi-modal dialogs. Destroy(); } Mode-less Dialogs Memory Management wxWidgets mode-less dialogs are always created on the heap using the C `new` operator. Therefore, it is the developers responsibility to manage the memory allocated for the dialog. However, https://www.wxwidgets.org/[wxWidgets] windows object memory should never be cleaned up using the C delete operator. wxWidgets provides the Destroy() method to perform any required window tear down and then deletes the allocated memory.\nDialog Life Time wxWidgets does not guarantee that a parent window will out live a mode-less dialog created by it. Therefore, attempting to access the parent window from the dialog’s destructor (See Avoid Direct Access of Parent) may crash. If you have to access the parent from the the dialog destructor, check to make sure the dialog has been shown in either the modal or quasi-modal mode.\nDon’t do this:\nMY_DIALOG::~MY_DIALOG() { m_parent-\u003eSomeParentWindowMethod(); // May crash if the dialog is mode-less. } instead do this:\nMY_DIALOG::~MY_DIALOG() { // Ensures the parent is still valid. if( IsModal() || IsQuasiModal() m_parent-\u003eSomeParentWindowMethod(); } S-Expression File Format Anti-patterns Unquoted strings Always quote strings in KiCad file formats, whether or not they contain user-generated data or you think they might need to be quoted.\n// Do this (generator \"eeschema\") // Not this (assuming that 'eeschema' is not a token) (generator eeschema) Non-standard boolean flags Use the tokens yes and no for booleans in the file format. All boolean flags should be a two- element list of the form (token [yes|no]). Do not use implicit-true booleans. Boolean flags may be omitted from formatting where it makes sense to do so (and the parser should have a defined default value that will be assumed if the flag is missing), but if the boolean token is present, an explicit value must also be present.\n// Do this (my_item (hide yes) ) // Or this (my_item (show no) ) // Not this (an implicitly-true boolean) (my_item (hide) ) // And not this (a boolean outside an enclosing list) (my_item hide yes) Ignoring unneeded or deprecated tokens implicitly When implementing a parser that needs to skip over tokens in a file that are not needed, always do so explicitly, by parsing the tokens and doing nothing with them. Do not do this implicitly by skipping a certain number of symbols.\n// Do this for( token = NextTok(); token != T_RIGHT \u0026\u0026 token != EOF; token = NextTok() ) { if( token == T_LEFT ) token = NextTok(); switch( token ) { case T_generator: // Skip (generator \"generatorname\") NeedSYMBOL(); NeedRIGHT(); break; //... } } // Don't do this for( token = NextTok(); token != T_RIGHT \u0026\u0026 token != EOF; token = NextTok() ) { if( token == T_LEFT ) token = NextTok(); switch( token ) { case T_version: m_requiredVersion = parseInt( FromUTF8().mb_str( wxConvUTF8 ) ); NeedRIGHT(); // Skip (generator \"generatorname\") NeedLEFT(); NeedSYMBOL(); NeedSYMBOL(); NeedRIGHT(); break; //... } } Formatting \u0026 Parsing Formatting Dealing with locale is terrible and ineffiecient.\nWhen writing output for a file, avoid the use of printf, both the libc implementation and relatives like the wxString formatters.\nInstead, utilize the {fmt} library which provides locale-neutral formatting of floats and is far more performant.\ndouble x,y; fmt::print( m_file, \"ORIGIN {} {}\", x, y ); An additional benefit of fmt::print when used with a FILE* handle (optional), is its ability to throw exceptions on failed IO activity. This simplifies error handling to a top-level try/catch block instead of needing to check every function call.\nParsing When parsing files, avoid the use of strtod. strtod is dependent on the locale for correct parsing.\nInstead utilize fast_float::from_char, the fast_float::chars_format::skip_white_space option for the chars_format arg can be used to give it compatibility with strtod’s whitespace skipping ability.\ndouble dval{}; fast_float::from_chars_result res = fast_float::from_chars( str.data(), str.data() + str.size(), dval, fast_float::chars_format::skip_white_space ); std::from_char should not be used for doubles. It is not available in macOS libc++ unlike Linux and Windows even in 2025. fast_float::from_char in benchmarking is also about 2-3x faster than std::from_char.",
    "description": "Anti-pattern guidelines for writing code for the KiCad project.",
    "tags": [],
    "title": "Anti-Patterns",
    "uri": "/en/rules-guidelines/anti-patterns/index.html"
  },
  {
    "breadcrumb": "Build",
    "content": " Building KiCad on Linux To perform a full build on Linux, run the following commands:\ncd \u003cyour kicad source mirror\u003e mkdir -p build/release mkdir -p build/debug # Optional for debug build. cd build/release cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo \\ ../../ make sudo make install If the CMake configuration fails, determine the missing dependencies (see Dependencies) and install them on your system.\nIf CMake fails at finding Protobuf even after installing the dependencies, try enabling KICAD_USE_CMAKE_FINDPROTOBUF, i.e.:\ncmake -DCMAKE_BUILD_TYPE=RelWithDebInfo \\ -DKICAD_USE_CMAKE_FINDPROTOBUF=ON \\ ../../ By default, CMake sets the install path on Linux to /usr/local. Use the CMAKE_INSTALL_PREFIX option to specify a different install path.\nWe recommend using the RelWithDebInfo build type for personal release builds, as this will include debugging symbols that will give you more useful stack traces in case you encounter a crash.\nReplace RelWithDebInfo with Debug for debug builds.\nDependencies The distribution-specific packages that have to be installed to build KiCad can be found in the nightly package sources:\nDebian/Ubuntu/Linux Mint (Depends and Build-Depends fields)\nFedora Linux (Requires and BuildRequires fields)\nArch Linux/Manjaro (depends and makedepends fields)\nTips and Tricks Ninja KiCad builds faster using the Ninja build system in place of make. To use Ninja, you can specify Ninja output on your CMake command line:\ncmake -G Ninja -DCMAKE_BUILD_TYPE=RelWithDebInfo ../../ ninja sudo ninja install Linker Build speed will be further improved by using a linker different than the default BFD linker (ld), for example gold (fast), lld (faster), or mold (fastest). To change the linker, specify it by passing the -fuse-ld=\u003clinker name\u003e flag via the -DCMAKE_CXX_FLAGS CMake option:\ncmake -G Ninja -DCMAKE_BUILD_TYPE=RelWithDebInfo -DCMAKE_CXX_FLAGS=-fuse-ld=lld ../../ GCC versions lower than 12.1.0 do not support -fuse-ld=mold. Read https://github.com/rui314/mold#how-to-use to learn how to use mold in that case.",
    "description": "Instructions for Linux using gcc",
    "tags": [
      "Linux"
    ],
    "title": "Linux",
    "uri": "/en/build/linux/index.html"
  },
  {
    "breadcrumb": "Build",
    "content": " Building KiCad on macOS Building on macOS requires care, as specific versions of dependencies are required in order for all KiCad features to compile and work properly. To simplify this process, we strongly recommend that all macOS users use our kicad-mac-builder utility, which contains the toolchain that produces the official macOS release builds of KiCad.\nThis utility can be used to set up a development environment for KiCad even if you just wish to build the sources without creating a full release package (DMG containing the KiCad applications and libraries).\nBuilding without kicad-mac-builder is possible but is not supported by the KiCad development team. If you wish to pursue this route, please use the latest state of the kicad-mac-builder repository for guidance as to which packages to install and how to configure and build them.\nKiCad requires a custom fork of wxWidgets on macOS to work properly. This fork is hosted at the KiCad GitLab. Currently, the kicad/macos-wx-3.2 branch should be used to build the master branch of KiCad. If you use kicad-mac-builder to set up your build environment, the correct version of wxWidgets will be downloaded and built for you automatically. Prerequisites As of version 7, KiCad requires macOS 11 or higher to build (the build outputs can be run on some older verisons of macOS). KiCad supports Apple’s arm64 architecture as well as x86_64, and the packaging scripts can produce a \"universal binary\" that will run on either architecture. You must take care to maintain a consistent architecture when building on arm64, which kicad-mac-builder will try to ensure for you. Building some of the dependencies for arm64 and some for x86_64 will result in linker errors (or Python errors) later in the process.\nSetting up development environment using kicad-mac-builder This guide assumes you already have the appropriate Apple C++ development toolchain (Xcode) for your macOS release installed. See Apple’s documentation for details on how to install Xcode or the Xcode command-line tools. kicad-mac-builder will not install this for you.\nTo obtain kicad-mac-builder and set up the KiCad build dependencies, run the following on an Apple arm64 machine:\nsoftwareupdate --install-rosetta --agree-to-license # only required if you did not already install rosetta cd \u003cyour preferred working directory\u003e git clone https://gitlab.com/kicad/packaging/kicad-mac-builder.git cd kicad-mac-builder ./ci/arm64-on-arm64/bootstrap-arm64-on-arm64.sh WX_SKIP_DOXYGEN_VERSION_CHECK=1 ./build.py --arch arm64 --target setup-kicad-dependencies Or, on an x86_64 (Intel) machine:\ncd \u003cyour preferred working directory\u003e git clone https://gitlab.com/kicad/packaging/kicad-mac-builder.git cd kicad-mac-builder ./ci/x86_64-on-x86_64/bootstrap-x86_64-on_x86_64.sh WX_SKIP_DOXYGEN_VERSION_CHECK=1 ./build.py --arch x86_64 --target setup-kicad-dependencies The first command, boostrap.sh, will install Homebrew if it is not already installed, and install all the KiCad dependencies that are available as Homebrew packages. You may wish to manually install the required dependencies instead of running this script. If so, simply inspect the script to see the current list of required Homebrew packages to install. The example bootstrap scripts are used for native compilation on the two Apple architectures. There is also an x86_64-on-arm64 option that can be used for cross-compilation on arm64 machines. The bootstrapping scripts are designed to run in a \"clean\" installation of macOS on our CI build machines. If you already have Homebrew installed to a non-standard directory, do not run bootstrap.sh. Instead, inspect the script and adapt the commands in it to your environment. If you already have Python installed, especially if you use a tool like pyenv to manage Python versions, you must ensure that the python3 that is found first on your PATH matches the target architecture you are building KiCad for. At the end of the kicad-mac-builder build process, build.py will print a list of suggested CMake arguments to the terminal.\nIt is recommended you save either the independent list of variables OR the toolchain file path. You will need these when configuring your KiCad build. The use of the toolchain file means you only have to set -DCMAKE_TOOLCHAIN_FILE=\u003cpath\u003e in the cmake arguments later. Future reruns of KMB will keep the toolchain file updated.\nYou can rerun build.py to get all the variables again at any time.\nBuilding KiCad Now you are ready to build KiCad itself. Run the following to obtain and build KiCad:\ncd \u003cyour preferred working directory\u003e git clone https://gitlab.com/kicad/code/kicad.git cd kicad mkdir -p build/release mkdir build/debug # Optional for debug build. cd build/release cmake \u003carguments from kicad-mac-builder\u003e ../.. make make install Paste in the arguments you saved from earlier after the cmake command. Note that you may want to inspect and modify some of the arguments before using them:\nBy default, kicad-mac-builder will set the CMAKE_INSTALL_PREFIX to ./build/kicad-dest inside your kicad-mac-builder directory. Edit the arguments provided by kicad-mac-builder if you want to install KiCad to a different location.\nBy default, kicad-mac-builder will set CMAKE_BUILD_TYPE to RelWithDebInfo to create an optimized release build with debugging symbols. Change this to Debug to create an unoptimized build that can be debugged using lldb.\nWe recommend using Ninja instead of make for faster builds. To do so, run brew install ninja and then add -G Ninja to your cmake arguments. Running and debugging On macOS, starting from 7.99 nightlies, you can set the KICAD_RUN_FROM_BUILD_DIR environment variable and launch any KiCad executable from the build directory for run or debug. This is generally done in the target launch configuration options of IDEs like CLion.\nYou can also create and run the entire app bundle by running make install (or ninja install) to package a complete KiCad.app and then launch that. You can use lldb to debug the application, or attach to a running copy.\nThe installed package will be self-signed by the installation process. This will allow it to run on the local machine, but this package cannot be distributed to other machines without triggering Apple’s security measures.\nUpdating dependencies At the moment, kicad-mac-builder is designed to run in a \"clean-slate\" environment and does not automatically handle dependency updates. From time to time, you may wish to update your KiCad build dependencies. To do so:\nRun git pull inside your kicad-mac-builder folder to sync with KiCad upstream.\nDelete the contents of the ./build directory.\nRe-run the setup-kicad-dependencies step as described above.\nIt is possible to rebuild only certain dependencies by deleting certain folders inside the ./build directory, however this is an advanced usage and will not be documented here. Inspect the cmake files inside the kicad-mac-builder subdirectory to figure out what to do. ",
    "description": "Instructions for macOS using cmake and clang",
    "tags": [
      "Macos"
    ],
    "title": "macOS",
    "uri": "/en/build/macos/index.html"
  },
  {
    "breadcrumb": "Build",
    "content": " Building using MSYS2 MSYS2 is the legacy build system for Windows due to KiCad’s historical roots. KiCad has switched to MSVC (Microsoft Visual Studio) from version 6.0 and onwards for development and releases. Building via MSYS2 is still possible but does not receive a high level of attention. Setup The MSYS2 project provides packages for all of the require dependencies to build KiCad. To setup the MSYS2 build environment, download and run the MSYS2 64-bit Installer available from the msys2 home page. After the installer is finished, update to the latest package versions by running the msys2_shell.cmd file located in the MSYS2 install path and running the command pacman -Syu. If the msys2-runtime package is updated, close the shell and run msys2_shell.cmd.\nBuilding The following commands assume you are building for 64-bit Windows, and that you already have the KiCad source code in a folder called kicad-source in your home directory. See below for changes if you need to build for 32-bit instead. At the command prompt run the the following commands:\npacman -S base-devel \\ git \\ mingw-w64-ucrt-x86_64-cmake \\ mingw-w64-ucrt-x86_64-doxygen \\ mingw-w64-ucrt-x86_64-gcc \\ mingw-w64-ucrt-x86_64-python \\ mingw-w64-ucrt-x86_64-pkg-config \\ mingw-w64-ucrt-x86_64-swig \\ mingw-w64-ucrt-x86_64-boost \\ mingw-w64-ucrt-x86_64-cairo \\ mingw-w64-ucrt-x86_64-glew \\ mingw-w64-ucrt-x86_64-curl \\ mingw-w64-ucrt-x86_64-wxPython \\ mingw-w64-ucrt-x86_64-toolchain \\ mingw-w64-ucrt-x86_64-glm \\ mingw-w64-ucrt-x86_64-opencascade \\ mingw-w64-ucrt-x86_64-ngspice \\ mingw-w64-ucrt-x86_64-zlib \\ mingw-w64-ucrt-x86_64-libgit2 \\ mingw-w64-ucrt-x86_64-wxwidgets3.2-msw \\ mingw-w64-ucrt-x86_64-protobuf \\ mingw-w64-ucrt-x86_64-nng cd kicad-source mkdir -p build/release mkdir build/debug # Optional for debug build. cd build/release cmake -DCMAKE_BUILD_TYPE=Release \\ -G \"MSYS Makefiles\" \\ -DCMAKE_PREFIX_PATH=/ucrt64 \\ -DCMAKE_INSTALL_PREFIX=/ucrt64 \\ -DDEFAULT_INSTALL_PATH=/ucrt64 \\ -DOCC_INCLUDE_DIR=/ucrt64/include/opencascade \\ ../../ make -j N install # Where N is the number of concurrent threads that your system can handle. Since nng has only provided packages for CLANG64, CLANGARM64, and UCRT64 environments, this article recommends UCRT64 as the building environment. For 32-bit builds, run mingw32.exe and change ucrt-x86_64 to i686 in the package names and change the paths in the cmake configuration from /ucrt64 to /mingw32.\nmsys2 has deprecated 32-bit support due to cygwin, it’s upstream dependency eliminating 32-bit support. For debug builds, run the cmake command with -DCMAKE_BUILD_TYPE=Debug from the build/debug folder.\nMSYS2 with CLion KiCad in combiation with MSYS2 can be configured to be used with CLion to provide a nice IDE experience.\nToolchain Setup First you must register MSYS2 as a toolchain, or namely, the compiler.\nFile \u003e Preferences to open the Settings window.\nNavigate to Build, Execution, Development and then the Toolchains page.\nAdd a new toolchain, and configure it as such\nName: MSYS2-MinGW64\nEnvironment Path: \u003cyour msys2 install folder\u003e\\mingw64\\\nCMake: \u003cyour msys2 install folder\u003e\\mingw64\\bin\\cmake.exe\nAll other fields will become automatically populated.\nProject Setup File \u003e Open and select the folder containing the kicad source. CLion may attempt to start CMake generation and fail, this is ok.\nOpen the Settings window again. Navigate to Build, Execution, Development and then the CMake page. These settings are saved to the project.\nYou want to create a Debug configuration as such\nName: Debug-MSYS2\nBuild-Type: Debug\nToolchain: MSYS2-MinGW64\nCMake options:\n-G \"MinGW Makefiles\" -DCMAKE_PREFIX_PATH=/mingw64 -DCMAKE_INSTALL_PREFIX=/mingw64 -DDEFAULT_INSTALL_PATH=/mingw64 Build-directory: build/debug-msys2\nYou may now trigger the \"Reload CMake Cache\" option in CLion to generate the cmake project You should delete the \"junk\" build folder (usually name cmake-build-debug-xxxx) it may have created in the source before it was changed above. We change the build folder because we have a gitignore for /build\nWarning: Receiving warning messages about Boost versions is normal.\nKnown MSYS2 Build Issues There are some known issues that are specific to MSYS2. This section provides a list of the currently known issues when building KiCad using MSYS2.\nwxwidgets 3.1 You get an error that wxwidgets 3.1 is not found\npacman -R mingw-w64-x86_64-wxwidgets rm -rf build/release # change to your cmake cache folder pacman -S mingw-w64-x86_64-wxmsw3.1 ",
    "description": "Guide on building KiCad using MSYS2",
    "tags": [
      "Windows"
    ],
    "title": "Windows (MSYS2)",
    "uri": "/en/build/windows-msys2/index.html"
  },
  {
    "breadcrumb": "Build",
    "content": " Building using Visual Studio (2019, 2022) Environment Setup Visual Studio You must first install Visual Studio with the Desktop development with C++ feature set installed. Additionally, you’ll need to make sure the optional component C++ CMake tools for Windows is installed.\nvcpkg KiCad uses vcpkg for dependencies and uses manifest mode to declare the dependencies and our kicad registry on top of vcpkg.\nObtain vcpkg for your system from https://github.com/microsoft/vcpkg\nIn order to benefit from pre-built packages, checkout the specific vcpkg commit used by KiCad’s continuous integration pipeline. This is defined as the $vcpkgCommit variable in the build.ps1 script in the kicad-win-builder repository\nBootstrap vcpkg, so the vcpkg tool is installed\nIn summary, decide where you want vcpkg to be installed and run the following commands:\ngit clone https://github.com/microsoft/vcpkg.git cd vcpkg # Replace commit hash with that defined as $vcpkgCommit of https://gitlab.com/kicad/packaging/kicad-win-builder/-/blob/master/build.ps1 git checkout ef7dbf94b9198bc58f45951adcf1f041fcbc5ea0 .\\bootstrap-vcpkg.bat KiCad Specific Setup 1. Manual installation of SWIG SWIG must be installed manually. Obtain the latest swigwin package from https://sourceforge.net/projects/swig/files/swigwin/ (at the time of this writing, the latest is swigwin-4.1.1) and extract the zip file to a known location.\n2. Configuring NuGet package source In order to benefit from pre-built packages that will significantly speed up your first build, you should add KiCad’s package repository to your NuGet sources with the name kicad-gitlab\nFor this, you need the nuget.exe command line utility. This can be obtained at https://www.nuget.org/downloads/\nGo to the directory where your nuget.exe is located and run:\n./nuget.exe sources add -Name kicad-gitlab -Source \"https://gitlab.com/api/v4/projects/27426693/packages/nuget/index.json\" For this to work, you must ensure your local copy of vcpkg is checked out at the same commit as is used in KiCad’s continuous integration pipeline. Refer to the vcpkg section above for more details. After you check-out the commit, ensure you run .\\bootstrap-vcpkg.bat again. 3. CMakeSettings.json Contained in the build root is a CMakeSettings.json.sample\nCopy and rename this file to CMakeSettings.json\nEdit your renamed CMakeSettings.json to:\nUpdate the VcPkgDir environment variable up top to match the location of your vcpkg clone.\nUpdate the SwigExePath environment variable up top to match the location of where you extracted the SWIG tool in step 1 above.\n{ \"VcPkgDir\": \"D:/vcpkg/\" }, ... { \"SwigExePath\": \"D:/swigwin-4.1.1/swig.exe\" }, 4. \"Open Folder\" in Visual Studio Launch Visual Studio (only after completing the above steps).\nWhen the initial wizard launches, select to Open a local folder. This is the correct way to make Visual Studio directly handle CMake projects.\nSelect the build root folder.\nEnsure x64-Debug build configuration is selected. This will start the cmake configuration process and building of vcpkg dependencies. Note: You can see the progress by opening the Output window (if not already open) by navigating to View → Output\nIf correctly configured, vcpkg should download the pre-built binaries of all dependencies from the KiCad packaging repository and usually complete in about 1-10 minutes depending on your internet connection. However, if there are any differences in your build environment, this step will take a long time (several hours, depending on the speed of your computer). In particular you should double check that you checked out the correct vcpkg commit and bootstrapped. At some points, it might appear as if the process is stuck because the output window doesn’t update for many minutes (or even an hour, depending on your machine) with a message like Building x64-windows. This is nomal. Keep visual studio open until it is complete. Wait until the \"CMake in Visual Studio\" tab appears and the CMake process finishes with the message CMake generation finished.\n5. Running and debugging Running or debugging KiCad directly from the build directory through Visual Studio requires that you set certain environment variables so that KiCad can find runtime dependencies and Python works. To configure the runtime environment for programs run from Visual Studio, edit the launch.vs.json file in the project root directory. To open this file, select Debug and Launch Settings for kicad from the Debug menu.\nIf you have multiple launch configurations, for example to debug standalone pcbnew or eeschema in addition to kicad, you will need to configure each one separately. The variable KICAD_RUN_FROM_BUILD_DIR must be present (it can be set to any value) to run from the build directory. Setting this variable allows KiCad to find dynamic libraries when running from the build directory.\nThe variable KICAD_USE_EXTERNAL_PYTHONHOME must be present (it can be set to any value) when running from either the build or the install directory, which allows you to specify PYTHONHOME in the environment. Normally, KiCad on Windows uses a Python that is bundled and placed in a specific location by the installer, and when running from Visual Studio, Python will be in a different location.\nThe variable PYTHONHOME must be present and set to the location of the Python installed by vcpkg.\nThe variable PYTHONPATH must be present and set to include the paths to the pcbnew python module and the kicad_pyshell module. The former is built next to pcbnew.exe in the build directory, and the latter lives in the source tree in the scripting directory.\nUse the env section of each configuration entry to set the required environment variables, including the path to the vcpkg installed packages directory, which will allow KiCad to find dynamic libraries from dependencies. For example, the below configuration allows running and debugging kicad.exe from the build directory.\nCreate this file as \u003ckicad_source\u003e/.vs/launch.vs.json to have a baseline/working default launch configuration:\n{ \"version\": \"0.2.1\", \"defaults\": {}, \"configurations\": [ { \"type\": \"default\", \"project\": \"CMakeLists.txt\", \"projectTarget\": \"kicad.exe (kicad\\\\kicad.exe)\", \"name\": \"kicad.exe (kicad\\\\kicad.exe)\", \"env\": { \"KICAD_RUN_FROM_BUILD_DIR\": \"1\", \"KICAD_USE_EXTERNAL_PYTHONHOME\": \"1\", \"PYTHONHOME\": \"${cmake.buildRoot}\\\\vcpkg_installed\\\\x64-windows\\\\tools\\\\python3\", \"PYTHONPATH\": \"${cmake.buildRoot}\\\\pcbnew;${projectDir}\\\\scripting\", \"PATH\": \"${cmake.buildRoot}\\\\vcpkg_installed\\\\x64-windows\\\\debug\\\\bin;${cmake.buildRoot}\\\\common;${cmake.buildRoot}\\\\api;${cmake.buildRoot}\\\\common\\\\gal;${env.PATH}\" } }, { \"type\": \"default\", \"project\": \"CMakeLists.txt\", \"projectTarget\": \"pcbnew.exe (pcbnew\\\\pcbnew.exe)\", \"name\": \"pcbnew.exe (pcbnew\\\\pcbnew.exe)\", \"env\": { \"KICAD_RUN_FROM_BUILD_DIR\": \"1\", \"KICAD_USE_EXTERNAL_PYTHONHOME\": \"1\", \"PYTHONHOME\": \"${cmake.buildRoot}\\\\vcpkg_installed\\\\x64-windows\\\\tools\\\\python3\", \"PYTHONPATH\": \"${cmake.buildRoot}\\\\pcbnew;${projectDir}\\\\scripting\", \"PATH\": \"${cmake.buildRoot}\\\\vcpkg_installed\\\\x64-windows\\\\debug\\\\bin;${cmake.buildRoot}\\\\common;${cmake.buildRoot}\\\\api;${cmake.buildRoot}\\\\common\\\\gal;${env.PATH}\" } }, { \"type\": \"default\", \"project\": \"CMakeLists.txt\", \"projectTarget\": \"eeschema.exe (eeschema\\\\eeschema.exe)\", \"name\": \"eeschema.exe (eeschema\\\\eeschema.exe)\", \"env\": { \"KICAD_RUN_FROM_BUILD_DIR\": \"1\", \"KICAD_USE_EXTERNAL_PYTHONHOME\": \"1\", \"PYTHONHOME\": \"${cmake.buildRoot}\\\\vcpkg_installed\\\\x64-windows\\\\tools\\\\python3\", \"PYTHONPATH\": \"${cmake.buildRoot}\\\\pcbnew;${projectDir}\\\\scripting\", \"PATH\": \"${cmake.buildRoot}\\\\vcpkg_installed\\\\x64-windows\\\\debug\\\\bin;${cmake.buildRoot}\\\\common;${cmake.buildRoot}\\\\api;${cmake.buildRoot}\\\\common\\\\gal;${env.PATH}\" } }, { \"type\": \"default\", \"project\": \"CMakeLists.txt\", \"projectTarget\": \"gerbview.exe (gerbview\\\\gerbview.exe)\", \"name\": \"gerbview.exe (gerbview\\\\gerbview.exe)\", \"env\": { \"KICAD_RUN_FROM_BUILD_DIR\": \"1\", \"KICAD_USE_EXTERNAL_PYTHONHOME\": \"1\", \"PYTHONHOME\": \"${cmake.buildRoot}\\\\vcpkg_installed\\\\x64-windows\\\\tools\\\\python3\", \"PYTHONPATH\": \"${cmake.buildRoot}\\\\pcbnew;${projectDir}\\\\scripting\", \"PATH\": \"${cmake.buildRoot}\\\\vcpkg_installed\\\\x64-windows\\\\debug\\\\bin;${cmake.buildRoot}\\\\common;${cmake.buildRoot}\\\\api;${cmake.buildRoot}\\\\common\\\\gal;${env.PATH}\" } }, { \"type\": \"default\", \"project\": \"CMakeLists.txt\", \"projectTarget\": \"pl_editor.exe (pagelayout_editor\\\\pl_editor.exe)\", \"name\": \"pl_editor.exe (pagelayout_editor\\\\pl_editor.exe)\", \"env\": { \"KICAD_RUN_FROM_BUILD_DIR\": \"1\", \"KICAD_USE_EXTERNAL_PYTHONHOME\": \"1\", \"PYTHONHOME\": \"${cmake.buildRoot}\\\\vcpkg_installed\\\\x64-windows\\\\tools\\\\python3\", \"PYTHONPATH\": \"${cmake.buildRoot}\\\\pcbnew;${projectDir}\\\\scripting\", \"PATH\": \"${cmake.buildRoot}\\\\vcpkg_installed\\\\x64-windows\\\\debug\\\\bin;${cmake.buildRoot}\\\\common;${cmake.buildRoot}\\\\api;${cmake.buildRoot}\\\\common\\\\gal;${env.PATH}\" } }, { \"type\": \"default\", \"project\": \"CMakeLists.txt\", \"projectTarget\": \"pcb_calculator.exe (pcb_calculator\\\\pcb_calculator.exe)\", \"name\": \"pcb_calculator.exe (pcb_calculator\\\\pcb_calculator.exe)\", \"env\": { \"KICAD_RUN_FROM_BUILD_DIR\": \"1\", \"KICAD_USE_EXTERNAL_PYTHONHOME\": \"1\", \"PYTHONHOME\": \"${cmake.buildRoot}\\\\vcpkg_installed\\\\x64-windows\\\\tools\\\\python3\", \"PYTHONPATH\": \"${cmake.buildRoot}\\\\pcbnew;${projectDir}\\\\scripting\", \"PATH\": \"${cmake.buildRoot}\\\\vcpkg_installed\\\\x64-windows\\\\debug\\\\bin;${cmake.buildRoot}\\\\common;${cmake.buildRoot}\\\\api;${cmake.buildRoot}\\\\common\\\\gal;${env.PATH}\" } }, { \"type\": \"default\", \"project\": \"CMakeLists.txt\", \"projectTarget\": \"bitmap2component.exe (bitmap2component\\\\bitmap2component.exe)\", \"name\": \"bitmap2component.exe (bitmap2component\\\\bitmap2component.exe)\", \"env\": { \"KICAD_RUN_FROM_BUILD_DIR\": \"1\", \"KICAD_USE_EXTERNAL_PYTHONHOME\": \"1\", \"PYTHONHOME\": \"${cmake.buildRoot}\\\\vcpkg_installed\\\\x64-windows\\\\tools\\\\python3\", \"PYTHONPATH\": \"${cmake.buildRoot}\\\\pcbnew;${projectDir}\\\\scripting\", \"PATH\": \"${cmake.buildRoot}\\\\vcpkg_installed\\\\x64-windows\\\\debug\\\\bin;${cmake.buildRoot}\\\\common;${cmake.buildRoot}\\\\api;${cmake.buildRoot}\\\\common\\\\gal;${env.PATH}\" } } ] } Visual Studio Extras Trailing Whitespace Remover (Extension) It is highly recommended users install the Trailing Whitespace Visualizer for Visual Studio 2022 which will not only highlight trailing whitespace as you type but also automatically remove it by default when you save the file.\nnatvis definitions for libraries Visual Studio supports defining decoders for objects in debug views.\nYou can find some useful ones here:\nhttps://github.com/wxWidgets/wxWidgets/blob/master/misc/msvc/wxWidgets.natvis\nhttps://github.com/nlohmann/json/blob/develop/nlohmann_json.natvis\nhttps://github.com/Open-Cascade-SAS/OCCT/blob/master/dox/debug/occt.natvis\nSimply download the files and drop them into: %USERPROFILE%\\Documents\\Visual Studio 2022\\Visualizers\nVS will load them after it starts up.\nAdvanced It is recommended to only try these changes after getting a basic configuration working using the above steps. Binary caching By default vcpkg will bundle up each dependency and store it in a binary cache which maintains copies of all past built dependencies by version.\nThe binary cache is located usually in %LOCALAPPDATA%\\vcpkg\\archives\nIf storage space consumed is a problem.\nYou may change the location of the binary cache by setting the environment variable VCPKG_DEFAULT_BINARY_CACHE to a different path.\nor\nYou may disable binary caching by setting the environment variable VCPKG_FEATURE_FLAGS with value -binarycaching. This is not advisable as the intention of the cache is to avoid rebuilds if the application cmake cache is destroyed and rebuilt and rebuilding kicad dependencies is quite time consuming.\nManifest mode The KiCad repository is configured to use Manifest Mode.\nThe benefits of using this is that it ensures the developer’s dependencies always match that of the project so that if any dependencies are added or version bumped, they will be automatically build. The negative side of manifest mode is that whenever you update your version of visual studio or navigate the git history, you will need to rebuild vcpkg dependencies.\nIf this is deemed undesirable, it is possible to disable manifest mode locally by following these steps:\nCopy vcpkg-configuration.json from kicad root into your vcpkg root\nManually run a vcpkg install command for all dependencies currently defined in the KiCad root vcpkg.json. E.g. something like below:\n.\\vcpkg.exe install --recurse --triplet x64-windows boost-algorithm boost-bimap boost-filesystem boost-functional boost-iterator boost-locale boost-optional boost-property-tree boost-ptr-container boost-range boost-test boost-uuid cairo wxwidgets glew curl gettext[tools] harfbuzz glm opencascade[rapidjson] opengl python3 openssl sqlite3[fts5,fts4,fts3,rtree,session] icu ngspice wxpython libgit2[ssh,winhttp] nng protobuf zstd .\\vcpkg upgrade --no-dry-run Set cmake variable VCPKG_MANIFEST_MODE to OFF\nEnsure launch.vs.json PATH and PYTHONHOME variables point to the vcpkg folder (instead of the one in cmake root) - i.e. modify to be as follows:\n\"PYTHONHOME\": \"C:\\\\PATH\\\\TO\\\\vcpkg_installed\\\\x64-windows\\\\tools\\\\python3\", \"PYTHONPATH\": \"${cmake.buildRoot}\\\\pcbnew;${projectDir}\\\\scripting\", \"PATH\": \"C:\\\\PATH\\\\TO\\\\vcpkg\\\\installed\\\\x64-windows\\\\debug\\\\bin;${env.PATH}\", Delete cmake cache and reconfigure\nDisabling manifest mode means you have to manually ensure that the dependencies you have installed locally match those required by the KiCad project. Troubleshooting vcpkg cannot finish installing a dependency Antivirus software is known to block interim steps in the package build process. Try temporarily disabling your antivirus or adding an exception.\nError: Couldn’t find the versions database file If this occurs, a mismatch between vcpkg and registries occurred when it was checking your already installed libraries within the kicad build repo. The easiest fix is to simply Delete Cache and Reconfigure under the Project menu option",
    "description": "Guide on building KiCad using Microsoft Visual Studio and vcpkg",
    "tags": [
      "Windows"
    ],
    "title": "Windows (Visual Studio)",
    "uri": "/en/build/windows-msvc/index.html"
  },
  {
    "breadcrumb": "APIs and Bindings \u003e KiCad IPC API",
    "content": " API Documentation for KiCad developers The IPC API is implemented inside KiCad by a server thread that listens on a UNIX socket for connections using the nanomsg next generation (nng) protocol. At the moment, this socket operates in request-reply mode, with KiCad as the server, so asynchronous notifications to API clients is not possible. This server passes messages to the rest of KiCad using a wxWidgets event to cross onto the main (UI) thread. As with all other interactive KiCad events, the rest of API processing happens on the UI thread.\nMessages are contained within an envelope structure, which is unpacked and then dispatched to a request handler according to the type of the interior Protobuf message. Request handlers are functions that typically belong to a subclass of the API_HANDLER class. The low-level infrastructure of the API all lives in kicommon and is shared between all parts of KiCad, but request handlers are dynamically registered and so can be attached to specific frames. If a certain message does not have a handler registered to it, the API server will return an error to the client.\nHandlers are processed one by one, and it is possible to register more than one handler for a given message type. This is useful for situations where a message has some specifying target information that can narrow down its effect to a subset of available handlers. For example, the GetOpenDocuments message takes a DocumentType parameter that specifies which type of documents to query. Each open editor frame can register a handler for the same message, and return ApiStatusCode::AS_UNHANDLED if they don’t handle that type of document. In this way, the dispatcher can try to have a message handled by multiple handlers, and only return an error to the client if none of the available handlers return success.\nA block diagram showing a typical request from a Python plugin is shown below. The API is language-agnostic; kicad-python is used here as one example of a language binding.\n┌─────────────────┐ │ KiCad Internals │ └───────▲─────────┘ │ ┌───────┴─────────┐ │ REQUEST_HANDLER │ └───────▲─────────┘ │ ┌──────┴────────┐ │ API_HANDLER_* │ └──────▲────────┘ │ ┌─────┴──────┐ ┌─────────────┐ │ API_SERVER │ │ Plugin Code │ └─────▲──────┘ └─────┬───────┘ │ │ ┌───┴───┐ ┌──────▼───────┐ │ KINNG │ │ kicad-python │ └───▲───┘ └──────┬───────┘ │ │ ┌──┴──┐ ┌───▼───┐ │ nng │ │ pynng │ └──▲──┘ └───┬───┘ │ │ ┌──────┴──────┐ ┌──────▼──────┐ │ UNIX socket ◄───────────────────┤ UNIX socket │ └─────────────┘ └─────────────┘ Transport and wire protocol The underlying transport mechanism for the API is nng, which is a library providing messaging primatives, including inter-process communication (IPC). The IPC mechanism used by KiCad’s API is to serialize protocol buffers to bytes and send them over a UNIX socket. KiCad does not currently make use of any of the more advanced features of nng.\nThe socket is opened at /tmp/kicad/api.sock on macOS and Linux, and in a subdirectory of the user’s temporary file directory on Windows. If multiple instances of KiCad are launched, the socket filename for every KiCad instance other than the first will be api-\u003cPID\u003e.sock, where \u003cPID\u003e is the process identifier of the KiCad instance.\nProtocol Buffers The API itself is implemented as Protocol Buffers (protobufs), a way of describing and serializing messages that, if used correctly, can provide stability for API clients while allowing KiCad internals to evolve. It is important for every KiCad developer who works on the API to read and understand the protobuf programming best practices and API best practices, as the KiCad API attempts to follow these guidelines in most circumstances. Some of the most important practices are:\nCare must be taken whenever evolving the API in a way that seeks to deprecate, rename, or otherwise change the existing messages and fields. In general, the API should be designed as much as possible to support both the current state of KiCad and anything we know about our desired future state, to avoid needing to deprecate lots of messages in the future.\nPlain data types should used sparingly. It is almost always a better idea in terms of future- proofing and API evolution to wrap data types in a container message, even if these types are represented by a single plain old data variable in KiCad’s C++ internals. This is particularly true for boolean values: they should almost never be included in protobuf messages. Instead, an enum type should be defined that distinguishes between UNKNOWN (which should always have the value of 0) and false. This also makes it possible to swap out the boolean for a tri-state at a later point in time with no compatibility issues.\nBe careful about message nesting. It is not always a good idea to attempt to duplicate the object hierarchy of KiCad’s internal C classes into a hierarchy of messages. Sometimes, KiCad's object hierarchy comes more from developer convenience or history than logical design, and this hierarchy doesn't always make sense at an abstract conceptual level. The API should, in general, be *conceptually* logical and not have its design influenced by how KiCad's C is designed.\nEnumerations Exposing enumerations to the API requires special care to minimize the chance of bugs and compatibility issues. To expose a new C++ enum type to the API, do the following:\nDefine a new protobuf enum for the type. This enum should have a CamelCase name that clearly describes the type — use this as a chance to double-check if the KiCad type is named clearly.\nFill out the values for the protobuf enum. Each value should be an UPPER_SNAKE_CASE name, and begin with a prefix to avoid namespace conflicts (protobuf enums are implemented as plain enums, not C enum classes). That prefix is conventionally the abbreviation of the CamelCase enum name, for example `StrokeLineStyle` has values like `SLS_SOLID`, but this can be deviated from where it makes sense. The first enum value must always be `\u003cprefix\u003e_UNKNOWN` and must be assigned the value `0`. This value represents a message where this enum has not been set, and does not map to an equivalent C enum value. Because of this, and because protobuf enums may not contain negative numbers, it is generally not going to be the case that there is a 1:1 mapping between C++ enum value and protobuf enum value.\nDefine a specialization of FromProtoEnum and ToProtoEnum for your new enum. There are several source files where these specializations could go, based on what compilation unit your enum’s C++ definition lives in. For example, shared (common) enums go in common/api/api_enums.cpp.\nAdd your enum to the QA tests in qa/tests/api/test_api_enums.cpp. Check that the tests pass, which will confirm that your To/From function implementations are correct.\nNote that as enum definitions evolve over time in KiCad, the protobuf versions must never have values deleted or modified: they can only have values deprecated and new values added! Use the ToProtoEnum/FromProtoEnum functions to handle any changes in how the values should map to KiCad internals.\nAdding, Modifying, and Removing API surface Please follow these guidelines when making any changes or additions to the API or to code that depends on the API surface (for example, when adding, removing, or modifying the behavior of an object’s properties):\nNever rename, re-order, or change the functional meaning of existing fields in any Protobuf messages. The only changes permitted are to add new fields or to remove deprecated fields by commenting them out (preserving their original field index, which must never be re-used).\nNever remove fields in a bugfix release of KiCad. If a field is deprecated, add a comment above it noting the deprecation (and any replacement, if applicable). The field must remain in the message until the next major KiCad release (at minimum). If it is necessary to deprecate a field in a bugfix release, the serialization code must continue supporting the deprecated field as best as possible (for example, serializing a default value even if the field no longer exists on the source object, and accepting but ignoring the value when deserializing).\nNever remove or change the meaning of any Protobuf enum values. If enums on the KiCad side change such that a Protobuf enum value no longer makes sense, mark it as deprecated with an appropriate comment, and update the ToProtoEnum and FromProtoEnum functions to handle the deprecated value in whatever way makes sense.\nPlease document fields that are added to existing messages with a note such as // Since: 9.0.1 in the comment line above the field. These comments will be included in client bindings, so adding information about when new APIs were introduced will help make sure the binding documentation is kept up-to-date.\nObject Serialization Objects on the drawing canvas (in other words, the KiCad classes that represent \"real things\" that the user places, modifies, etc) are all subclasses of the SERIALIZABLE interface. This means that in order to expose them to the API, all you need to do is:\nDefine a protobuf message describing that object\nAdd the object to the QA tests in qa/test/api/test_api_proto.cpp — you may need to extend the api_kitchen_sink.kicad_pcb test file with instances of your object. Make sure there is at least one instance of your object that has all its properties set to non-default values for best test coverage.\nImplement the ::Serialize and ::Deserialize methods, and iterate on them until the QA tests pass.\nWhen adding new object messages, look at what exists already and try to be consistent. Design for the desired conceptual representation of an object, even if that doesn’t completely match the current C++ implementation. And only include \"concrete\" data about the objects in the message. Calculated/computed properties of an object should rarely be included in an object’s main message.\nBe careful about datatypes as well: as described above, plain data types (ints, bools, strings) are usually not the right choice to describe a property, as they can limit the ability to evolve that property over time. Prefer enums and container messages.\nUse protobuf message hierarchies sparingly — it is generally not a good idea to encode KiCad’s C++ class hierarchies into messages as described above. For example, in KiCad, a PCB_TRACK and a PCB_VIA are related by inheritance, but there are separate Track and Arc protobuf messages that duplicate their shared properties, rather than defining the Arc message as containing an inner Track message. The cost of a slight increase in code duplication is worth it because it prevents confusing/convoluted API surfaces (protobuf does not support inheritance, so the arc properties would need to be accessed as arc.track.start and arc.mid for example) and reduces interdependence between messages that could make API evolution more painful in the future.\nCommon data types The base_types.proto file contains a number of data type definitions that are used throughout the API. Use these (and expand them) instead of defining more specific types, where it makes sense. Some of the types to be aware of: KIID, Vector2, Distance, Angle, Ratio, Color, etc.\nNote that all physical distances that represent concrete object properties in the API are represented as 64-bit integer nanometer values, regardless of what part of KiCad they come from.\nAPI Handlers A handler function is any function-like construct with the following signature:\nHANDLER_RESULT\u003cResponseType\u003e( HandlerType::* aHandler )( RequestType\u0026, const HANDLER_CONTEXT\u0026 ) In this signature, RequestType and ResponseType are protobuf message classes, and HANDLER_RESULT\u003cT\u003e is a typedef for tl::expected\u003cT, ApiResponseStatus\u003e. tl::expected is a library that backports std::expected to older C++ and adds some functionality beyond the STL spec. This type represents either an expected value, or an unexpected value that contains more information about why something failed. The expected value is always just the response message that we want to send back to the client, and the unexpected value, ApiResponseStatus, is a message that contains a status code as well as an error message string.\nFor example:\ne.set_status( ApiStatusCode::AS_BAD_REQUEST ); e.set_error_message( fmt::format( \"the client {} already has a commit in progress\", aCtx.ClientName ) ); return tl::unexpected( e ); Notice that the error message begins lowercase and has no punctuation. This is because the error returned by this handler will almost always be composed with other fragments to form a full sentence (for example, the text \"KiCad API error: \" might be prepended).\nThe status code ApiStatusCode::AS_UNHANDLED is used as a special flag to note that this handler can’t handle the given request, but there was nothing in particular wrong with the request. This is used in situations when the same request is routed to multiple handlers, one after the other, in case one of them is able to handle the request.\nThe base class API_HANDLER_EDITOR is used to provide many of the common handlers that all the graphical editors in KiCad need, such as object CRUD, document retrieval, etc. This is then specialized into API_HANDLER_PCB, API_HANDLER_SCH, and so on. Handlers that don’t require an editor frame to be open are in API_HANDLER_COMMON.\nHandlers always get passed a HANDLER_CONTEXT structure that contains information about the API request that is in flight. This can be used to tell apart multiple different API clients, for example.",
    "description": "API Documentation for KiCad developers The IPC API is implemented inside KiCad by a server thread that listens on a UNIX socket for connections using the nanomsg next generation (nng) protocol. At the moment, this socket operates in request-reply mode, with KiCad as the server, so asynchronous notifications to API clients is not possible. This server passes messages to the rest of KiCad using a wxWidgets event to cross onto the main (UI) thread.",
    "tags": [],
    "title": "For KiCad Developers",
    "uri": "/en/apis-and-binding/ipc-api/for-kicad-developers/index.html"
  },
  {
    "breadcrumb": "APIs and Bindings",
    "content": " KiCad IPC API The IPC API is an interface that can be used to remotely control a running instance of KiCad. This can be used to implement KiCad plug-ins as well as to interface KiCad with external software. The API is currently under development, with the plan of stabilizing the first version for KiCad 9.0.\nOverall Design Principles The KiCad API is implemented using Protocol Buffers to define the structure and contents of messages, and NNG to transport messages between processes using UNIX sockets. This implementation supports all supported KiCad platforms, including Windows, macOS, and many Linux/BSD variants. Each running KiCad instance acts as a server when the API is enabled, and plugins and other applications act as clients which open connections to KiCad.\nKiCad is an event-driven GUI application, and like most other such applications, it operates a single thread that handles all events (background worker threads are used for certain computations to improve performance). While the API server itself is decoupled from the rest of KiCad, API events are handled like any other form of user input, and thus are synchronous. This is an important difference from other APIs that users may be used to (for example, APIs for web services) which are often asynchronous to some extent. In practice, this means a few things must be kept in mind:\nThe KiCad user may be doing something with the application that blocks the API, in order to prevent out-of-order event issues and to prevent third-party software from disrupting the user. This means that API clients need to anticipate that API messages may sometimes timeout or fail because KiCad is busy, and should have a facility to retry requests.\nAn application should not open multiple connections to KiCad at the same time. While the underlying transport layer supports this, KiCad itself will force an ordering of handling API requests and so there is no advantage to doing so.\nThe API surface described by Protocol Buffers messages (\"protobufs\") is stable following the best practices described by the Protocol Buffers team. In general, this means that new versions of KiCad may introduce new messages and fields, but will not modify the meaning of existing messages and fields. Items in the API may be deprecated over time; deprecated messages and fields will be supported for at least one major version of KiCad after the deprecation is announced.\nPlugins developed for the IPC API are launched in standalone processes that then communicate with the KiCad process that launched them. Environment variables are used to inform the plugin about the IPC socket path and a unique identifier for the running KiCad instance. This allows multiple instances of KiCad to run side-by-side and launch plugins that can communicate with the correct instance. Third-party software that is not launched as a KiCad plugin can also communicate with any running KiCad instance, however it is up to the third-party software to decide how (and if) to handle the case of multiple running KiCad instances.\nDetailed information The For KiCad Developers section contains information on the technical implementation of the API on the C++ side, and guidelines for modifying and extending the API. Please read this section before working on contributions that touch the API.\nThe For Add-on Developers section contain information for users of the API. Please read this section if you are interested in developing KiCad plugins or interfaces with third-party software.",
    "description": "KiCad IPC API The IPC API is an interface that can be used to remotely control a running instance of KiCad. This can be used to implement KiCad plug-ins as well as to interface KiCad with external software. The API is currently under development, with the plan of stabilizing the first version for KiCad 9.0.\nOverall Design Principles The KiCad API is implemented using Protocol Buffers to define the structure and contents of messages, and NNG to transport messages between processes using UNIX sockets.",
    "tags": [],
    "title": "KiCad IPC API",
    "uri": "/en/apis-and-binding/ipc-api/index.html"
  },
  {
    "breadcrumb": "APIs and Bindings \u003e KiCad IPC API",
    "content": " API Documentation for Add-on Developers The KiCad IPC API is a new feature in KiCad 9.0 that allows third-party applications to interact with KiCad. Unlike the SWIG-based Python bindings to KiCad’s PCB editor, the IPC API is designed to be a stable interface that does not change when KiCad’s internals are refactored, and does not require that KiCad build against Python directly. It is also designed to be language-agnostic, so that interoperability with software written in languages other than Python is possible.\nAPI Status and Goals The initial release of the IPC API in KiCad 9.0 is focused on a particular set of use cases that will allow many (but not all) of the things that people have built using the SWIG-based Python bindings to be done with the new API. The API will be expanded over time (and, when practical, additions will be backported to the 9.0 branch).\nThere are a few important limitations to be aware of when considering use of the IPC API:\nThe IPC API currently only supports communication with a running instance of the KiCad GUI. There is no support for running KiCad in a headless mode, and unlike the SWIG-based Python bindings, the IPC API does not provide an independent way to load and process KiCad PCB files outside of the KiCad editor. In the future, a headless mode (implemented through kicad-cli) will support third-party tools that want a way to interact with KiCad design files without running the full KiCad GUI. Even then, third-party tools will need to launch kicad-cli and then communicate with it. There are no plans to support a standalone library for loading and manipulating KiCad files separate from the client-server (IPC) model.\nThe IPC API currently has no support for plotting or exporting files from KiCad designs. This support may be added in the future, however the primary way we expect users to export files and generate other outputs from KiCad design files in an automated way is through the use of the kicad-cli tool. If you are currently relying on Python scripting for generating outputs from KiCad, we recommend moving to kicad-cli.\nIn KiCad 9.0, the IPC API and the new IPC plugin system are only implemented in the PCB editor, due to development time constraints. In the future, the IPC API will be expanded to support the schematic editor, library editors, and other parts of KiCad. While there are specific places where the IPC API has new features that are not available in the SWIG-based Python bindings, in general, the capabilities of the IPC API in KiCad 9.0 should be seen as equivalent to the Action Plugins system present since KiCad 5: a way to interact with a running KiCad PCB Editor session.\nThe API is still under active development, although after KiCad 9.0.0 is released, existing API messages will be treated as stable and will be supported according to our deprecation policy. We encourage developers to report issues and request new capabilities as they experiment with the API.\nConnecting to KiCad API clients such as scripts and plugins connect to KiCad using a Unix domain socket on macOS and Linux, and a named pipe on Windows. The socket or pipe is created by KiCad in the user’s temporary directory when KiCad is launched. The name of the socket or pipe is api.sock by default, but multiple instances of KiCad can be run simultaneously, and if this name is already taken, KiCad will append its process id number (PID) to the name to make it unique.\nWhen KiCad launches API plugins (see below), it will set several environment variables that can be used by the client to know where to connect to the IPC API. These variables include:\nKICAD_API_SOCKET: The full path to the socket or pipe that the client should connect to.\nKICAD_API_TOKEN: A generated token that the client should use in request messages. This token is generally passed to the API client library when creating a connection to KiCad (for example, in the init method of a KiCad object in kicad-python). This token is unique to the running instance of KiCad, and can be used by long-running clients to detect if KiCad restarts in the middle of a session.\nAPI clients do not need to be launched from KiCad, but if they are not (for example, if a client is launched from an IDE while developing a plugin), the client will not have access to these environment variables. For this reason, it is recommended that plugin developers run only one instance of KiCad at a time while developing and testing plugins.\nPlugin Action registration IPC plugins can register actions that appear on the PCB editor’s toolbar much like the SWIG-based Action Plugins system. There are several differences in how this is done, however:\nThe default directory for IPC plugins is ${KICAD_DOCUMENTS_HOME}/\u003cversion\u003e/plugins, where ${KICAD_DOCUMENTS_HOME} is the root path for KiCad’s user data directory, which is platform-dependent. On Windows, it is typically C:\\Users\\\u003cusername\u003e\\Documents\\KiCad, on macOS it is typically /Users/\u003cusername\u003e/Documents/KiCad, and on Linux it is typically ~/.local/share/KiCad.\nPlugins must provide a plugin.json file containing metadata about the plugin and any actions it provides. The plugin.json file must be in a subdirectory of the plugins directory, and must follow the schema defined by KiCad.\nThe plugin system currently supports two types of plugins: Python-based, and executable. Python plugins are run by an external Python interpreter (unlike the SWIG-based plugins which run in an interpreter embedded into KiCad), and KiCad will automatically manage the creation of a virtual environment for each plugin using the chosen Python interpreter. On macOS and Windows, KiCad will continue to ship with its own Python interpreter, which will be used by the IPC system by default if the user does not specify a different interpreter. On Linux, KiCad uses the first version of Python found in the user’s PATH by default. Executable plugins are run as separate processes with an arbitrary command line, and can be used to launch plugins written in compiled languages, or any other kind of external tool that does not require a Python environment.\nDebugging There are a few ways to get debug information from KiCad that might be useful while developing against the IPC API, including trace output from KiCad as well as a log of all API requests and responses.\nTo enable API-related trace output from KiCad itself (which is particularly useful for debugging Python plugins that are being loaded by KiCad), set the following environment variables before launching KiCad:\nKICAD_ALLOC_CONSOLE=1 # If you are on Windows, this variable is required to show any output KICAD_ENABLE_WXTRACE=1 # This enables KiCad's tracing system even when running a release build WXTRACE=KICAD_API # This enables trace output for the API subsystem To enable the API log file, create an advanced config file in your KiCad configuration directory if you don’t have one already (a plain text file named kicad_advanced), and add the following line:\nEnableAPILogging=1 This will create a file at ${KICAD_DOCUMENTS_HOME}/\u003cversion\u003e/logs/api.log containing every API request and response at the Protobuf message level.\nThe API log file can grow quite large, so be sure to disable it when you are done debugging. Plugins using the Python runtime are launched from a virtual environment created by KiCad for that plugin. You can find the virtual environment for each plugin located in a cache folder ${KICAD_CACHE_HOME}/python-environments/\u003cplugin_identifier\u003e. The default KICAD_CACHE_HOME is platform-dependent: ~/Library/Caches/KiCad/\u003cversion\u003e on macOS, C:\\Users\\\u003cusername\u003e\\AppData\\Local\\KiCad\\\u003cversion\u003e on Windows, and ~/.cache/KiCad/\u003cversion\u003e on most Linux systems. Activating this virtual environment will allow you to run the plugin from a terminal or IDE, manually install Python packages, and debug the plugin using the Python debugger.\nPython Bindings kicad-python is the official Python bindings library for the IPC API. It is a wrapper around the Protobuf-based API that exposes Python classes and helper methods that make it easier to interact with the IPC API from Python.\nThe kicad-python library is available on PyPI.\nAutomatically-generated documentation for kicad-python is available online at https://docs.kicad.org/kicad-python-main/.\nThere are some examples of scripts and plugins in the examples directory of the kicad-python repository that may be a good starting point for developing your own tools.",
    "description": "API Documentation for Add-on Developers The KiCad IPC API is a new feature in KiCad 9.0 that allows third-party applications to interact with KiCad. Unlike the SWIG-based Python bindings to KiCad’s PCB editor, the IPC API is designed to be a stable interface that does not change when KiCad’s internals are refactored, and does not require that KiCad build against Python directly. It is also designed to be language-agnostic, so that interoperability with software written in languages other than Python is possible.",
    "tags": [],
    "title": "For Add-on Developers",
    "uri": "/en/apis-and-binding/ipc-api/for-addon-developers/index.html"
  },
  {
    "breadcrumb": "Build",
    "content": " These are the build options that can be passed to CMake during configuration.\nAll Platforms Option Description Default KICAD_SCRIPTING_WXPYTHON\nBuild wxPython implementation for wx interface building in Python and py.shell.\nON\nKICAD_INSTALL_DEMOS\nInstall KiCad demos and examples.\nON\nKICAD_BUILD_QA_TESTS\nBuild software Quality assurance unit tests.\nON\nKICAD_SPICE\nBuild KiCad with internal Spice simulator.\nON\nKICAD_BUILD_I18N\nBuild the translation language libraries\nOFF\nKICAD_I18N_UNIX_STRICT_PATH\nInstall the language libraries to the standard UNIX install path of ${CMAKE_INSTALL_PREFIX}/share/locale\nOFF\nBUILD_SMALL_DEBUG_FILES\nIn debug build: create smaller binaries. On Windows, binaries created by link option -g3 are very large (more than 1Gb for Pcbnew, and more than 3Gb for the full KiCad suite). This option create binaries using link option -g1 that create much smaller files, but there are less info in debug (However the file names and line numbers are available).\nOFF\nMAINTAIN_PNGS\nAllow build/rebuild bitmap icons used in menus from the corresponding .svg file. Set to true if you are a PNG maintainer and have the required tools given in the bitmaps_png/CMakeLists.txt file.\nOFF\nKICAD_IPC_API\nBuild KiCad with support for the IPC API server (requires the nng library)\nON\nPlatform Specific Option Description Default KICAD_WIN32_DPI_AWARE\nTurn on DPI awareness for Windows builds only.\nOFF\nKICAD_WIN32_CONTEXT_WINFIBER\nUse win32 fibers for libcontext.\nOFF\nKICAD_USE_EGL\nBuild KiCad with EGL backend support for Wayland.\nOFF\nKICAD_USE_BUNDLED_GLEW\nUse the bundled version of GLEW - only available when KICAD_USE_EGL is set.\nOFF\nDeveloper Specific Option Description Default KICAD_SANITIZE_ADDRESS\nBuild KiCad with address sanitizer (ASan) options. WARNING: May cause errors with Gold, Lld, Mold linkers.\nOFF\nKICAD_SANITIZE_THREADS\nBuild KiCad with thread sanitizer (TSan) options. WARNING: May cause errors with Gold, Lld, Mold linkers.\nOFF\nKICAD_STDLIB_DEBUG\nBuild KiCad with libstdc++ debug flags enabled.\nOFF\nKICAD_STDLIB_LIGHT_DEBUG\nBuild KiCad with libstdc++ with -Wp,-D_GLIBCXX_ASSERTIONS flag enabled. Not as intrusive as KICAD_STDLIB_DEBUG\nOFF\nKICAD_DRC_PROTO\nBuild the DRC prototype QA tool.\nOFF\nKICAD_BUILD_PNS_DEBUG_TOOL\nBuild the P\u0026S debugging/playground QA tool.\nOFF\nKICAD_GAL_PROFILE\nEnable profiling info for GAL.\nOFF\nKICAD_USE_VALGRIND\nBuild KiCad with valgrind stack tracking enabled.\nOFF\nNotes Note 1 Python 3 is required to build KiCad. The path to Python is normally determined automatically by a CMake script, but if needed, PYTHON_EXECUTABLE can be defined when invoking cmake ( use -DPYTHON_EXECUTABLE=\u003cpython path\u003e ) to specify a particular Python binary.\nNote 2 These Symbols are always defined, and are not an option for cmake invocation:\nCOMPILING_DLL\nThis is a signal to import_export.h, and when present, toggles the interpretation of the #defines in that file. Its purpose should not be extended beyond this.\nUSE_KIWAY_DLLS\nComes from CMake as a user configuration variable, settable in the Cmake user interface. It decides if KiCad will be built with the *.kiface program modules.\nBUILD_KIWAY_DLL\nComes from CMake, but at the 2nd tier, not the top tier. By 2nd tier, something like pcbnew/CMakeLists.txt, not /CMakeLists.txt is meant. It is not a user configuration variable. Instead, the 2nd tier CMakeLists.txt file looks at the top level USE_KIWAY_DLLS and decides how the object files under the 2nd tier’s control will be built. If it decides it wants to march in lockstep with USE_KIWAY_DLLS, then this local CMakeLists.txt file may pass a defined BUILD_KIWAY_DLL (singular) on the compiler command line to the pertinent set of compilation steps under its control.\nNote 3 When building with KICAD_BUILD_I18N on Linux systems, gettext needs the rule files shared-mime-info.its and metainfo.its/appdata.its to translate the Linux metadata files.",
    "description": "Summary of CMake build configuration options.",
    "tags": [],
    "title": "Build Options",
    "uri": "/en/build/compile-options/index.html"
  },
  {
    "breadcrumb": "APIs and Bindings",
    "content": " HTTP Libraries HTTP libraries are a type of KiCad symbol library that sources data about parts for an external source such an ERP system. They do not contain any symbol or footprint definitions as standard KiCad libraries do. Instead, they reference to symbols and footprints found in other KiCad libraries.\nHTTP libraries are read only for now but will eventually support read/write in the future. At the moment only REST or REST-Like APIs are supported but support for other libraries could be added easily.\nAuthentication Authentication is done via an Access Token only; usually issued by the providing application. The token will be used in every request using the following header: 'AUTHORIZATION': 'Token usertokendatastring'.\nREST API Endpoint Definition Different to ODBC, the REST API provides the information already pre-formatted. KiCad does not know anything about tables, nor does it need to know anything about the underlying database structure of the providing application (API).\nKiCad expects a root-URL and an api-version to access the library. This must be provided via the Configuration File. There are two endpoints which will provide all data necessary to KiCad. Those are called:\ncategories\nparts\nExamples Return all parts belonging to a category with ID = 16 using the root-url and the api-version as shown in the config file: {root-url}/{api-version}/parts/category/16.json. In relation to the example config file this means: http://localhost:8000/kicad-api/v1/parts/category/16.json.\nAnother example would be using a non integer ID such as Resistors {root-url}/{api-version}/parts/category/Resistors.json.\nAs shown further below, KiCad expects an ID (numeric or not) which is used to query the API and an optional human-readable name which is displayed as part name to the user. If the API does not return the optional name key, KiCad will use the id key instead as part name.\nPlease note that KiCad expects strings only. All integers, Boolean values, doubles, floats etc must be converted to strings when responding to requests.\nEndpoint Validation KiCad queries the root-URL on {root-url}/{api-version}/ and expects it to return a dictionary with the endpoints as key-value pairs.\nHTTP_200_OK { \"categories\": \"\", \"parts\": \"\" } Note: Only keys are validated. The values can be left blank or set to the actual URL.\nFetching Categories To fetch the categories, KiCad queries {root-url}/{api-version}/categories.json using a standard GET request. KiCad expects the server to respond with a JSON formatted array holding one or more categories. It expects only an id and a name for each category and will display those as libraries inside the Symbol Chooser. Part belonging to this category will be displayed underneath those respectively.\nHTTP_200_OK [ { \"id\": \"16\", \"name\": \"Active Parts/Clock and Timer ICs\", \"description\" : \"A description of Active Parts/Clock and Timer ICs\" }, { \"id\": \"17\", \"name\": \"Active Parts/Driver ICs\", \"description\" : \"A description of Active Parts/Driver ICs\" }, { \"id\": \"20\", \"name\": \"Active Parts/Embedded Processors and Controllers\", \"description\" : \"A description of Active Parts/Embedded Processors and Controllers\" }, { \"id\": \"22\", \"name\": \"Active Parts/Interfaces\", \"description\" : \"A description of Active Parts/Interfaces\" }, { \"id\": \"15\", \"name\": \"Active Parts/Logic ICs\", \"description\" : \"A description of Active Parts/Logic ICs\" } ] Fetching Parts for Symbol Chooser To display parts underneath a certain category inside KiCad’s Symbol Chooser, KiCad queries the parts endpoint using a standard GET request: {root-url}/{api-version}/parts/category/16.json; with 16 being a numerical example ID for a specific category. As server response, KiCad expects an array containing one or more parts for that specific category.\nFor each part KiCad expects only an id. If there is a need to display a different name to the id inside the Symbol Chooser, one can use the optional name key as shown below. Additionally, one can also provide a part description using the description key.\nHTTP_200_OK [ { \"id\": \"69\", \"name\": \"830050789\", \"description\": \"CRYSTAL 32.7680KHZ 12.5PF SMD\" }, { \"id\": \"40\", \"name\": \"NE555PSR\", \"description\": \"IC OSC SINGLE TIMER 100KHZ 8SO\" }, { \"id\": \"238\", \"name\": \"TLC555CPSR\", \"description\": \"IC OSC SINGLE TIMER 2.1MHZ 8SO\" } ] TIP: Since the part details are just for the high-level overview within the Symbol Chooser, one should only respond with the minimum data needed. This will speed up the data acquiring process and consequently enhance the user experience. Therefore, KiCad expects only the minimum amount of detail needed (see example above) to display the parts inside the Symbol Chooser. Any other key/value pairs are ignored at this stage. However, the API can send the full details if that’s easier to implement and bandwidth is not a concern.\nFetching Detailed Part Information When a user clicks on a part inside the Symbol Chooser, KiCad will try to retrieve full detailed information about the part using the parts endpoint and a standard GET request: {root-url}/{api-version}/parts/16.json. KiCad expects a single JSON object with the following keys as shown below (Note: the name key is used in this example).\nThe dict fields can contain any number of additional key/value pairs; this includes being an empty dictionary! A key represents a FIELD Name which is visible in KiCad’s symbol editor. The server can provide as many fields as needed; there is no limit to it.\nEach KiCad FIELD is represented using a dict, and must contain at least the the value key. Additionally, the API can return whether or not the field is displayed using the optional visible key. If this key is not specified, KiCad will display the field by default.\nAs mentioned above all types must be converted to strings. Allowed booleans are: \"1\", \"0\", \"true\", \"false\", \"yes\", \"no\", \"y\", \"n\". The strings are case-insensitive.\nHTTP_200_OK { \"id\": \"16\", \"name\": \"R_0R0_0603_0.125W_1%\", \"symbolIdStr\": \"Device:R\", \"exclude_from_bom\": \"False\", \"exclude_from_board\": \"False\", \"exclude_from_sim\": \"True\", \"fields\": { \"footprint\": { \"value\": \"Resistor_SMD:R_0603_1608Metric\", \"visible\": \"False\" }, \"datasheet\": { \"value\": \"www.kicad.org\", \"visible\": \"False\" }, \"value\": { \"value\": \"0R0\" }, \"reference\": { \"value\": \"R\" }, \"description\": { \"value\": \"I am a resistor\", \"visible\": \"False\" }, \"keywords\": { \"value\": \"RES passive smd\", \"visible\": \"False\" }, \"custom1\": { \"value\": \"MyText1\", \"visible\": \"False\" }, \"custom2\": { \"value\": \"MyText2\", \"visible\": \"False\" }, \"custom3\": { \"value\": \"MyText3\", \"visible\": \"False\" } } } Symbol Attributes The API provides the functionality to include exclusion flags, as illustrated in the example above. These attributes serve to specify certain preferences within the KiCad software. The following exclusion flags are currently supported:\nexclude_from_bom\nexclude_from_board\nexclude_from_sim\nIt’s important to note that if one ore more of these exclusion flags are not explicitly specified, KiCad will assume that they are not set for exclusion. In other words, the default behavior is to include all items and features in the relevant processes (BOM generation, board layout, and simulation) unless otherwise specified using these exclusion flags.\nServer Response Codes If KiCad receives anything else than HTTP 200, it will simply display an error message to the user and ignore that specific request result entirely. This means that KiCad could end up not displaying some or any categories or parts at all if the API does not comply.",
    "description": "HTTP Libraries HTTP libraries are a type of KiCad symbol library that sources data about parts for an external source such an ERP system. They do not contain any symbol or footprint definitions as standard KiCad libraries do. Instead, they reference to symbols and footprints found in other KiCad libraries.\nHTTP libraries are read only for now but will eventually support read/write in the future. At the moment only REST or REST-Like APIs are supported but support for other libraries could be added easily.",
    "tags": [],
    "title": "HTTP Libraries",
    "uri": "/en/apis-and-binding/http-libraries/index.html"
  },
  {
    "breadcrumb": "APIs and Bindings",
    "content": " Deprecation notice The SWIG-based Python bindings in KiCad are deprecated as of KiCad 9.0 and will be removed in a future version. They will be replaced by the IPC API, which is a stable interface that is accessible from many languages including Python. The current plan is to remove the SWIG bindings in KiCad 10.0. This plan is subject to delay based on development timelines and community feedback. KiCad 10.0 is currently planned for release in February 2026. Check out the kicad-python library for a Pythonic interface to the IPC API.\nIntroduction KiCad implements a Python plugin interface so that external Python plugins can be run from within the PCB editor. The interface is generated using the Simplified Wrapper and Interface Generator or SWIG. SWIG is instructed to translate specific C/C++ header files into other languages using interface files. These files ultimately decide what C/C++ functions, classes and other declarations are exported and can be found in pcbnew/swig/.\nDuring build-time the SWIG interface files are used to generate the corresponding .py files. These files are installed into Python’s system-wide dist-packages repository, thus they can be imported by any Python 3 interpreter installed on the system.\nSince this interface is a raw binding layer over KiCad rather than a true API, it is unstable and will generally change between KiCad major versions. While the development team will make reasonable efforts to maintain compatiblity of function, there are no guarantees on strict compatibility, so plugins will need to handle situations such as function calls and data types being renamed from time to time. Python bindings are provided for the PCB editor only at this time. Using Python from within the other parts of KiCad is not supported. The Python binding module is called pcbnew, a reference to the internal name of the PCB Editor (which was its official name in old versions of KiCad).\nExisting PCB Editor Python Bindings documentation The PCB Editor Python bindings can be used stand-alone, i.e. no instance of the PCB Editor is running and the board project to be manipulated is loaded and saved from and to file. This approach is shown with some examples in the user’s documentation.\nAnother documentation source is the auto-generated Doxygen reference of the bindings. It can be found here:\nKiCad 6.0\nKiCad 7.0\nKiCad 8.0\nKiCad Nightly\n\"Action Plugin\" Support Besides the stand-alone usage of the generated Python plugin interface, additional support regarding online manipulation of board projects is available for the PCB Editor. Plugins using this feature are called Action Plugins and they are accessible using a PCB Editor menu entry that can be found under Tools→External Plugins. KiCad plugins that follow the Action Plugin conventions can be made to show up as external plugins in that menu and optionally as top toolbar button. The user can run the plugin resulting in calling a defined entry function in the Python plugin’s code. This function can then be used to access and manipulate the currently loaded board from the Python script environment.\nTypical Plugin Structure The Action Plugin support is implemented in the PCB editor by discovering Python packages and Python script files in specific directories on startup. In order for the discovery process to work, the following requirements must be met.\nThe plugin must be installed in the KiCad plugins search paths as documented in scripting/kicadplugins.i. You can always discover the search path for your setup by opening the scripting console and entering the command:\nimport pcbnew; print(pcbnew.PLUGIN_DIRECTORIES_SEARCH)\nCurrently on a Linux Installation the plugins search path is\n/usr/share/kicad/scripting/plugins/`\n~/.kicad/scripting/plugins\n~/.kicad_plugins/`\nOn Windows\n%KICAD_INSTALL_PATH%/share/kicad/scripting/plugins\n%APPDATA%/Roaming/kicad/scripting/plugins\nOn macOS, there is a security feature that makes it easier to add scripting plugins to the ~/Library…​ path than to kicad.app, but the search path is\n/Applications/kicad/Kicad/Contents/SharedSupport/scripting/plugins\n~/Library/Application Support/kicad/scripting/plugins\nAlternatively a symbolic link can be created in the KiCad plugin path link to the plugin file/folder in another location of the file system. This can be useful for development.\nThe plugin must be written as a simple Python script (*.py) located in the plugin search path. Note that this method is preferred for small plugins consisting of a single .py file.\nAlternatively the plugin must be implemented as a Python package conforming to the Python package standard definitions (See 6.4. Packages. Note that this method is preferred for larger plugin projects consisting of multiple .py files and resource files such as dialogs or images.\nThe Python plugin must contain a class derived from pcbnew.ActionPlugin and it’s register() method must be called within the plugin.\nThe following examples demonstrate the plugin requirements.\nSimple Plugin Example The folder structure of the simple plugin is fairly straight forward. A single Python script file is placed into a directory that is present in the KiCad plugin path.\n+ ~/.kicad_plugins/ # A folder in the KiCad plugin path - simple_plugin.py - simple_plugin.png (optional) The file simple_plugin.py contains the following.\nimport pcbnew import os class SimplePlugin(pcbnew.ActionPlugin): def defaults(self): self.name = \"Plugin Name as shown in Pcbnew: Tools-\u003eExternal Plugins\" self.category = \"A descriptive category name\" self.description = \"A description of the plugin and what it does\" self.show_toolbar_button = False # Optional, defaults to False self.icon_file_name = os.path.join(os.path.dirname(__file__), 'simple_plugin.png') # Optional, defaults to \"\" def Run(self): # The entry function of the plugin that is executed on user action print(\"Hello World\") SimplePlugin().register() # Instantiate and register to Pcbnew Note that if specified icon_file_name must contain absolute path to the plugin icon. It must be png file, recommended size is 24x24 pixels. Alpha channel for opacity is supported. If icon is not specified a generic tool icon will be used.\nAn additional property self.dark_icon_file_name may be specified to provide an alternate icon for dark window themes. If this property is not present, the icon specified in icon_file_name will be used when the dark theme is active;\nshow_toolbar_button only defines a default state for plugin toolbar button. Users can override it in the PCB Editor preferences.\nComplex Plugin Example The complex plugin example represents a single Python package that is imported on startup of the editor. When the Python package is imported, the __init__.py file is executed and is thus a perfect place to instantiate and register the plugin to KiCad. The big advantage here is, that you can modularize your plugin much better and include other files without cluttering the KiCad plugin directory. Additionally, the same plugin can be executed standalone using python -m e.g. to perform tests on the Python code. The following folder structure shows how complex plugins are implemented:\n+ ~/.kicad_plugins/ # this directory has to be in the plugin path + complex_plugin/ # The plugin directory (A Python package) - __init__.py # This file is executed when the package is imported (on PCB editor startup) - __main__.py # This file is optional. See below - complex_plugin_action.py # The ActionPlugin derived class lives here - complex_plugin_utils.py # Other Python parts of the plugin - icon.png + otherstuff/ - otherfile.png - misc.txt It is recommended to name the file containing the ActionPlugin derived class as \u003cpackage-name\u003e_action.py. In this case the file is named complex_plugin_action.py with the following contents:\nimport pcbnew import os class ComplexPluginAction(pcbnew.ActionPlugin): def defaults(self): self.name = \"A complex action plugin\" self.category = \"A descriptive category name\" self.description = \"A description of the plugin\" self.show_toolbar_button = True # Optional, defaults to False self.icon_file_name = os.path.join(os.path.dirname(__file__), 'icon.png') # Optional def Run(self): # The entry function of the plugin that is executed on user action print(\"Hello World\") The __init__.py file is then used to instantiate and register the plugin to Pcbnew as follows.\nfrom .complex_plugin_action import ComplexPluginAction # Note the relative import! ComplexPluginAction().register() # Instantiate and register to PCB editor As described in PEP 338 Python can execute packages (or modules) as scripts. This can be useful to implement a command-line stand-alone version of your KiCad plugin with minimum effort. In order to implement this feature, a __main__.py file is created in the package directory. This file can be executed by running the following command.\npython -m \u003cpackage_name\u003e Make sure that your current directory is the parent directory of the package directory when running the command. In these examples, this would be ~/.kicad_plugins. When running the command the Python interpreter runs /complex_plugin/__init__.py followed by /complex_plugin/__main__.py.",
    "description": "Deprecation notice The SWIG-based Python bindings in KiCad are deprecated as of KiCad 9.0 and will be removed in a future version. They will be replaced by the IPC API, which is a stable interface that is accessible from many languages including Python. The current plan is to remove the SWIG bindings in KiCad 10.0. This plan is subject to delay based on development timelines and community feedback. KiCad 10.",
    "tags": [],
    "title": "PCB Python Bindings",
    "uri": "/en/apis-and-binding/pcbnew/index.html"
  },
  {
    "breadcrumb": "",
    "content": " Publishing KiCad Addons This document is a guide for users and plugin developers who are interested in creating addon packages that can be installed by the KiCad plugin and content manager.\nThe Plugin and Content Manager The plugin and content manager (PCM) allows KiCad users to discover and install addon packages from public or private repositories. These addon packages may contain Python plugins, symbol or footprint libraries, color themes, and other KiCad content.\nThe KiCad team operates an official repository of addon content that is available by default to KiCad users. Users may also add other repositories, either hosted publicly by third parties or privately (for example, an internal corporate repository).\nPackaging your content A KiCad addon package consists of a compressed archive file containing a metadata file, the package content, and several optional files. The archive must be in ZIP format (compatible with the ISO 21320-1 standard). The contents of the archive file depend on the package type, but all packages must include a control file called metadata.json that is described in detail below.\nAddon archives must follow the exact folder structure listed below. Extra files that are not related to your addon are not permitted and must be stripped out of the archive. Python plugins The structure of a Python plugin archive must look like:\nArchive root |- plugins |- __init__.py |- ... |- resources |- icon.png |- metadata.json icon.png is an optional 64x64-pixel icon that will be displayed alongside your package in the PCM dialog. If no icon is supplied, the resources subdirectory may be empty or omitted.\nThe contents of the plugins subdirectory should include any Python source files and resources required by your plugin. Place your plugin directly inside the plugins subdirectory, not inside a second level of subdirectory.\nFor action plugins that supply a toolbar button icon, this icon should be smaller (24x24) and located inside the plugins subdirectory. The action plugin toolbar icon will not be used by the PCM. Content libraries The structure of a content library package must look like:\nArchive root |- footprints |- first-library.pretty |- my-footprint.kicad_mod |- ... |- second-library.pretty |- another-footprint.kicad_mod |- ... |- 3dmodels |- 3d-library.3dshapes |- my-model.stp |- my-model.wrl |- ... |- symbols |- my-symbols.kicad_sym |- ... |- resources |- icon.png |- metadata.json Each content library package must contain one or more of the footprints, 3dmodels, or symbols subdirectories. Each of these subdirectories may contain one or more libraries of the corresponding type.\nicon.png is an optional 64x64-pixel icon that will be displayed alongside your package in the PCM dialog. If no icon is supplied, the resources subdirectory may be empty or omitted.\nColor themes The structure of a color theme package must look like:\nArchive root |- colors |- my-theme.json |- resources |- icon.png |- metadata.json icon.png is an optional 64x64-pixel icon that will be displayed alongside your package in the PCM dialog. If no icon is supplied, the resources subdirectory may be empty or omitted. For color themes, it is best if the icon somehow represents the theme, for example by using the same primary colors and background color as the theme.\nMetadata file format The metadata file, metadata.json, follows a JSON schema, currently published at https://go.kicad.org/pcm/schemas/v1\nUnless otherwise noted all fields are limited to valid UTF-8 code points and 1000 characters.\nExample metadata.json for a color theme:\n{ \"$schema\": \"https://go.kicad.org/pcm/schemas/v1\", \"name\": \"My Beautiful Theme\", \"description\": \"A theme that makes KiCad truly beautiful\", \"description_full\": \"I came up with this theme in a dream one night.\", \"identifier\": \"com.github.kicad-user.kicad-beautiful-theme\", \"type\": \"colortheme\", \"author\": { \"name\": \"KiCad User\", \"contact\": { \"web\": \"https://mywebsite.com\" } }, \"maintainer\": { \"name\": \"KiCad User\", \"contact\": { \"web\": \"https://mywebsite.com\" } }, \"license\": \"CC0-1.0\", \"resources\": { \"homepage\": \"https://github.com/kicad-user/kicad-beautiful-theme\" }, \"versions\": [ { \"version\": \"1.0\", \"status\": \"stable\", \"kicad_version\": \"5.99\", \"download_sha256\": \"YOUR_SHA256_HERE\", \"download_size\": 1234, \"download_url\": \"https://github.com/YOUR/DOWNLOAD/URL/kicad-beautiful-theme.zip\", \"install_size\": 5678 } ] } Fields $schema: (optional) Must contain the URL to the current KiCad package JSON schema (https://go.kicad.org/pcm/schemas/v1)\nname: (required) The human-readable name of the package (may contain any valid UTF-8 characters)\ndescription: (required) A short free-form description of the package that will be shown in the PCM alongside the package name. May contain a maximum of 150 characters.\ndescription_full: (required) A long free-form description of the package that will be shown in the PCM when the package is selected by the user. May include line breaks.\nidentifier: (required) The unique identifier for the package. May contain only alphanumeric characters and the dash (-) symbol. Must be between 2 and 50 characters in length. Must start with a latin character and end with a latin character or a numeral. See instructions below on namespaces for guidelines for selecting an identifier.\ntype: (required) The type of the package; one of plugin, library, or colortheme.\nauthor: (required) Object containing one mandatory field, name, containing the name of the package creator. An optional contact field may be present, containing free-form fields with contact information.\nmaintainer: (optional) Semantics same as author, but containing information about the maintainer of the package. Can be omitted if same as author.\nlicense: (required) A string containing the license under which the package is distributed.\nThe license must be a valid string under Debian license rules with the following modifications:\nThe MIT license is always taken to mean the Expat license.\nThe Creative Commons licenses are permitted without a version number, indicating the author did not specify which version applies.\nStripping of trailing zeroes is not recognized.\nCERN-OHL is recognized as a valid license.\nWTFPL is recognized as a valid license.\nUnlicense is recognized as a valid license.\nThe following license strings are also valid and indicate other licensing not described above:\nopen-source: Other Open Source Initiative (OSI) approved license.\nunrestricted: Not an OSI approved license, but not restricted.\nresources: (optional) Additional resource links for the package. Place your website, github, documentation and other links here.\nkeep_on_update: (optional) (since KiCad 7.0) List of regular expressions describing which files should be kept on package update. Each file from the extracted package is tested against all regex with the $KICADX_3RD_PARTY component removed. If it matches any expression then it will not be deleted.\nIf your plugin type package archive has keepme.txt file directly in plugins directory, then path /plugins/your_package_id/keepme.txt will be tested against all regex in the list.\nFor consistency, directory delimiter will always be forward slash (/) even on windows. Tested path will have a leading forward slash.\nDots in package identifier are replaced with underscore (_) when extracted.\nWhen updating the package keep_on_update field is used as it is in the repository at the moment of update, not at the moment of previous version installation.\nExtended POSIX flavour of regular expressions is used.\nIf you want to keep all ini and bkp files on update, this regex will work: .*(\\.ini|\\.bkp)$.\nIf you want to keep all .step files from 3d models directory: ^/3dmodels/.*\\.step$\nversions: (required) A list of objects describing package versions. Each version object can contain the following keys:\nversion: (required) A string containing the version of the package (format of this is up to you).\nstatus: (required) A string containing one of the following:\nstable: This package is stable for general use.\ntesting: This package is in a testing phase, users should be cautious and report issues.\ndevelopment: This package is in a development phase and should not be expected to work fully.\ndeprecated: This package is no longer maintained.\nkicad_version: (required) The minimum required KiCad version for this package (major.minor).\nkicad_version_max: (optional) The latest KiCad version this package is compatible with (major.minor).\ndownload_sha256: (optional) A string containing a SHA-256 hash of the package archive.\ndownload_url: (optional) A string containing a direct download URL for the package archive.\ndownload_size: (optional) The size of the package archive, in bytes.\ninstall_size: (optional) The size of the package (uncompressed), in bytes.\nkeep_on_update: (optional) (since KiCad 7.0) Same semantics as corresponding field in package struct but specific to this version. Field of the package version user is updating to is used, not the package user is updating from.\nruntime: (optional) (since KiCad 9.0.1) For plugin packages, this field may be set to either \"ipc\" or \"swig\" to indicate which runtime the plugin requires. If not set, the plugin will be assumed to require the SWIG (legacy) runtime.\nThe download_* keys must only be present in the version of the metadata.json that you submit to the package metadata repository, not in the version of the file that is actually present in the package archive. It is not possible to put a valid download_sha256 value in the metadata.json file inside the archive. Submission to the official repository KiCad hosts an official addons repository that is available by default to all KiCad users. To be included in the official repository, your package must meet several requirements beyond the technical requirements described above.\nNamespacing and naming Your package identifier must be namespaced using reverse-DNS format. For example, official KiCad addons use the namespace org.kicad.packagename.\nIf your addon content is hosted on a publicly-visible code-hosting service such as GitHub or GitLab, your namespace should be based on this service. For example, com.github.username.packagename. The package identifier should generally match the repository name if there is a 1-to-1 correspondence between the package and the repository.\nYour package namespace may also be based on a domain name that you control. If there is no obvious link between the domain name you submit and the download location of your package, or if it is not otherwise clear that you control the domain name, the KiCad team may request further information before approving your submission.\nYour package identifier must be unique. The namespacing requirements above should make this easy.\nIf you are not clearly a maintainer of the project, we must have written confirmation from a maintainer that you are permitted to submit the project to the KiCad repository on their behalf.\nYour package must not be a fork or copy of an existing package in the KiCad repository, unless your fork is significantly different in scope from the original work and has a clearly unique name, or unless you are proposing to replace an abandoned project (see below).\nLicensing Packages must be licensed under a valid open-source license. Closed-source packages may be used with KiCad under a third-party repository, but all packages in the official KiCad repository must be open-source to allow for code review, issue reporting, and to maintain license compatibility with KiCad itself.\nPackages containing code (Python plugins) must be licensed under an open-source license compatible with the GNU GPL.\nPackages containing data (color themes, libraries, etc) should be licensed under a Creative Commons or similar license.\nTechnical requirements Metadata files submitted to the official repository must include the download_sha256 key in the metadata, containing a valid SHA-256 hash of the archive file.\nThe download_url must point to a publicly-accessible URL.\nPackage metadata must be in English. Package contents (for example, the language used inside a dialog created by a Python plugin) may be in any language, but the package description should clearly state if the contents are in a language other than English. At this time, KiCad does not have a built-in mechanism to allow for plugins to offer multiple language translations.\nThe package source must be hosted in a location that allows issue reporting and tracking. Examples that meet this requirement include GitHub, GitLab, Bitbucket and Sourceforge.\nContent policy Packages added to the official KiCad addon repository must follow our community Code of Conduct. The KiCad team reserves the right to review package content and metadata and reject submissions that violate this code of conduct.\nThe KiCad team makes no guarantees about the quality, security, or safety of any addon content, but will strive to maintain a general standard of security and safety. If a security, safety, or privacy issue related to a package is brought to our attention, we reserve the right to take corrective actions up to and including removing a package from the repository without advance notice. In this case, the package can be submitted to the repository again once the issue has been resolved to the satisfaction of the KiCad team.\nThe KiCad team reserves the right to modify or expand on this policy in the future in order to best meet the needs of the KiCad user community. Publishers of existing packages that become in violation of new or updated content policies will receive advance notice and have the opportunity to make changes to meet the updated policies.\nAbandoned content policy The KiCad team may consider a package published to the official repository abandoned if we are unable to contact the maintainer, or if it has bugs preventing its use on a stable version of KiCad that remain open with no feedback for longer than 90 days. In order to prevent the situation of users installing broken packages from the official repository, the KiCad team may edit (for example, by changing the kicad_version_max field) or remove packages from the repository if they have been abandoned.\nAnyone wishing to \"revive\" an abandoned project can do so either by taking over maintenance of it from the original submitter (with their permission) or by forking it and submitting it under a new name. The standard requirements for all packages will apply to the newly-forked project.\nCommercial Services Packages that link to or provide commercial services, including but not limited to PCB fabrication, component lookup and order management, must first contact the KiCad team at plugins@kicad.org to discuss commercial plugin options.\nCommercial Service FAQ Why do we need to e-mail the KiCad Team? We need to have a simple contract on file with the commercial service provider. This protects both the KiCad project and the commercial service provider.\nI wrote a plugin that only uses public APIs of a service provider. Do I need to e-mail the KiCad Team? In general, we will only deal with the service provider. They may be interested in contracting with you to build a plugin or in allowing third-party plugins generally. Either way, we need to discuss this directly with the service provider.\nWhat if the API terms of service already allow my plugin? We are not lawyers. We pay lawyers to review our contracts and make sure that the KiCad project and, by extension, our users are legally safe. We do not have the resources to review other entities' terms of service or to watch them for changes. This is one reason why we need a direct contract with the commercial service provider.\nDoesn’t this process go against the spirit of Open Source? No. We place no restrictions on users publishing and publicising their own plugins. Open Source does not require us to distribute or publish others' content.\nMy plugin formats KiCad data for easier use by a commercial service provider. Do I need to e-mail the KiCad Team? No. As long as your plugin doesn’t connect to the commercial service provider, we do not need a contract with the provider.\nI represent a commercial service provider. Can we provide a blanket allowance for developers to use our API? Yes! We love it when we can make the process of PCB creation easier for our users. Please e-mail the KiCad team at plugins@kicad.org and we’ll help to make this happen.\nSubmitting your package Once you have created a package following the guidelines above, and confirmed that your package is available for download using the URL listed in the metadata file, you can submit your package to the official KiCad addon repository.\nTo do so, you must have an account at GitLab, and submit your metadata file as a merge request to the Package Metadata repository at https://gitlab.com/kicad/addons/metadata. Create a directory inside the packages directory named the same as your package identifier, and containing the metadata.json file and any additional optional metadata files (for example, an icon) as described above. You may submit more than one new package in a single merge request as long as the packages share a namespace.\nDo not submit merge requests to the public-facing repository at https://gitlab.com/kicad/addons/repository - changes to this repository are made automatically based on changes to the metadata repository. Updating your package Updates should be submitted as additional merge requests that change the metadata.json file (and any other package files that need updating). You may submit updates to more than one package in a single merge request as long as the packages share a namespace.",
    "description": "Publishing KiCad Addons This document is a guide for users and plugin developers who are interested in creating addon packages that can be installed by the KiCad plugin and content manager.\nThe Plugin and Content Manager The plugin and content manager (PCM) allows KiCad users to discover and install addon packages from public or private repositories. These addon packages may contain Python plugins, symbol or footprint libraries, color themes, and other KiCad content.",
    "tags": [],
    "title": "KiCad Addons",
    "uri": "/en/addons/index.html"
  },
  {
    "breadcrumb": "Components",
    "content": " This document briefly outlines the structure of the tool system in the GAL canvases.\nIntroduction The GAL (Graphics Abstraction Layer) framework provides a powerful method of easily adding tools to KiCad. Compared to the older \"legacy\" canvas, GAL tools are more flexible, powerful and much easier to write.\nA GAL \"tool\" is a class which provides one or more \"actions\" to perform. An action can be a simple one-off action (e.g. \"zoom in\" or \"flip object\"), or an interactive process (e.g. \"manually edit polygon points\").\nSome examples of tools in the Pcbnew GAL are:\nThe selection tool - the \"normal\" tool. This tool enters a state where items can be added to a list of selected objects, which are then made available for other tools to act on. (pcbnew/tools/selection_tool.cpp, pcbnew/tools/selection_tool.h)\nThe edit tool - this tool is active when a component is \"picked up\", and tracks the mouse position to allow the user to move a component. Aspects of editing (e.g. flip) are also make available for use by hotkeys or other tools. (pcbnew/tools/edit_tool.cpp,pcbnew/tools/edit_tool.h)\nThe drawing tool - this tool controls the process of drawing graphics elements such as line segments and circles. (pcbnew/tools/drawing_tool.cpp,pcbnew/tools/drawing_tool.h)\nThe zoom tool - allows the user to zoom in and out.\nMajor parts of a tool There are two main aspects to tools: the actions and the the tool class.\nTool actions The TOOL_ACTION class acts as a handle for the GAL framework to call on actions provided by tools. Generally, every action, interactive or not, has a TOOL_ACTION instance. This provides:\nA \"name\", which is of the format pcbnew.ToolName.actionName, which is used internally to dispatch the action\nA \"scope\", which determines when the tools is available:\nAS_CONTEXT, when the action is specific to a particular tool. For example, pcbnew.InteractiveDrawing.incWidth increases the width of a line while the line is still being drawn.\nAS_GLOBAL, when the tool can always be invoked, by a hotkey, or during the execution of a different tool. For example, the zoom actions can be accessed from the selection tool’s menu during the interactive selection process.\nA \"default hotkey\", which is used if the user doesn’t provide their own configuration.\nA \"menu item\", which is the (translatable) string shown when this tool is accessed from a menu.\nA \"menu description\", which is the string shown in the menu item’s tooltip and provides a more detailed description if needed.\nAn \"icon\", which is shown in menus and on buttons for the action\n\"Flags\" which include:\nAF_ACTIVATE which indicates that the tool enters an active state. When a tool is active it will keep receiving UI events, such as mouse clicks or key presses, which are normally handled in an event loop (see TOOL_INTERACTIVE::Wait()).\nA parameter, which allows different actions to call the same function with different effects, for example \"step left\" and \"step right\".\nThe tool class GAL tools inherit the TOOL_BASE class. A Pcbnew tool will generally inherit from PCB_TOOL, which is a TOOL_INTERACTIVE, which is a TOOL_BASE. Eeschema tools inherit directly from TOOL_INTERACTIVE.\nThe tool class for a tool can be fairly lightweight - much of the functionality is inherited from the tool’s base classes. These base classes provide access to several things, particularly:\nAccess to the parent frame (a wxWindow, which can be used to modify the viewport, set cursors and status bar content, etc.\nUse the function getEditFrame\u003cT\u003e(), where T is the frame subclass you want. In PCB_TOOL, this is likely PCB_EDIT_FRAME.\nAccess to the TOOL_MANAGER which can be used to access other tools' actions.\nAccess to the \"model\" (some sort of EDA_ITEM) which backs the tool.\nAccess with getModel\u003cT\u003e(). In PCB_TOOL, the model type T is BOARD, which can be used to access and modify the PCB content.\nAccess to the KIGFX::VIEW and KIGFX::VIEW_CONTROLS, which are used to manipulate the GAL canvas.\nThe major parts of tool’s implementation are the functions used by the TOOL_MANAGER to set up and manage the tool:\nConstructor and destructor to establish whatever class members are required.\nThe TOOL_BASE class requires a string to be passed for the tool name, which normally looks like pcbnew.ToolName.\nInit() function (optional), which is commonly used to fill in a context menu, either belonging to this tool, or access another tool’s menu and add items to that. This function is called once, when the tool is registered with the tool manager.\nReset() function, called when the model (e.g. the BOARD) is reloaded, when the GAL canvas is switched, and also just after tool registration. Any resource claimed from the GAL view or the model must be released in this function, as they could become invalid.\nsetTransitions() function, which maps tool actions to functions within the tool class.\nOne or more functions to call when actions are invoked. Many actions can invoke the same function if desired. The functions have the following signature:\nint TOOL_CLASS::FunctionName( const TOOL_EVENT\u0026 aEvent )\nReturning 0 means success.\nThese functions are called by the TOOL_MANAGER in case an associated event arrives (association is created with TOOL_INTERACTIVE::Go() function).\nThese can generally be private, as they are not called directly by any other code, but are invoked by the tool manager’s coroutine framework according to the setTransitions() map.\nInteractive actions The action handlers for an interactive actions handle repeated actions from the tool manager in a loop, until an action indicating that the tool should exit.\nInteractive tools also normally indicate that they are active with a cursor change and by setting a status string.\nint TOOL_NAME::someAction( const TOOL_EVENT\u0026 aEvent ) { auto\u0026 frame = *getEditFrame\u003cPCB_EDIT_FRAME\u003e(); // set tool hint and cursor (actually looks like a crosshair) frame.SetToolID( ID_LOCAL_RATSNEST_BUTT, wxCURSOR_PENCIL, _( \"Select item to move left\" ) ); getViewControls()-\u003eShowCursor( true ); // activate the tool, now it will be the first one to receive events // you can skip this, if you are writing a handler for a single action // (e.g. zoom in), opposed to interactive tool that requires further // events to operate (e.g. dragging a component) Activate(); // the main event loop while( OPT_TOOL_EVENT evt = Wait() ) { if( evt-\u003eIsCancel() || evt-\u003eIsActivate() ) { // end of interactive tool break; } else if( evt-\u003eIsClick( BUT_LEFT ) ) { // do something here } // other events... } // reset the PCB frame to how it was when we got it frame.SetToolID( ID_NO_TOOL_SELECTED, wxCURSOR_DEFAULT, wxEmptyString ); getViewControls()-\u003eShowCursor( false ); return 0; } The tool menu Top level tools, i.e. tools that the user enters directly, usually provide their own context menu. Tools that are called only from other tools' interactive modes add their menu items to those tools' menus.\nTo use a TOOL_MENU in a top level tool, simply add one as a member and initialize it with a reference to the tools at construction time:\nclass TOOL_NAME: public PCB_TOOL { public: TOOL_NAME() : PCB_TOOL( \"pcbnew.MyNewTool\" ), m_menu( *this ) {} private: TOOL_MENU m_menu; } You can then add a menu accessor, or provide a custom function to allow other tools to add any other actions, or a subset that you think appropriate.\nYou can then invoke the menu from an interactive tool loop by calling m_menu.ShowContextMenu(). Clicking on the tool’s entry in this menu will trigger the action - there is no further action needed in your tool’s event loop.\nCommit objects The COMMIT class manages changes to EDA_ITEMS, which combines changes on any number of items into a single undo/redo action. When editing PCBs, changes to the PCB are managed by the derived BOARD_COMMIT class.\nThis class takes either a PCB_BASE_FRAME or a PCB_TOOL as an argument. Using PCB_TOOL is more appropriate for a GAL tool, since there’s no need to go though a frame class if not required.\nThe procedure of a commit is:\nConstruct an appropriate COMMIT object\nBefore modifying any item, add it to the commit with Modify( item ) so that the current item state can be stored as an undo point.\nWhen adding a new item, call Add( item ). Do not delete the added item, unless you are going to abort the commit.\nWhen removing an item, call Remove( item ). You should not delete the removed item, it will be stored in the undo buffer.\nFinalize the commit with Push( \"Description\" ). If you performed no modifications, additions or removals, this is a no-op, so you don’t need to check if you made any changes before pushing.\nIf you want to abort a commit, you can just destruct it, without calling Push(). The underlying model won’t be updated.\nAs an example:\n// Construct commit from current PCB_TOOL BOARD_COMMIT commit( this ); BOARD_ITEM* modifiedItem = getSomeItemToModify(); // tell the commit we're going to change the item commit.Modify( modifiedItem ); // update the item modifiedItem-\u003eMove( x, y ); // create a new item PCB_SHAPE* newItem = new PCB_SHAPE; // ... set up item here // add to commit commit.Add( newItem ); // update the model and add the undo point commit.Push( \"Modified one item, added another\" ); Tutorial: Adding a new tool Without getting too heavily into the details of how the GAL tool framework is implemented under the surface, let’s look at how you could add a brand new tool to Pcbnew. Our tool will have the following (rather useless) functions:\nAn interactive tool which will allow the user to select a point, choose from the items at that point and then move that item 10mm to the left.\nWhile in this mode, the context menu will have more options:\nUse of the \"normal\" canvas zoom and grid options\nA non-interactive tool which will add a fixed circle at a fixed point.\nA way to invoke the non-interactive \"unfill all zones\" tool from the PCB_EDITOR_CONTROL tool.\nDeclare tool actions {#declare-actions} The first step is to add tool actions. We will implement two actions named:\nPcbnew.UselessTool.MoveItemLeft - the interactive tool\nPcbnew.UselessTool.FixedCircle - the non-interactive tool.\nThe \"unfill tool\" already exists with the name pcbnew.EditorControl.zoneUnfillAll.\nThis guide assumes we will be adding a tool to Pcbnew, but the procedure for other GAL-capable canvases will be similar.\nIn pcbnew/tools/pcb_actions.h, we add the following to the PCB_ACTIONS class, which declares our tools:\nstatic TOOL_ACTION uselessMoveItemLeft; static TOOL_ACTION uselessFixedCircle; Definitions of actions generally happen in the .cpp of the relevant tool. It doesn’t actually matter where the definition occurs (the declaration is enough to use the action), as long as it’s linked in the end. Similar tools should always be defined together.\nIn our case, since we’re making a new tool, this will be in pcbnew/tools/useless_tool.cpp. If adding actions to existing tools, the prefix of the tool string (e.g. \"Pcbnew.UselessTool\") will be a strong indicator as to where to define the tool.\nThe tools definitions look like this:\nTOOL_ACTION COMMON_ACTIONS::uselessMoveItemLeft( \"pcbnew.UselessTool.MoveItemLeft\", AS_GLOBAL, MD_CTRL + MD_SHIFT + int( 'L' ), _( \"Move item left\" ), _( \"Select and move item left\" ) ); TOOL_ACTION COMMON_ACTIONS::uselessFixedCircle( \"pcbnew.UselessTool.FixedCircle\", AS_GLOBAL, MD_CTRL + MD_SHIFT + int( 'C' ), _( \"Fixed circle\" ), _( \"Add a fixed size circle in a fixed place\" ), add_circle_xpm ); We have defined hotkeys for each action, and they are both global. This means you can use Shift+Ctrl+L and Shift-Ctrl-C to access each tool respectively.\nWe defined an icon for one of the tools, which should appear in any menu the item is added to, along with the given label and explanatory tooltip.\nWe now have two actions defined, but they are not connected to anything. We need to define a functions which implement the right actions. You can add these to an existing tool (for example PCB_EDITOR_CONTROL, which deals with many general PCB modification operation like zone filling), or you can write a whole new tool to keep things separate and give you more scope for adding tool state.\nWe will write our own tool to demonstrate the process.\nAdd tool class declaration Add a new tool class header pcbnew/tools/useless_tool.h containing the following class:\nclass USELESS_TOOL : public PCB_TOOL { public: USELESS_TOOL(); ~USELESS_TOOL(); ///\u003e React to model/view changes void Reset( RESET_REASON aReason ) override; ///\u003e Basic initialization bool Init() override; ///\u003e Bind handlers to corresponding TOOL_ACTIONs void setTransitions() override; private: ///\u003e 'Move selected left' interactive tool int moveLeft( const TOOL_EVENT\u0026 aEvent ); ///\u003e Internal function to perform the move left action void moveLeftInt(); ///\u003e Add a fixed size circle int fixedCircle( const TOOL_EVENT\u0026 aEvent ); ///\u003e Menu model displayed by the tool. TOOL_MENU m_menu; }; Implement tool class methods In the pcbnew/tools/useless_tool.cpp, implement the required methods. In this file, you might also add free function helpers, other classes, and so on.\nYou will need to add this file to the pcbnew/CMakeLists.txt to build it.\nBelow you will find the contents of useless_tool.cpp:\n#include \"useless_tool.h\" #include \u003cclass_draw_panel_gal.h\u003e #include \u003cview/view_controls.h\u003e #include \u003cview/view.h\u003e #include \u003ctool/tool_manager.h\u003e #include \u003cboard_commit.h\u003e // For frame ToolID values #include \u003cpcbnew_id.h\u003e // For action icons #include \u003cbitmaps.h\u003e // Items tool can act on #include \u003cclass_board_item.h\u003e #include \u003cclass_drawsegment.h\u003e // Access to other PCB actions and tools #include \"pcb_actions.h\" #include \"selection_tool.h\" /* * Tool-specific action definitions */ TOOL_ACTION PCB_ACTIONS::uselessMoveItemLeft( \"pcbnew.UselessTool.MoveItemLeft\", AS_GLOBAL, MD_CTRL + MD_SHIFT + int( 'L' ), _( \"Move item left\" ), _( \"Select and move item left\" ) ); TOOL_ACTION PCB_ACTIONS::uselessFixedCircle( \"pcbnew.UselessTool.FixedCircle\", AS_GLOBAL, MD_CTRL + MD_SHIFT + int( 'C' ), _( \"Fixed circle\" ), _( \"Add a fixed size circle in a fixed place\" ), add_circle_xpm ); /* * USELESS_TOOL implementation */ USELESS_TOOL::USELESS_TOOL() : PCB_TOOL( \"pcbnew.UselessTool\" ), m_menu( *this ) { } USELESS_TOOL::~USELESS_TOOL() {} void USELESS_TOOL::Reset( RESET_REASON aReason ) { } bool USELESS_TOOL::Init() { auto\u0026 menu = m_menu.GetMenu(); // add our own tool's action menu.AddItem( PCB_ACTIONS::uselessFixedCircle ); // add the PCB_EDITOR_CONTROL's zone unfill all action menu.AddItem( PCB_ACTIONS::zoneUnfillAll ); // Add standard zoom and grid tool actions m_menu.AddStandardSubMenus( *getEditFrame\u003cPCB_BASE_FRAME\u003e() ); return true; } void USELESS_TOOL::moveLeftInt() { // we will call actions on the selection tool to get the current // selection. The selection tools will handle item disambiguation PCB_SELECTION_TOOL* selectionTool = m_toolMgr-\u003eGetTool\u003cPCB_SELECTION_TOOL\u003e(); assert( selectionTool ); // call the actions m_toolMgr-\u003eRunAction( PCB_ACTIONS::selectionClear, true ); m_toolMgr-\u003eRunAction( PCB_ACTIONS::selectionCursor, true ); selectionTool-\u003eSanitizeSelection(); const SELECTION\u0026 selection = selectionTool-\u003eGetSelection(); // nothing selected, return to event loop if( selection.Empty() ) return; BOARD_COMMIT commit( this ); // iterate BOARD_ITEM* container, moving each item for( auto item : selection ) { commit.Modify( item ); item-\u003eMove( wxPoint( -5 * IU_PER_MM, 0 ) ); } // push commit - if selection were empty, this is a no-op commit.Push( \"Move left\" ); } int USELESS_TOOL::moveLeft( const TOOL_EVENT\u0026 aEvent ) { auto\u0026 frame = *getEditFrame\u003cPCB_EDIT_FRAME\u003e(); // set tool hint and cursor (actually looks like a crosshair) frame.SetToolID( ID_NO_TOOL_SELECTED, wxCURSOR_PENCIL, _( \"Select item to move left\" ) ); getViewControls()-\u003eShowCursor( true ); Activate(); // handle tool events for as long as the tool is active while( OPT_TOOL_EVENT evt = Wait() ) { if( evt-\u003eIsCancel() || evt-\u003eIsActivate() ) { // end of interactive tool break; } else if( evt-\u003eIsClick( BUT_RIGHT ) ) { m_menu.ShowContextMenu(); } else if( evt-\u003eIsClick( BUT_LEFT ) ) { // invoke the main action logic moveLeftInt(); // keep showing the edit cursor getViewControls()-\u003eShowCursor( true ); } } // reset the PCB frame to how it was we got it frame.SetToolID( ID_NO_TOOL_SELECTED, wxCURSOR_DEFAULT, wxEmptyString ); getViewControls()-\u003eShowCursor( false ); // exit action return 0; } int USELESS_TOOL::fixedCircle( const TOOL_EVENT\u0026 aEvent ) { // new circle to add (ideally use a smart pointer) PCB_SHAPE* circle = new PCB_SHAPE; // Set the circle attributes circle-\u003eSetShape( S_CIRCLE ); circle-\u003eSetWidth( 5 * IU_PER_MM ); circle-\u003eSetStart( wxPoint( 50 * IU_PER_MM, 50 * IU_PER_MM ) ); circle-\u003eSetEnd( wxPoint( 80 * IU_PER_MM, 80 * IU_PER_MM ) ); circle-\u003eSetLayer( LAYER_ID::F_SilkS ); // commit the circle to the BOARD BOARD_COMMIT commit( this ); commit.Add( circle ); commit.Push( _( \"Draw a circle\" ) ); return 0; } void USELESS_TOOL::setTransitions() { Go( \u0026USELESS_TOOL::fixedCircle, PCB_ACTIONS::uselessFixedCircle.MakeEvent() ); Go( \u0026USELESS_TOOL::moveLeft, PCB_ACTIONS::uselessMoveItemLeft.MakeEvent() ); } Register the tool The last step is to register the tool in the tool manager.\nThis is done in the frame’s setupTools() function for whichever EDA_DRAW_FRAME support that tool.\nBuild and run When this is all done, you should have modified the following files:\npcbnew/tools/common_actions.h - action declarations\npcbnew/tools/useless_tool.h - tool header\npcbnew/tools/useless_tool.cpp - action definitions and tool implementation\npcbnew/tools/tools_common.cpp - registration of the tool\npcbnew/CMakeLists.txt - for building the new .cpp files\nWhen you run Pcbnew, you should be able to press Shift+Ctrl+L to enter the \"move item left\" tool - the cursor will change to a crosshair and \"Select item to move left\" appears in the bottom right corner.\nWhen you right-click, you get a menu, which contains an entry for our \"create fixed circle\" tool and one for the existing \"unfill all zones\" tool which we added to the menu. You can also use Shift+Ctrl+C to access the fixed circle action.\nCongratulations, you have just created your first KiCad tool!",
    "description": "This document briefly outlines the structure of the tool system in the GAL canvases.\nIntroduction The GAL (Graphics Abstraction Layer) framework provides a powerful method of easily adding tools to KiCad. Compared to the older \"legacy\" canvas, GAL tools are more flexible, powerful and much easier to write.\nA GAL \"tool\" is a class which provides one or more \"actions\" to perform. An action can be a simple one-off action (e.",
    "tags": [],
    "title": "Tool Framework",
    "uri": "/en/components/tool-framework/index.html"
  },
  {
    "breadcrumb": "Components",
    "content": " The KiCad plugin system is a framework for extending the capabilities of KiCad using shared libraries. One of the main advantages of using a plugin is that it is not necessary to rebuild the KiCad suite while developing a plugin; in fact, plugins can be built with the aid of a very small set of headers from the KiCad source tree. Removing the requirement to build KiCad during plugin development greatly increases productivity by ensuring that the developer only compiles code directly related to the plugin which is being developed and thus reducing the time required for each build and test cycle.\nPlugins were initially developed for the 3D model viewer to make it possible to support more types of 3D models without requiring major changes to the KiCad source for each new model type supported. The plugin framework was later generalized so that in the future developers can create different classes of plugins. Currently only 3D plugins are implemented within KiCad but it is envisioned that a PCB plugin will eventually be developed to make it possible for users to implement data Importers and Exporters.\nPlugin Classes Plugins are divided into Plugin Classes since each plugin addresses problems in a specific domain and therefore requires an interface unique to that domain. For example, the 3D model plugins load 3D model data from files and translate that data into a format which can be displayed by the 3D viewer. A PCB Import/Export plugin would take PCB data and export to other electrical or mechanical data formats, or translate a foreign format into a KiCad PCB. At the moment only the 3D Plugin Class has been developed and it will be the focus of this document.\nImplementing a Plugin Class requires creating code within the KiCad source tree which manages the loading of plugin code. Within the KiCad source tree, the file plugins/ldr/pluginldr.h declares the base class for all plugin loaders. This class declares the most basic functions which we would expect to find in any KiCad plugin (boilerplate code) and its implementation provides basic checks on version compatibility between the plugin loader and the available plugins. The header plugins/ldr/3d/pluginldr3D.h declares a loader for the 3D Plugin Class. The loader is responsible for loading a given plugin and making its functions available to KiCad. Each instance of a plugin loader represents an actual plugin implementation and acts as a transparent bridge between KiCad and the plugin’s features. The loader is not the only code required within KiCad to support plugins: we also need code to discover the plugins and code to invoke the functions of the plugins via the plugin loader. In the case of the 3D plugins the discovery and invocation functions are all contained within the S3D_CACHE class.\nPlugin developers do not need to be concerned with the details of KiCad’s internal code for managing plugins unless a new Plugin Class is being developed; a plugin only needs to define the functions declared by their specific plugin class.\nThe header include/plugins/kicad_plugin.h declares the generic functions required of all KiCad plugins; these functions identify the Plugin Class, provide the name of the specific plugin, provide version information for the Plugin Class API, provide version information for the specific plugin, and provide a basic version compatibility check on the Plugin Class API. In brief, these functions are:\n/* Return a UTF-8 string naming the Plugin Class */ char const* GetKicadPluginClass( void ); /* Return version information for the Plugin Class API */ void GetClassVersion( unsigned char* Major, unsigned char* Minor, unsigned char* Patch, unsigned char* Revision ); /* Return true if the version check implemented in the plugin determines that the given Plugin Class API is compatible. */ bool CheckClassVersion( unsigned char Major, unsigned char Minor, unsigned char Patch, unsigned char Revision ); /* Return the name of the specific plugin, for example \"PLUGIN_3D_VRML\" */ const char* GetKicadPluginName( void ); /* Return version information for the specific plugin */ void GetPluginVersion( unsigned char* Major, unsigned char* Minor, unsigned char* Patch, unsigned char* Revision ); Plugin Class: PLUGIN_3D The header include/plugins/3d/3d_plugin.h declares the functions which must be implemented by all 3D plugins and defines a number of functions which are required by the plugin and which the user must not reimplement. The defined functions which the user must not reimplement are:\n/* Returns the Plugin Class name \"PLUGIN_3D\" */ char const* GetKicadPluginClass( void ); /* Return version information for the PLUGIN_3D API */ void GetClassVersion( unsigned char* Major, unsigned char* Minor, unsigned char* Patch, unsigned char* Revision ); /* Performs basic version checks enforced by the developers of the loader for the PLUGIN_3D class and returns true if the checks pass */ bool CheckClassVersion( unsigned char Major, unsigned char Minor, unsigned char Patch, unsigned char Revision ); The functions which the user must implement are as follows:\n/* Return the number of extension strings supported by the plugin */ int GetNExtensions( void ); /* Return the requested extension string; valid values are 0 to GetNExtensions() - 1 */ char const* GetModelExtension( int aIndex ); /* Return the total number of file filters supported by the plugin */ int GetNFilters( void ); /* Return the file filter requested; valid values are 0 to GetNFilters() - 1 */ char const* GetFileFilter( int aIndex ); /* Return true if the plugin can render this type of 3D model. In some cases a plugin may not yet provide a visual model and must return false. */ bool CanRender( void ); /* Load the specified model and return a pointer to its visual model data */ SCENEGRAPH* Load( char const* aFileName ); Tutorials: 3D Plugin Class This section contains a description of two very simple plugins of the PLUGIN_3D class and walks the user through the setup and building of the code.\nBasic 3D Plugin This tutorial walks the user through the development of a very basic 3D plugin named \"PLUGIN_3D_DEMO1\". The purpose of this tutorial is only to demonstrate the construction of a very basic 3D plugin which does nothing other than provide a few filter strings which permit the KiCad user to filter file names while browsing for 3D models. The code demonstrated here is the absolute minimum requirement for any 3D plugin and can be used as a template for creating more advanced plugins.\nIn order to build the demo project we require the following:\nCMake\nKiCad plugin headers\nKiCad Scene Graph library kicad_3dsg\nTo automatically detect the KiCad headers and library we shall use a CMake FindPackage script; the script supplied in this tutorial should work on Linux and Windows if the relevant header files are installed to ${KICAD_ROOT_DIR}/kicad and the KiCad Scene Graph library is installed in ${KICAD_ROOT_DIR}/lib.\nTo start let’s create a project directory and the FindPackage script:\nmkdir demo \u0026\u0026 cd demo export DEMO_ROOT=${PWD} mkdir CMakeModules \u0026\u0026 cd CMakeModules cat \u003e FindKICAD.cmake \u003c\u003c _EOF find_path( KICAD_INCLUDE_DIR kicad/plugins/kicad_plugin.h PATHS ${KICAD_ROOT_DIR}/include $ENV{KICAD_ROOT_DIR}/include DOC \"Kicad plugins header path.\" ) if( NOT ${KICAD_INCLUDE_DIR} STREQUAL \"KICAD_INCLUDE_DIR-NOTFOUND\" ) # attempt to extract the version information from sg_version.h find_file( KICAD_SGVERSION sg_version.h PATHS ${KICAD_INCLUDE_DIR} PATH_SUFFIXES kicad/plugins/3dapi NO_DEFAULT_PATH ) if( NOT ${KICAD_SGVERSION} STREQUAL \"KICAD_SGVERSION-NOTFOUND\" ) # extract the \"#define KICADSG_VERSION*\" lines file( STRINGS ${KICAD_SGVERSION} _version REGEX \"^#define.*KICADSG_VERSION.*\" ) foreach( SVAR ${_version} ) string( REGEX MATCH KICADSG_VERSION_[M,A,J,O,R,I,N,P,T,C,H,E,V,I,S]* _VARNAME ${SVAR} ) string( REGEX MATCH [0-9]+ _VALUE ${SVAR} ) if( NOT ${_VARNAME} STREQUAL \"\" AND NOT ${_VALUE} STREQUAL \"\" ) set( _${_VARNAME} ${_VALUE} ) endif() endforeach() #ensure that NOT SG3D_VERSION* will evaluate to '0' if( NOT _KICADSG_VERSION_MAJOR ) set( _KICADSG_VERSION_MAJOR 0 ) endif() if( NOT _KICADSG_VERSION_MINOR ) set( _KICADSG_VERSION_MINOR 0 ) endif() if( NOT _KICADSG_VERSION_PATCH ) set( _KICADSG_VERSION_PATCH 0 ) endif() if( NOT _KICADSG_VERSION_REVISION ) set( _KICADSG_VERSION_REVISION 0 ) endif() set( KICAD_VERSION ${_KICADSG_VERSION_MAJOR}.${_KICADSG_VERSION_MINOR}.${_KICADSG_VERSION_PATCH}.${_KICADSG_VERSION_REVISION} ) unset( KICAD_SGVERSION CACHE ) endif() endif() find_library( KICAD_LIBRARY NAMES kicad_3dsg PATHS ${KICAD_ROOT_DIR}/lib $ENV{KICAD_ROOT_DIR}/lib ${KICAD_ROOT_DIR}/bin $ENV{KICAD_ROOT_DIR}/bin DOC \"Kicad scenegraph library path.\" ) include( FindPackageHandleStandardArgs ) FIND_PACKAGE_HANDLE_STANDARD_ARGS( KICAD REQUIRED_VARS KICAD_INCLUDE_DIR KICAD_LIBRARY KICAD_VERSION VERSION_VAR KICAD_VERSION ) mark_as_advanced( KICAD_INCLUDE_DIR ) set( KICAD_VERSION_MAJOR ${_KICADSG_VERSION_MAJOR} CACHE INTERNAL \"\" ) set( KICAD_VERSION_MINOR ${_KICADSG_VERSION_MINOR} CACHE INTERNAL \"\" ) set( KICAD_VERSION_PATCH ${_KICADSG_VERSION_PATCH} CACHE INTERNAL \"\" ) set( KICAD_VERSION_TWEAK ${_KICADSG_VERSION_REVISION} CACHE INTERNAL \"\" ) _EOF Kicad and its plugin headers must be installed; if they are installed to a user directory or under /opt on Linux, or you are using Windows, you will need to set the KICAD_ROOT_DIR environment variable to point to the directory containing the KiCad include and lib directories. For OS X the FindPackage script presented here may require some adjustments.\nTo configure and build the tutorial code we will use CMake and create a CMakeLists.txt script file:\ncd ${DEMO_ROOT} cat \u003e CMakeLists.txt \u003c\u003c _EOF # declare the name of the project project( PLUGIN_DEMO ) # check that we have a version of CMake with all required features cmake_minimum_required( VERSION 2.8.12 FATAL_ERROR ) # inform CMake of where to find the FindKICAD script set( CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/CMakeModules ) # attempt to discover the installed kicad headers and library # and set the variables: # KICAD_INCLUDE_DIR # KICAD_LIBRARY find_package( KICAD 1.0 REQUIRED ) # add the kicad include directory to the compiler's search path include_directories( ${KICAD_INCLUDE_DIR}/kicad ) # create a plugin named s3d_plugin_demo1 add_library( s3d_plugin_demo1 MODULE src/s3d_plugin_demo1.cpp ) _EOF The first demo project is very basic; it consists of a single file with no external link dependencies other than the compiler defaults. We start by creating a source directory:\ncd ${DEMO_ROOT} mkdir src \u0026\u0026 cd src export DEMO_SRC=${PWD} Now we create the plugin source itself:\ns3d_plugin_demo1.cpp #include \u003ciostream\u003e // the 3d_plugin.h header defines the functions required of 3D plugins #include \"plugins/3d/3d_plugin.h\" // define the version information of this plugin; do not confuse this // with the Plugin Class version which is defined in 3d_plugin.h #define PLUGIN_3D_DEMO1_MAJOR 1 #define PLUGIN_3D_DEMO1_MINOR 0 #define PLUGIN_3D_DEMO1_PATCH 0 #define PLUGIN_3D_DEMO1_REVNO 0 // implement the function which provides users with this plugin's name const char* GetKicadPluginName( void ) { return \"PLUGIN_3D_DEMO1\"; } // implement the function which provides users with this plugin's version void GetPluginVersion( unsigned char* Major, unsigned char* Minor, unsigned char* Patch, unsigned char* Revision ) { if( Major ) *Major = PLUGIN_3D_DEMO1_MAJOR; if( Minor ) *Minor = PLUGIN_3D_DEMO1_MINOR; if( Patch ) *Patch = PLUGIN_3D_DEMO1_PATCH; if( Revision ) *Revision = PLUGIN_3D_DEMO1_REVNO; return; } // number of extensions supported; on *NIX systems the extensions are // provided twice - once in lower case and once in upper case letters #ifdef _WIN32 #define NEXTS 7 #else #define NEXTS 14 #endif // number of filter sets supported #define NFILS 5 // define the extension strings and filter strings which this // plugin will supply to the user static char ext0[] = \"wrl\"; static char ext1[] = \"x3d\"; static char ext2[] = \"emn\"; static char ext3[] = \"iges\"; static char ext4[] = \"igs\"; static char ext5[] = \"stp\"; static char ext6[] = \"step\"; #ifdef _WIN32 static char fil0[] = \"VRML 1.0/2.0 (*.wrl)|*.wrl\"; static char fil1[] = \"X3D (*.x3d)|*.x3d\"; static char fil2[] = \"IDF 2.0/3.0 (*.emn)|*.emn\"; static char fil3[] = \"IGESv5.3 (*.igs;*.iges)|*.igs;*.iges\"; static char fil4[] = \"STEP (*.stp;*.step)|*.stp;*.step\"; #else static char ext7[] = \"WRL\"; static char ext8[] = \"X3D\"; static char ext9[] = \"EMN\"; static char ext10[] = \"IGES\"; static char ext11[] = \"IGS\"; static char ext12[] = \"STP\"; static char ext13[] = \"STEP\"; static char fil0[] = \"VRML 1.0/2.0 (*.wrl;*.WRL)|*.wrl;*.WRL\"; static char fil1[] = \"X3D (*.x3d;*.X3D)|*.x3d;*.X3D\"; static char fil2[] = \"IDF 2.0/3.0 (*.emn;*.EMN)|*.emn;*.EMN\"; static char fil3[] = \"IGESv5.3 (*.igs;*.iges;*.IGS;*.IGES)|*.igs;*.iges;*.IGS;*.IGES\"; static char fil4[] = \"STEP (*.stp;*.step;*.STP;*.STEP)|*.stp;*.step;*.STP;*.STEP\"; #endif // instantiate a convenient data structure for accessing the // lists of extension and filter strings static struct FILE_DATA { char const* extensions[NEXTS]; char const* filters[NFILS]; FILE_DATA() { extensions[0] = ext0; extensions[1] = ext1; extensions[2] = ext2; extensions[3] = ext3; extensions[4] = ext4; extensions[5] = ext5; extensions[6] = ext6; filters[0] = fil0; filters[1] = fil1; filters[2] = fil2; filters[3] = fil3; filters[4] = fil4; #ifndef _WIN32 extensions[7] = ext7; extensions[8] = ext8; extensions[9] = ext9; extensions[10] = ext10; extensions[11] = ext11; extensions[12] = ext12; extensions[13] = ext13; #endif return; } } file_data; // return the number of extensions supported by this plugin int GetNExtensions( void ) { return NEXTS; } // return the indexed extension string char const* GetModelExtension( int aIndex ) { if( aIndex \u003c 0 || aIndex \u003e= NEXTS ) return NULL; return file_data.extensions[aIndex]; } // return the number of filter strings provided by this plugin int GetNFilters( void ) { return NFILS; } // return the indexed filter string char const* GetFileFilter( int aIndex ) { if( aIndex \u003c 0 || aIndex \u003e= NFILS ) return NULL; return file_data.filters[aIndex]; } // return false since this plugin does not provide visualization data bool CanRender( void ) { return false; } // return NULL since this plugin does not provide visualization data SCENEGRAPH* Load( char const* aFileName ) { // this dummy plugin does not support rendering of any models return NULL; } This source file meets all the minimum requirements to implement a 3D plugin. The plugin does not produce any data for rendering models but it can provide KiCad with a list of supported model file extensions and file extension filters to enhance the 3D model file selection dialog. Within KiCad the extension strings are used to select the plugins which may be used to load a specified model; for example, if the plugin is wrl then KiCad will invoke each plugin which claims to support the extension wrl until a plugin returns visualization data. The file filters provided by each plugin are passed to the 3D file selector dialog to improve the browsing UI.\nTo build the plugin:\ncd ${DEMO_ROOT} # export KICAD_ROOT_DIR if necessary mkdir build \u0026\u0026 cd build cmake .. \u0026\u0026 make The plugin will be built but not installed; you must copy the plugin file to KiCad’s plugin directory if you wish to load the plugin.\nAdvanced 3D Plugin This tutorial walks the user through the development of a 3D plugin named \"PLUGIN_3D_DEMO2\". The purpose of this tutorial is to demonstrate the construction of a very basic scene graph which the KiCad previewer can render. The plugin claims to handle files of type txt. Although the file must exist in order for the cache manager to invoke the plugin, the file contents are not processed by this plugin; instead, the plugin simply creates a scene graph containing a pair of tetrahedra. This tutorial assumes that the first tutorial had been completed and that the CMakeLists.txt and FindKICAD.cmake script files have been created.\nPlace the new source file in the same directory as the previous tutorial’s source file and we will extend the previous tutorial’s CMakeLists.txt file to build this tutorial. Since this plugin will create a scene graph for KiCad we need to link to KiCad’s scene graph library kicad_3dsg. KiCad’s Scene Graph Library provides a set of classes which can be used to build the Scene Graph Object; the Scene Graph Object is an intermediate data visualization format used by the 3D Cache Manager. All plugins which support model visualization must translate the model data into a scene graph via this library.\nThe first step is to extend CMakeLists.txt to build this tutorial project:\ncd ${DEMO_ROOT} cat \u003e\u003e CMakeLists.txt \u003c\u003c _EOF add_library( s3d_plugin_demo2 MODULE src/s3d_plugin_demo2.cpp ) target_link_libraries( s3d_plugin_demo2 ${KICAD_LIBRARY} ) _EOF Now we change to the source directory and create the source file:\ncd ${DEMO_SRC} s3d_plugin_demo2.cpp #include \u003ccmath\u003e // 3D Plugin Class declarations #include \"plugins/3d/3d_plugin.h\" // interface to KiCad Scene Graph Library #include \"plugins/3dapi/ifsg_all.h\" // version information for this plugin #define PLUGIN_3D_DEMO2_MAJOR 1 #define PLUGIN_3D_DEMO2_MINOR 0 #define PLUGIN_3D_DEMO2_PATCH 0 #define PLUGIN_3D_DEMO2_REVNO 0 // provide the name of this plugin const char* GetKicadPluginName( void ) { return \"PLUGIN_3D_DEMO2\"; } // provide the version of this plugin void GetPluginVersion( unsigned char* Major, unsigned char* Minor, unsigned char* Patch, unsigned char* Revision ) { if( Major ) *Major = PLUGIN_3D_DEMO2_MAJOR; if( Minor ) *Minor = PLUGIN_3D_DEMO2_MINOR; if( Patch ) *Patch = PLUGIN_3D_DEMO2_PATCH; if( Revision ) *Revision = PLUGIN_3D_DEMO2_REVNO; return; } // number of extensions supported #ifdef _WIN32 #define NEXTS 1 #else #define NEXTS 2 #endif // number of filter sets supported #define NFILS 1 static char ext0[] = \"txt\"; #ifdef _WIN32 static char fil0[] = \"demo (*.txt)|*.txt\"; #else static char ext1[] = \"TXT\"; static char fil0[] = \"demo (*.txt;*.TXT)|*.txt;*.TXT\"; #endif static struct FILE_DATA { char const* extensions[NEXTS]; char const* filters[NFILS]; FILE_DATA() { extensions[0] = ext0; filters[0] = fil0; #ifndef _WIN32 extensions[1] = ext1; #endif return; } } file_data; int GetNExtensions( void ) { return NEXTS; } char const* GetModelExtension( int aIndex ) { if( aIndex \u003c 0 || aIndex \u003e= NEXTS ) return NULL; return file_data.extensions[aIndex]; } int GetNFilters( void ) { return NFILS; } char const* GetFileFilter( int aIndex ) { if( aIndex \u003c 0 || aIndex \u003e= NFILS ) return NULL; return file_data.filters[aIndex]; } // return true since this plugin can provide visualization data bool CanRender( void ) { return true; } // create the visualization data SCENEGRAPH* Load( char const* aFileName ) { // For this demonstration we create a tetrahedron (tx1) consisting // of a SCENEGRAPH (VRML Transform) which in turn contains 4 // SGSHAPE (VRML Shape) objects representing each of the sides of // the tetrahedron. Each Shape is associated with a color (SGAPPEARANCE) // and a SGFACESET (VRML Geometry-\u003eindexedFaceSet). Each SGFACESET is // associated with a vertex list (SGCOORDS), a per-vertex normals // list (SGNORMALS), and a coordinate index (SGCOORDINDEX). One shape // is used to represent each face so that we may use per-vertex-per-face // normals. // // The tetrahedron in turn is a child of a top level SCENEGRAPH (tx0) // which has a second SCENEGRAPH child (tx2) which is a transformation // of the tetrahedron tx1 (rotation + translation). This demonstrates // the reuse of components within the scene graph hierarchy. // define the vertices of the tetrahedron // face 1: 0, 3, 1 // face 2: 0, 2, 3 // face 3: 1, 3, 2 // face 4: 0, 1, 2 double SQ2 = sqrt( 0.5 ); SGPOINT vert[4]; vert[0] = SGPOINT( 1.0, 0.0, -SQ2 ); vert[1] = SGPOINT( -1.0, 0.0, -SQ2 ); vert[2] = SGPOINT( 0.0, 1.0, SQ2 ); vert[3] = SGPOINT( 0.0, -1.0, SQ2 ); // create the top level transform; this will hold all other // scenegraph objects; a transform may hold other transforms and // shapes IFSG_TRANSFORM* tx0 = new IFSG_TRANSFORM( true ); // create the transform which will house the shapes IFSG_TRANSFORM* tx1 = new IFSG_TRANSFORM( tx0-\u003eGetRawPtr() ); // add a shape which we will use to define one face of the tetrahedron; // shapes hold facesets and appearances IFSG_SHAPE* shape = new IFSG_SHAPE( *tx1 ); // add a faceset; these contain coordinate lists, coordinate indices, // vertex lists, vertex indices, and may also contain color lists and // their indices. IFSG_FACESET* face = new IFSG_FACESET( *shape ); IFSG_COORDS* cp = new IFSG_COORDS( *face ); cp-\u003eAddCoord( vert[0] ); cp-\u003eAddCoord( vert[3] ); cp-\u003eAddCoord( vert[1] ); // coordinate indices - note: enforce triangles; // in real plugins where it is not necessarily possible // to determine which side a triangle is visible from, // 2 point orders must be specified for each triangle IFSG_COORDINDEX* coordIdx = new IFSG_COORDINDEX( *face ); coordIdx-\u003eAddIndex( 0 ); coordIdx-\u003eAddIndex( 1 ); coordIdx-\u003eAddIndex( 2 ); // create an appearance; appearances are owned by shapes // magenta IFSG_APPEARANCE* material = new IFSG_APPEARANCE( *shape); material-\u003eSetSpecular( 0.1, 0.0, 0.1 ); material-\u003eSetDiffuse( 0.8, 0.0, 0.8 ); material-\u003eSetAmbient( 0.2, 0.2, 0.2 ); material-\u003eSetShininess( 0.2 ); // normals IFSG_NORMALS* np = new IFSG_NORMALS( *face ); SGVECTOR nval = S3D::CalcTriNorm( vert[0], vert[3], vert[1] ); np-\u003eAddNormal( nval ); np-\u003eAddNormal( nval ); np-\u003eAddNormal( nval ); // // Shape2 // Note: we reuse the IFSG* wrappers to create and manipulate new // data structures. // shape-\u003eNewNode( *tx1 ); face-\u003eNewNode( *shape ); coordIdx-\u003eNewNode( *face ); cp-\u003eNewNode( *face ); np-\u003eNewNode( *face ); // vertices cp-\u003eAddCoord( vert[0] ); cp-\u003eAddCoord( vert[2] ); cp-\u003eAddCoord( vert[3] ); // indices coordIdx-\u003eAddIndex( 0 ); coordIdx-\u003eAddIndex( 1 ); coordIdx-\u003eAddIndex( 2 ); // normals nval = S3D::CalcTriNorm( vert[0], vert[2], vert[3] ); np-\u003eAddNormal( nval ); np-\u003eAddNormal( nval ); np-\u003eAddNormal( nval ); // color (red) material-\u003eNewNode( *shape ); material-\u003eSetSpecular( 0.2, 0.0, 0.0 ); material-\u003eSetDiffuse( 0.9, 0.0, 0.0 ); material-\u003eSetAmbient( 0.2, 0.2, 0.2 ); material-\u003eSetShininess( 0.1 ); // // Shape3 // shape-\u003eNewNode( *tx1 ); face-\u003eNewNode( *shape ); coordIdx-\u003eNewNode( *face ); cp-\u003eNewNode( *face ); np-\u003eNewNode( *face ); // vertices cp-\u003eAddCoord( vert[1] ); cp-\u003eAddCoord( vert[3] ); cp-\u003eAddCoord( vert[2] ); // indices coordIdx-\u003eAddIndex( 0 ); coordIdx-\u003eAddIndex( 1 ); coordIdx-\u003eAddIndex( 2 ); // normals nval = S3D::CalcTriNorm( vert[1], vert[3], vert[2] ); np-\u003eAddNormal( nval ); np-\u003eAddNormal( nval ); np-\u003eAddNormal( nval ); // color (green) material-\u003eNewNode( *shape ); material-\u003eSetSpecular( 0.0, 0.1, 0.0 ); material-\u003eSetDiffuse( 0.0, 0.9, 0.0 ); material-\u003eSetAmbient( 0.2, 0.2, 0.2 ); material-\u003eSetShininess( 0.1 ); // // Shape4 // shape-\u003eNewNode( *tx1 ); face-\u003eNewNode( *shape ); coordIdx-\u003eNewNode( *face ); cp-\u003eNewNode( *face ); np-\u003eNewNode( *face ); // vertices cp-\u003eAddCoord( vert[0] ); cp-\u003eAddCoord( vert[1] ); cp-\u003eAddCoord( vert[2] ); // indices coordIdx-\u003eAddIndex( 0 ); coordIdx-\u003eAddIndex( 1 ); coordIdx-\u003eAddIndex( 2 ); // normals nval = S3D::CalcTriNorm( vert[0], vert[1], vert[2] ); np-\u003eAddNormal( nval ); np-\u003eAddNormal( nval ); np-\u003eAddNormal( nval ); // color (blue) material-\u003eNewNode( *shape ); material-\u003eSetSpecular( 0.0, 0.0, 0.1 ); material-\u003eSetDiffuse( 0.0, 0.0, 0.9 ); material-\u003eSetAmbient( 0.2, 0.2, 0.2 ); material-\u003eSetShininess( 0.1 ); // create a copy of the entire tetrahedron shifted Z+2 and rotated 2/3PI IFSG_TRANSFORM* tx2 = new IFSG_TRANSFORM( tx0-\u003eGetRawPtr() ); tx2-\u003eAddRefNode( *tx1 ); tx2-\u003eSetTranslation( SGPOINT( 0, 0, 2 ) ); tx2-\u003eSetRotation( SGVECTOR( 0, 0, 1 ), M_PI*2.0/3.0 ); SGNODE* data = tx0-\u003eGetRawPtr(); // delete the wrappers delete shape; delete face; delete coordIdx; delete material; delete cp; delete np; delete tx0; delete tx1; delete tx2; return (SCENEGRAPH*)data; } Application Programming Interface (API) Plugins are implemented via Application Programming Interface (API) implementations. Each Plugin Class has its specific API and in the 3D Plugin tutorials we have seen examples of the implementation of the 3D Plugin API as declared by the header 3d_plugin.h. Plugins may also rely on other APIs defined within the KiCad source tree; in the case of 3D plugins, all plugins which support visualization of models must interact with the Scene Graph API as declared in the header ifsg_all.h and its included headers.\nThis section describes the details of available Plugin Class APIs and other KiCad APIs which may be required for implementations of plugin classes.\nPlugin Class APIs There is currently only one plugin class declared for KiCad: the 3D Plugin Class. All KiCad plugin classes must implement a basic set of functions declared in the header file kicad_plugin.h; these declarations are referred to as the Base Kicad Plugin Class. No implementation of the Base Kicad Plugin Class exists; the header file exists purely to ensure that plugin developers implement these defined functions in each plugin implementation.\nWithin KiCad, each instance of a Plugin Loader implements the API presented by a plugin as though the Plugin Loader is a class providing the plugin’s services. This is achieved by the Plugin Loader class providing a public interface containing function names which are similar to those implemented by the plugin; the argument lists may vary to accommodate the need to inform the user of any problems which may be encountered if, for example, no plugin is loaded. Internally the Plugin Loader uses a stored pointer to each API function to invoke each function on behalf of the user.\nAPI: Base Kicad Plugin Class The Base Kicad Plugin Class is defined by the header file kicad_plugin.h. This header must be included in the declaration of all other plugin classes; for an example see the 3D Plugin Class declaration in the header file 3d_plugin.h. The prototypes for these functions were briefly described in Plugin Classes. The API is implemented by the base plugin loader as defined in pluginldr.cpp.\nTo help make sense of the functions required by the base KiCad plugin header we must look at what happens in the base Plugin Loader class. The Plugin Loader class declares a virtual function Open() which takes the full path to the plugin to be loaded. The implementation of the Open() function within a specific plugin class loader will initially invoke the protected open() function of the base plugin loader; this base open() function attempts to find the address of each of the required basic plugin functions; once the addresses of each function have been retrieved, a number of checks are enforced:\nPlugin GetKicadPluginClass() is invoked and the result is compared to the Plugin Class string provided by the Plugin Loader implementation; if these strings do not match then the opened plugin is not intended for the Plugin Loader instance.\nPlugin GetClassVersion() is invoked to retrieve the Plugin Class API Version implemented by the plugin.\nPlugin Loader virtual GetLoaderVersion() function is invoked to retrieve the Plugin Class API Version implemented by the loader.\nThe Plugin Class API Version reported by the plugin and the loader are required to have the same Major Version number, otherwise they are considered incompatible. This is the most basic version test and it is enforced by the base plugin loader.\nPlugin CheckClassVersion() is invoked with the Plugin Class API Version information of the Plugin Loader; if the Plugin supports the given version then it returns true to indicate success. If successful the loader creates a PluginInfo string based on the results of GetKicadPluginName() and GetPluginVersion(), and the plugin loading procedure continues within the Plugin Loader’s Open() implementation.\nAPI: 3D Plugin Class The 3D Plugin Class is declared by the header file 3d_plugin.h and it extends the required plugin functions as described in Plugin Class: PLUGIN_3D. The corresponding Plugin Loader is defined in pluginldr3D.cpp and the loader implements the following public functions in addition to the required API functions:\n/* Open the plugin specified by the full path \"aFullFileName\" */ bool Open( const wxString\u0026 aFullFileName ); /* Close the currently opened plugin */ void Close( void ); /* Retrieve the Plugin Class API Version implemented by this Plugin Loader */ void GetLoaderVersion( unsigned char* Major, unsigned char* Minor, unsigned char* Revision, unsigned char* Patch ) const; The required 3D Plugin Class functions are exposed via the following functions:\n/* returns the Plugin Class or NULL if no plugin loaded */ char const* GetKicadPluginClass( void ); /* returns false if no plugin loaded */ bool GetClassVersion( unsigned char* Major, unsigned char* Minor, unsigned char* Patch, unsigned char* Revision ); /* returns false if the class version check fails or no plugin is loaded */ bool CheckClassVersion( unsigned char Major, unsigned char Minor, unsigned char Patch, unsigned char Revision ); /* returns the Plugin Name or NULL if no plugin loaded */ const char* GetKicadPluginName( void ); /* returns false if no plugin is loaded, otherwise the arguments contain the result of GetPluginVersion() */ bool GetVersion( unsigned char* Major, unsigned char* Minor, unsigned char* Patch, unsigned char* Revision ); /* sets aPluginInfo to an empty string if no plugin is loaded, otherwise aPluginInfo is set to a string of the form: [NAME]:[MAJOR].[MINOR].[PATCH].[REVISION] where NAME = name provided by GetKicadPluginClass() MAJOR, MINOR, PATCH, REVISION = version information from GetPluginVersion() */ void GetPluginInfo( std::string\u0026 aPluginInfo ); In typical situations, the user would do the following:\nCreate an instance of KICAD_PLUGIN_LDR_3D.\nInvoke Open( \"/path/to/myplugin.so\" ) to open a specific plugin. The return value must be checked to ensure that the plugin loaded as desired.\nInvoke any of the 3D Plugin Class calls as exposed by KICAD_PLUGIN_LDR_3D.\nInvoke Close() to close (unlink) the plugin.\nDestroy the KICAD_PLUGIN_LDR_3D instance.\nScenegraph Class APIs The Scenegraph Class API is defined by the header ifsg_all.h and its included headers. The API consists of a number of helper routines with the namespace S3D as defined in ifsg_api.h and wrapper classes defined by the various ifsg_*.h headers; the wrappers support the underlying scene graph classes which, taken together, form a scene graph structure which is compatible with VRML2.0 static scene graphs. The headers, structures, classes and their public functions are as follows:\nsg_version.h /* Defines version information of the SceneGraph Classes. All plugins which use the scenegraph class should include this header and check the version information against the version reported by S3D::GetLibVersion() to ensure compatibility */ #define KICADSG_VERSION_MAJOR 2 #define KICADSG_VERSION_MINOR 0 #define KICADSG_VERSION_PATCH 0 #define KICADSG_VERSION_REVISION 0 sg_types.h /* Defines the SceneGraph Class Types; these types are closely related to VRML2.0 node types. */ namespace S3D { enum SGTYPES { SGTYPE_TRANSFORM = 0, SGTYPE_APPEARANCE, SGTYPE_COLORS, SGTYPE_COLORINDEX, SGTYPE_FACESET, SGTYPE_COORDS, SGTYPE_COORDINDEX, SGTYPE_NORMALS, SGTYPE_SHAPE, SGTYPE_END }; }; The sg_base.h header contains declarations of basic data types used by the scenegraph classes.\nsg_base.h /* This is an RGB color model equivalent to the VRML2.0 RGB model where each color may have a value within the range [0..1]. */ class SGCOLOR { public: SGCOLOR(); SGCOLOR( float aRVal, float aGVal, float aBVal ); void GetColor( float\u0026 aRedVal, float\u0026 aGreenVal, float\u0026 aBlueVal ) const; void GetColor( SGCOLOR\u0026 aColor ) const; void GetColor( SGCOLOR* aColor ) const; bool SetColor( float aRedVal, float aGreenVal, float aBlueVal ); bool SetColor( const SGCOLOR\u0026 aColor ); bool SetColor( const SGCOLOR* aColor ); }; class SGPOINT { public: double x; double y; double z; public: SGPOINT(); SGPOINT( double aXVal, double aYVal, double aZVal ); void GetPoint( double\u0026 aXVal, double\u0026 aYVal, double\u0026 aZVal ); void GetPoint( SGPOINT\u0026 aPoint ); void GetPoint( SGPOINT* aPoint ); void SetPoint( double aXVal, double aYVal, double aZVal ); void SetPoint( const SGPOINT\u0026 aPoint ); }; /* A SGVECTOR has 3 components (x,y,z) similar to a point; however a vector ensures that the stored values are normalized and prevents direct manipulation of the component variables. */ class SGVECTOR { public: SGVECTOR(); SGVECTOR( double aXVal, double aYVal, double aZVal ); void GetVector( double\u0026 aXVal, double\u0026 aYVal, double\u0026 aZVal ) const; void SetVector( double aXVal, double aYVal, double aZVal ); void SetVector( const SGVECTOR\u0026 aVector ); SGVECTOR\u0026 operator=( const SGVECTOR\u0026 source ); }; The IFSG_NODE class is the base class for all scenegraph nodes. All scenegraph objects implement the public functions of this class but in some cases a particular function may have no meaning for a specific class.\nifsg_node.h class IFSG_NODE { public: IFSG_NODE(); virtual ~IFSG_NODE(); /** * Function Destroy * deletes the scenegraph object held by this wrapper */ void Destroy( void ); /** * Function Attach * associates a given SGNODE* with this wrapper */ virtual bool Attach( SGNODE* aNode ) = 0; /** * Function NewNode * creates a new node to associate with this wrapper */ virtual bool NewNode( SGNODE* aParent ) = 0; virtual bool NewNode( IFSG_NODE\u0026 aParent ) = 0; /** * Function GetRawPtr() * returns the raw internal SGNODE pointer */ SGNODE* GetRawPtr( void ); /** * Function GetNodeType * returns the type of this node instance */ S3D::SGTYPES GetNodeType( void ) const; /** * Function GetParent * returns a pointer to the parent SGNODE of this object * or NULL if the object has no parent (ie. top level transform) * or if the wrapper is not currently associated with an SGNODE. */ SGNODE* GetParent( void ) const; /** * Function SetParent * sets the parent SGNODE of this object. * * @param aParent [in] is the desired parent node * @return true if the operation succeeds; false if * the given node is not allowed to be a parent to * the derived object. */ bool SetParent( SGNODE* aParent ); /** * Function GetNodeTypeName * returns the text representation of the node type * or NULL if the node somehow has an invalid type */ const char * GetNodeTypeName( S3D::SGTYPES aNodeType ) const; /** * Function AddRefNode * adds a reference to an existing node which is not owned by * (not a child of) this node. * * @return true on success */ bool AddRefNode( SGNODE* aNode ); bool AddRefNode( IFSG_NODE\u0026 aNode ); /** * Function AddChildNode * adds a node as a child owned by this node. * * @return true on success */ bool AddChildNode( SGNODE* aNode ); bool AddChildNode( IFSG_NODE\u0026 aNode ); }; IFSG_TRANSFORM is similar to a VRML2.0 Transform node; it may contain any number of child IFSG_SHAPE and IFSG_TRANSFORM nodes and any number of referenced IFSG_SHAPE and IFSG_TRANSFORM nodes. A valid scenegraph must have a single IFSG_TRANSFORM object as a root.\nifsg_transform.h /** * Class IFSG_TRANSFORM * is the wrapper for the VRML compatible TRANSFORM block class SCENEGRAPH */ class IFSG_TRANSFORM : public IFSG_NODE { public: IFSG_TRANSFORM( bool create ); IFSG_TRANSFORM( SGNODE* aParent ); bool SetScaleOrientation( const SGVECTOR\u0026 aScaleAxis, double aAngle ); bool SetRotation( const SGVECTOR\u0026 aRotationAxis, double aAngle ); bool SetScale( const SGPOINT\u0026 aScale ); bool SetScale( double aScale ); bool SetCenter( const SGPOINT\u0026 aCenter ); bool SetTranslation( const SGPOINT\u0026 aTranslation ); /* various base class functions not shown here */ }; IFSG_SHAPE is similar to a VRML2.0 Shape node; it must contain a single child or reference FACESET node and may contain a single child or reference APPEARANCE node.\nifsg_shape.h /** * Class IFSG_SHAPE * is the wrapper for the SGSHAPE class */ class IFSG_SHAPE : public IFSG_NODE { public: IFSG_SHAPE( bool create ); IFSG_SHAPE( SGNODE* aParent ); IFSG_SHAPE( IFSG_NODE\u0026 aParent ); /* various base class functions not shown here */ }; IFSG_APPEARANCE is similar to a VRML2.0 Appearance node, however, at the moment it only represents the equivalent of an Appearance node containing a Material node.\nifsg_appearance.h class IFSG_APPEARANCE : public IFSG_NODE { public: IFSG_APPEARANCE( bool create ); IFSG_APPEARANCE( SGNODE* aParent ); IFSG_APPEARANCE( IFSG_NODE\u0026 aParent ); bool SetEmissive( float aRVal, float aGVal, float aBVal ); bool SetEmissive( const SGCOLOR* aRGBColor ); bool SetEmissive( const SGCOLOR\u0026 aRGBColor ); bool SetDiffuse( float aRVal, float aGVal, float aBVal ); bool SetDiffuse( const SGCOLOR* aRGBColor ); bool SetDiffuse( const SGCOLOR\u0026 aRGBColor ); bool SetSpecular( float aRVal, float aGVal, float aBVal ); bool SetSpecular( const SGCOLOR* aRGBColor ); bool SetSpecular( const SGCOLOR\u0026 aRGBColor ); bool SetAmbient( float aRVal, float aGVal, float aBVal ); bool SetAmbient( const SGCOLOR* aRGBColor ); bool SetAmbient( const SGCOLOR\u0026 aRGBColor ); bool SetShininess( float aShininess ); bool SetTransparency( float aTransparency ); /* various base class functions not shown here */ /* the following functions make no sense within an appearance node and always return a failure code bool AddRefNode( SGNODE* aNode ); bool AddRefNode( IFSG_NODE\u0026 aNode ); bool AddChildNode( SGNODE* aNode ); bool AddChildNode( IFSG_NODE\u0026 aNode ); */ }; IFSG_FACESET is similar to a VRML2.0 Geometry node which contains an IndexedFaceSet node. It must contain a single child or reference COORDS node, a single child COORDINDEX node, and a single child or reference NORMALS node; in addition there may be a single child or reference COLORS node. A simplistic normals calculation function is provided to aid the user in assigning normal values to surfaces. The deviations from the VRML2.0 analogue are as follows:\nNormals are always per-vertex.\nColors are always per vertex.\nThe coordinate index set must describe triangular faces only.\nifsg_faceset.h /** * Class IFSG_FACESET * is the wrapper for the SGFACESET class */ class IFSG_FACESET : public IFSG_NODE { public: IFSG_FACESET( bool create ); IFSG_FACESET( SGNODE* aParent ); IFSG_FACESET( IFSG_NODE\u0026 aParent ); bool CalcNormals( SGNODE** aPtr ); /* various base class functions not shown here */ }; ifsg_coords.h /** * Class IFSG_COORDS * is the wrapper for SGCOORDS */ class IFSG_COORDS : public IFSG_NODE { public: IFSG_COORDS( bool create ); IFSG_COORDS( SGNODE* aParent ); IFSG_COORDS( IFSG_NODE\u0026 aParent ); bool GetCoordsList( size_t\u0026 aListSize, SGPOINT*\u0026 aCoordsList ); bool SetCoordsList( size_t aListSize, const SGPOINT* aCoordsList ); bool AddCoord( double aXValue, double aYValue, double aZValue ); bool AddCoord( const SGPOINT\u0026 aPoint ); /* various base class functions not shown here */ /* the following functions make no sense within a coords node and always return a failure code bool AddRefNode( SGNODE* aNode ); bool AddRefNode( IFSG_NODE\u0026 aNode ); bool AddChildNode( SGNODE* aNode ); bool AddChildNode( IFSG_NODE\u0026 aNode ); */ }; IFSG_COORDINDEX is similar to a VRML2.0 coordIdx[] set except it must exclusively describe triangular faces, which implies that the total number of indices is divisible by 3.\nifsg_coordindex.h /** * Class IFSG_COORDINDEX * is the wrapper for SGCOORDINDEX */ class IFSG_COORDINDEX : public IFSG_INDEX { public: IFSG_COORDINDEX( bool create ); IFSG_COORDINDEX( SGNODE* aParent ); IFSG_COORDINDEX( IFSG_NODE\u0026 aParent ); bool GetIndices( size_t\u0026 nIndices, int*\u0026 aIndexList ); bool SetIndices( size_t nIndices, int* aIndexList ); bool AddIndex( int aIndex ); /* various base class functions not shown here */ /* the following functions make no sense within a coordindex node and always return a failure code bool AddRefNode( SGNODE* aNode ); bool AddRefNode( IFSG_NODE\u0026 aNode ); bool AddChildNode( SGNODE* aNode ); bool AddChildNode( IFSG_NODE\u0026 aNode ); */ }; IFSG_NORMALS is equivalent to a VRML2.0 Normals node.\nifsg_normals.h /** * Class IFSG_NORMALS * is the wrapper for the SGNORMALS class */ class IFSG_NORMALS : public IFSG_NODE { public: IFSG_NORMALS( bool create ); IFSG_NORMALS( SGNODE* aParent ); IFSG_NORMALS( IFSG_NODE\u0026 aParent ); bool GetNormalList( size_t\u0026 aListSize, SGVECTOR*\u0026 aNormalList ); bool SetNormalList( size_t aListSize, const SGVECTOR* aNormalList ); bool AddNormal( double aXValue, double aYValue, double aZValue ); bool AddNormal( const SGVECTOR\u0026 aNormal ); /* various base class functions not shown here */ /* the following functions make no sense within a normals node and always return a failure code bool AddRefNode( SGNODE* aNode ); bool AddRefNode( IFSG_NODE\u0026 aNode ); bool AddChildNode( SGNODE* aNode ); bool AddChildNode( IFSG_NODE\u0026 aNode ); */ }; IFSG_COLORS is similar to a VRML2.0 colors[] set.\nifsg_colors.h /** * Class IFSG_COLORS * is the wrapper for SGCOLORS */ class IFSG_COLORS : public IFSG_NODE { public: IFSG_COLORS( bool create ); IFSG_COLORS( SGNODE* aParent ); IFSG_COLORS( IFSG_NODE\u0026 aParent ); bool GetColorList( size_t\u0026 aListSize, SGCOLOR*\u0026 aColorList ); bool SetColorList( size_t aListSize, const SGCOLOR* aColorList ); bool AddColor( double aRedValue, double aGreenValue, double aBlueValue ); bool AddColor( const SGCOLOR\u0026 aColor ); /* various base class functions not shown here */ /* the following functions make no sense within a normals node and always return a failure code bool AddRefNode( SGNODE* aNode ); bool AddRefNode( IFSG_NODE\u0026 aNode ); bool AddChildNode( SGNODE* aNode ); bool AddChildNode( IFSG_NODE\u0026 aNode ); */ }; The remaining API functions are defined in ifsg_api.h as follows:\nifsg_api.h namespace S3D { /** * Function GetLibVersion retrieves version information of the * kicad_3dsg library */ SGLIB_API void GetLibVersion( unsigned char* Major, unsigned char* Minor, unsigned char* Patch, unsigned char* Revision ); // functions to extract information from SGNODE pointers SGLIB_API S3D::SGTYPES GetSGNodeType( SGNODE* aNode ); SGLIB_API SGNODE* GetSGNodeParent( SGNODE* aNode ); SGLIB_API bool AddSGNodeRef( SGNODE* aParent, SGNODE* aChild ); SGLIB_API bool AddSGNodeChild( SGNODE* aParent, SGNODE* aChild ); SGLIB_API void AssociateSGNodeWrapper( SGNODE* aObject, SGNODE** aRefPtr ); /** * Function CalcTriNorm * returns the normal vector of a triangle described by vertices p1, p2, p3 */ SGLIB_API SGVECTOR CalcTriNorm( const SGPOINT\u0026 p1, const SGPOINT\u0026 p2, const SGPOINT\u0026 p3 ); /** * Function WriteCache * writes the SGNODE tree to a binary cache file * * @param aFileName is the name of the file to write * @param overwrite must be set to true to overwrite an existing file * @param aNode is any node within the node tree which is to be written * @return true on success */ SGLIB_API bool WriteCache( const char* aFileName, bool overwrite, SGNODE* aNode, const char* aPluginInfo ); /** * Function ReadCache * reads a binary cache file and creates an SGNODE tree * * @param aFileName is the name of the binary cache file to be read * @return NULL on failure, on success a pointer to the top level SCENEGRAPH node; * if desired this node can be associated with an IFSG_TRANSFORM wrapper via * the IFSG_TRANSFORM::Attach() function. */ SGLIB_API SGNODE* ReadCache( const char* aFileName, void* aPluginMgr, bool (*aTagCheck)( const char*, void* ) ); /** * Function WriteVRML * writes out the given node and its subnodes to a VRML2 file * * @param filename is the name of the output file * @param overwrite should be set to true to overwrite an existing VRML file * @param aTopNode is a pointer to a SCENEGRAPH object representing the VRML scene * @param reuse should be set to true to make use of VRML DEF/USE features * @return true on success */ SGLIB_API bool WriteVRML( const char* filename, bool overwrite, SGNODE* aTopNode, bool reuse, bool renameNodes ); // NOTE: The following functions are used in combination to create a VRML // assembly which may use various instances of each SG* representation of a module. // A typical use case would be: // 1. invoke 'ResetNodeIndex()' to reset the global node name indices // 2. for each model pointer provided by 'S3DCACHE-\u003eLoad()', invoke 'RenameNodes()' once; // this ensures that all nodes have a unique name to present to the final output file. // Internally, RenameNodes() will only rename the given node and all Child subnodes; // nodes which are only referenced will not be renamed. Using the pointer supplied // by 'S3DCACHE-\u003eLoad()' ensures that all nodes but the returned node (top node) are // children of at least one node, so all nodes are given unique names. // 3. if SG* trees are created independently of S3DCACHE-\u003eLoad() the user must invoke // RenameNodes() as appropriate to ensure that all nodes have a unique name // 4. create an assembly structure by creating new IFSG_TRANSFORM nodes as appropriate // for each instance of a component; the component base model as returned by // S3DCACHE-\u003eLoad() may be added to these IFSG_TRANSFORM nodes via 'AddRefNode()'; // set the offset, rotation, etc of the IFSG_TRANSFORM node to ensure correct // 5. Ensure that all new IFSG_TRANSFORM nodes are placed as child nodes within a // top level IFSG_TRANSFORM node in preparation for final node naming and output // 6. Invoke RenameNodes() on the top level assembly node // 7. Invoke WriteVRML() as normal, with renameNodes = false, to write the entire assembly // structure to a single VRML file // 8. Clean up by deleting any extra IFSG_TRANSFORM wrappers and their underlying SG* // classes which have been created solely for the assembly output /** * Function ResetNodeIndex * resets the global SG* class indices * * @param aNode may be any valid SGNODE */ SGLIB_API void ResetNodeIndex( SGNODE* aNode ); /** * Function RenameNodes * renames a node and all children nodes based on the current * values of the global SG* class indices * * @param aNode is a top level node */ SGLIB_API void RenameNodes( SGNODE* aNode ); /** * Function DestroyNode * deletes the given SG* class node. This function makes it possible * to safely delete an SG* node without associating the node with * its corresponding IFSG* wrapper. */ SGLIB_API void DestroyNode( SGNODE* aNode ); // NOTE: The following functions facilitate the creation and destruction // of data structures for rendering /** * Function GetModel * creates an S3DMODEL representation of aNode (raw data, no transforms) * * @param aNode is the node to be transcribed into an S3DMODEL representation * @return an S3DMODEL representation of aNode on success, otherwise NULL */ SGLIB_API S3DMODEL* GetModel( SCENEGRAPH* aNode ); /** * Function Destroy3DModel * frees memory used by an S3DMODEL structure and sets the pointer to * the structure to NULL */ SGLIB_API void Destroy3DModel( S3DMODEL** aModel ); /** * Function Free3DModel * frees memory used internally by an S3DMODEL structure */ SGLIB_API void Free3DModel( S3DMODEL\u0026 aModel ); /** * Function Free3DMesh * frees memory used internally by an SMESH structure */ SGLIB_API void Free3DMesh( SMESH\u0026 aMesh ); /** * Function New3DModel * creates and initializes an S3DMODEL struct */ SGLIB_API S3DMODEL* New3DModel( void ); /** * Function Init3DMaterial * initializes an SMATERIAL struct */ SGLIB_API void Init3DMaterial( SMATERIAL\u0026 aMat ); /** * Function Init3DMesh * creates and initializes an SMESH struct */ SGLIB_API void Init3DMesh( SMESH\u0026 aMesh ); }; For actual usage examples of the Scenegraph API see the Advanced 3D Plugin tutorial above and the KiCad VRML1, VRML2, and X3D parsers.\nContributors Cirilo Bernardo",
    "description": "The KiCad plugin system is a framework for extending the capabilities of KiCad using shared libraries. One of the main advantages of using a plugin is that it is not necessary to rebuild the KiCad suite while developing a plugin; in fact, plugins can be built with the aid of a very small set of headers from the KiCad source tree. Removing the requirement to build KiCad during plugin development greatly increases productivity by ensuring that the developer only compiles code directly related to the plugin which is being developed and thus reducing the time required for each build and test cycle.",
    "tags": [],
    "title": "Plugins Framework",
    "uri": "/en/components/plugins/index.html"
  },
  {
    "breadcrumb": "Components",
    "content": " Unit tests KiCad has a limited number of unit tests, which can be used to check that certain functionality works.\nTests are registered using CTest, part of CMake. CTest gathers all the disparate test programs and runs them. Most C++ unit tests are written using the Boost Unit Test framework, but this is not required to add a test to the testing suite.\nThe test CMake targets generally start with qa_, the names of the tests within CTest are the same but without the qa_ prefix.\nRunning tests You can run all tests after building with make test or ctest. The latter option allows many CTest options which can be useful, especially in automated or CI environments.\nRunning specific tests To run a specific test executable, you can just run with ctest or run the executable directly. Running directly is often the simplest way when working on a specific test and you want access to the test executable’s arguments. For example:\n# run the libcommon tests cd /path/to/kicad/build qa/tests/common/qa_common [parameters] For Boost unit tests, you can see the options for the test with \u003ctest\u003e --help. Common useful patterns:\n\u003ctest\u003e -t \"Utf8/*\" runs all tests in the Utf8 test suite.\n\u003ctest\u003e -t \"Utf8/UniIterNull\" runs only a single test in a specific suite.\n\u003ctest\u003e -l all adds more verbose debugging to the output.\n\u003ctest\u003e --list_content lists the test suites and test cases within the test program. You can use these for arguments to -t.\nYou can rebuild just a specific test with CMake to avoid rebuilding everything when working on a small area, e.g. make qa_common.\nAutomated testing The unit tests can be run on automated Continuous Integration (CI) systems.\nBy default, tests output human-readable results, which is useful when developing or debugging, but not so useful for automated test reporting. Systems that can parse XML test results can enable these by setting the KICAD_TEST_XML_OUTPUT option to ON. The test results are then output as files ending in .xml in the qa subdirectory.\nTest results are written to the build directory as follows:\nBoost units tests: one XML file per test with the extension .boost-results.xml\nPython unit tests: one directory per test with the extension .xunit-results.xml. These directories contain one .xml file per Python test case file.\nWriting Boost tests Boost unit tests are straightforward to write. Individual test cases can be registered with:\nBOOST_AUTO_TEST_CASE( SomeTest ) { BOOST_CHECK_EQUAL( 1, 1 ); } There is a range of functions like BOOST_CHECK, which are documented here. Using the most specific function is preferred, as that allows Boost to provide more detailed failures: BOOST_CHECK( foo == bar ) only reports a mismatch, BOOST_CHECK_EQUAL( foo, bar ) will show the values of each.\nTo output debug messages, you can use BOOST_TEST_MESSAGE in the unit tests, which will be visible only if you set the -l parameter to message or higher. This colours the text differently to make it stand out from other testing messages and standard output.\nYou can also use std::cout, printf, wxLogDebug and so on for debug messages inside tested functions (i.e. where you don’t have access to the Boost unit test headers). These will always be printed, so take care to remove them before committing, or they’ll show up when KiCad runs normally!\nExpected failures Sometimes, it is helpful to check in tests that do not pass. However, it is bad practise to intentionally check in commits that break builds (which is what happens if you cause make test to fail).\nBoost provides a method of declaring that some specific tests are allowed to fail. This syntax is not consistently available in all supported Boost versions, so you should use the following construct:\n#include \u003cunit_test_utils/unit_test_utils.h\u003e // On platforms with older boosts, the test will be excluded entirely #ifdef HAVE_EXPECTED_FAILURES // Declare a test case with 1 \"allowed\" failure (out of 2, in this case) BOOST_AUTO_TEST_CASE( SomeTest, *boost::unit_test::expected_failures( 1 ) ) { BOOST_CHECK_EQUAL( 1, 1 ); // This check fails, but does not cause a test suite failure BOOST_CHECK_EQUAL( 1, 2 ); // Further failures *would* be a test suit failure } #endif When run, this produces output somewhat like this:\nqa/common/test_mytest.cpp(123): error: in \"MyTests/SomeTest\": check 1 == 2 has failed [1 != 2 *** No errors detected And the unit test executable returns 0 (success).\nChecking in a failing test is a strictly temporary situation, used to illustrate the triggering of a bug prior to fixing it. This is advantageous, not only from a \"project history\" perspective, but also to ensure that the test you write to catch the bug in question does, in fact, catch the bug in the first place.\nAssertions It is possible to check for assertions in unit tests. When running the unit tests, wxASSERT calls are caught and re-thrown as exceptions. You can then use the CHECK_WX_ASSERT macro to check this is called in Debug builds. In Release builds, the check is not run, as wxASSERT is disabled in these builds.\nYou can use this to ensure that code rejects invalid input correctly.\nPython modules The Pcbnew Python modules have some test programs in the qa directory. You must have the KICAD_SCRIPTING_MODULES option on in CMake to build the modules and enable this target.\nThe main test script is qa/test.py and the test units are in qa/testcases. All the test units can by run using ctest python, which runs test.py.\nYou can also run an individual case manually, by making sure the modules are built, adding them to PYTHONPATH and running the test from the source tree:\nmake pcbnew_python_module export PYTHONPATH=/path/to/kicad/build/pcbnew cd /path/to/kicad/source/qa python2 testcase/test_001_pcb_load.py Diagnosing segfaults Although the module is Python, it links against a C++ library (the same one used by KiCad Pcbnew), so it can segfault if the library has a defect.\nYou can run the tests in GDB to trace this:\n$ gdb (gdb) file python2 (gdb) run testcases/test_001_pcb_load.py If the test segfaults, you will get a familiar backtrace, just like if you were running pcbnew under GDB.\nUtility programs KiCad includes some utility programs that can be used for debugging, profiling, analysing or developing certain parts of the code without having to invoke the full GUI program.\nGenerally, they are part of the qa_*_tools QA executables, each one containing the relevant tools for that library. To list the tools in a given program, pass the -l parameter. Most tools provide help with the -h argument. To invoke a program:\nqa_\u003clib\u003e_tools \u003ctool name\u003e [-h] [tool arguments] Below is a brief outline of some available tools. For full information and command-line parameters, refer to the tools' usage test (-h).\ncommon_tools (the common library and core functions):\ncoroutine: A simple coroutine example\nio_benchmark: Show relative speeds of reading files using various IO techniques.\nqa_pcbnew_tools (pcbnew-related functions):\ndrc: Run and benchmark certain DRC functions on a user-provided .kicad_pcb files\npcb_parser: Parse user-provided .kicad_pcb files\npolygon_generator: Dump polygons found on a PCB to the console\npolygon_triangulation: Perform triangulation of zone polygons on PCBs\nFuzz testing It is possible to run fuzz testing on some parts of KiCad. To do this for a generic function, you need to be able to pass some kind of input from the fuzz testing tool to the function under test.\nFor example, to use the AFL fuzzing tool, you will need:\nA test executable that can:\nReceive input from stdin to be run by afl-fuzz.\nOptional: process input from a filename to allow afl-tmin to minimise the input files.\nTo compile this executable with an AFL compiler, to enable the instrumentation that allows the fuzzer to detect the fuzzing state.\nFor example, the qa_pcbnew_tools executable (which contains pcb_parser, a fuzz testing tool for .kicad_pcb file parsing) can be compiled like this:\nmkdir build cd build cmake -DCMAKE_CXX_COMPILER=/usr/bin/afl-clang-fast++ -DCMAKE_C_COMPILER=/usr/bin/afl-clang-fast ../kicad_src make qa_pcbnew_tools You may need to disable core dumps and CPU frequency scaling on your system (AFL will warn you if you should do this). For example, as root:\n# echo core \u003e/proc/sys/kernel/core_pattern # echo performance | tee cpu*/cpufreq/scaling_governor To fuzz, run the executable via afl-fuzz:\nafl-fuzz -i fuzzin -o fuzzout -m500 qa/pcbnew_tools/qa_pcbnew_tools pcb_parser where:\n-i is a directory of files to use as fuzz input \"seeds\"\n-o is a directory to write the results (including inputs that provoke crashes or hangs)\n-t is the maximum time that a run is allowed to take before being declared a \"hang\"\n-m is the memory allowed to use (this often needs to be bumped, as KiCad code tends to use a lot of memory to initialise)\nThe AFL TUI will then display the fuzzing progress, and you can use the hang- or crash-provoking inputs to debug code as needed.\nRun-time debugging KiCad can be debugged at run-time, either under a full debugger such as GDB, or using simple methods like logging debug to the console.\nPrinting debug If you are compiling KiCad yourself, you can simply add debugging statements to relevant places in the code, for example:\nwxLogDebug( \"Value of variable: %d\", my_int ); This produces debug output that can only be seen when compiling in Debug mode.\nYou can also use std::cout and printf.\nEnsure you do not leave this kind of debugging in place when submitting code.\nPrinting trace Some parts of the code have \"trace\" that can be enabled selectively according to a \"mask\", for example:\nwxLogTrace( \"TRACEMASK\", \"My trace, value: %d\", my_int ); This will not be printed by default. To show it, set the WXTRACE environment variable when you run KiCad to include the masks you wish to enable:\n$ WXTRACE=\"TRACEMASK,OTHERMASK\" kicad When printed, the debug will be prefixed with a timestamp and the trace mask:\n11:22:33: Trace: (TRACEMASK) My trace, value: 42 If you add a trace mask, define and document the mask as a variable in include/trace_helpers.h. This will add it to the trace mask documentation.\nSome available masks:\nCore KiCad functions:\nKICAD_KEY_EVENTS\nKicadScrollSettings\nKICAD_FIND_ITEM\nKICAD_FIND_REPLACE\nKICAD_NGSPICE\nKICAD_PLUGINLOADER\nGAL_PROFILE\nGAL_CACHED_CONTAINER\nPNS\nCN\nSCROLL_ZOOM - for the scroll-wheel zooming logic in GAL\nPlugin-specific (including \"standard\" KiCad formats):\n3D_CACHE\n3D_SG\n3D_RESOLVER\n3D_PLUGIN_MANAGER\nKI_TRACE_CCAMERA\nPLUGIN_IDF\nPLUGIN_VRML\nKICAD_SCH_LEGACY_PLUGIN\nKICAD_GEDA_PLUGIN\nKICAD_PCB_PLUGIN\nAdvanced configuration There are some advance configuration options, which are mostly used for development or testing purposes.\nTo set these options, you can create the file kicad_advanced and set the keys as desired (the advanced config documentation for a current list. You should never need to set these keys for normal usage - if you do, that’s a bug.\nAny features enabled though the advanced configuration system are considered experimental and therefore unsuitable for production use. These features are explicitly not supported or considered fully tested. Issues are still welcome for defects discovered.\nRouter debugging The push and shove (PNS) router has some debugging tools.\nPNG debug graphics Setting the ShowRouterDebugGraphics advanced config enables graphics which show some internal state of the router:\nPNS logging There is a logging function that allows the router to store and save a log of events that can be used to replay the events that lead to a problem.\nTo create a PNS log dump:\nSet the advanced config option EnableRouterDump=1 and restart KiCad\nDuring routing, after recreating the issue, press 0.\nSave the pns.log file where you want\nTo view a PNS log, you need to build an extra tool:\nSet the KICAD_BUILD_PNS_DEBUG_TOOL CMake setting to ON\nBuild the pns_debug_tool tool\nRun this tool with ./qa/tools/pns/pns_debug_tool replay path/to/pns.log",
    "description": "Unit tests KiCad has a limited number of unit tests, which can be used to check that certain functionality works.\nTests are registered using CTest, part of CMake. CTest gathers all the disparate test programs and runs them. Most C++ unit tests are written using the Boost Unit Test framework, but this is not required to add a test to the testing suite.\nThe test CMake targets generally start with qa_, the names of the tests within CTest are the same but without the qa_ prefix.",
    "tags": [],
    "title": "Testing",
    "uri": "/en/components/testing/index.html"
  },
  {
    "breadcrumb": "Components",
    "content": " An s-expression is a text stream or string, in the same vein as XML, consisting of a sequence of elements. Each element is either an atom or list. An atom corresponds to a string, while a list corresponds to an s-expression.\nThe following grammar represents our definition of an s-expression:\nsexpr ::= ( sx ) sx ::= atom sxtail | sexpr sxtail | NULL sxtail ::= sx | NULL atom :: quoted | value quoted :: \"ws_string\" value :: nws_string An atom can either be a quoted string, which is a string containing whitespace surrounded by double quotes, or a non-whitespace string that does not require surrounding quotes.\nThe s-expression syntax used in Kicad uses two quoting/syntax strategies, given by the needs of the Specctra DSN specification and of our own non-specctra needs. The Specctra DSN specification is not very clear with regard to quoting and on top of that there is Freerouter’s interpretation, which would actually supercede anything in the Specctra DSN spec anyway, due to a desire to be compatible with Freerouter.\nWe have our own needs, which go beyond those of the Specctra DSN spec, so we support the two syntaxes or quoting protocols for quoted atoms:\nSpecctra quoting protocol (specctraMode)\nKicad quoting protocol (non-specctraMode)\nWe can control our own destiny better by having a separately defined mode for non Specctra DSN files.\nTo summarize, in specctraMode Freerouter dictates to us what we need to do. In non-specctraMode, which can be thought of as Kicad mode, we have our own quoting protocol and can make changes without breaking the specctraMode.\nThere needs to be agreement between how a file is saved, and how a file is read back in, in either mode, to fulfill the round-tripping requirements. A file written using one mode may not necessarily be readable using the other mode, although it might be. Just don’t count on it.\nIn Kicad mode:\nOUTPUTFORMATTER::Quoted() is the tool to wrap s-expression atoms. DSNLEXER::NexTok() is basically the inverse function, and reads tokens back in. These two must agree, so that what is written out comes back in un-altered.\nThe decision to wrap the string or not is left to the Quoted() function. If the string is wrapped, it will also escape internal double quotes, \\n’s and \\r’s. Any null string is wrapped in quotes, and so is any string which starts with '#', so that it is not confused with an s-expression comment.\nKicad S-expression Syntax and Quoting Protocol (non-specctraMode): Some atoms are considered keywords, and constitute a grammar superimposed on the s-expressions. All keywords are ASCII and lowercase. International characters are not to be used here.\nAll Kicad s-expression files are saved using a UTF8 encoding and should support any international characters in the atoms which are not keywords.\nDSNLEXER::NextTok() requires that any token be on a single line of input. If you want to save a multi-line string, Quoted() will automatically escape the \\n or \\r for you and put the output on a single line. It should round-trip fine.\nThere can be escape sequences in a quoted string only. Escape sequences allow foreign tools to generate byte patterns in the input stream. C style 2 byte hex codes are supported, and so are 3 byte octal escape sequences. See DSNLEXER::NextTok() for the full list of escape sequences, by searching file dsnlexer.cpp for the string \"ESCAPE SEQUENCES\". Any use of the escape mechanism must still produce UTF-8 encoded text after the escape handling is applied.\nJust because an escape sequence is supported on input, does not mean that OUTPUTFORMATTER::Quoted() must generate such an escape sequence for output. For example, having true tabs in the s-expression file is OK. So that will not be escaped on output. Other similar cases exist.\nBackslash is the escape byte.",
    "description": "An s-expression is a text stream or string, in the same vein as XML, consisting of a sequence of elements. Each element is either an atom or list. An atom corresponds to a string, while a list corresponds to an s-expression.\nThe following grammar represents our definition of an s-expression:\nsexpr ::= ( sx ) sx ::= atom sxtail | sexpr sxtail | NULL sxtail ::= sx | NULL atom :: quoted | value quoted :: \"ws_string\" value :: nws_string An atom can either be a quoted string, which is a string containing whitespace surrounded by double quotes, or a non-whitespace string that does not require surrounding quotes.",
    "tags": [],
    "title": "S-Expressions",
    "uri": "/en/components/sexpr/index.html"
  },
  {
    "breadcrumb": "",
    "content": " Formats S-Expression Format Footprint Library File Format Board File Format Symbol Library File Format Schematic File Format Work Sheet File Format Legacy Formats (4.0 up to 6.0) Legacy Board Format (pre 4.0) ",
    "description": " Formats S-Expression Format Footprint Library File Format Board File Format Symbol Library File Format Schematic File Format Work Sheet File Format Legacy Formats (4.0 up to 6.0) Legacy Board Format (pre 4.0) ",
    "tags": [],
    "title": "File Formats",
    "uri": "/en/file-formats/index.html"
  },
  {
    "breadcrumb": "File Formats",
    "content": " Introduction KiCad uses an s-expression file format for symbol libraries, footprint libraries, schematics, printed circuit boards, and title block and border worksheets.\nSyntax Syntax is based on the Specctra DSN file format.\nToken definitions are delimited by opening ( and closing ) parenthesis.\nAll tokens are lowercase.\nTokens cannot contain any white space characters or special characters other than the underscore '_' character.\nAll strings are quoted using the double quote character (\") and are UTF-8 encoded.\nTokens can have zero or more attributes.\nHuman readability is a design goal.\nConventions In order to use the file format documentation properly, there are a few notation conventions that must be understood.\nToken attributes are upper case descriptive names. For example (at X Y), X is the horizontal coordinate and Y is the vertical coordinate.\nSome tokens have a limited number of possible attribute values which are separated by a logical or character '|'. For example (visible yes|no) the only valid attributes for the visible token are yes or no.\nSome tokens have optional attributes which are enclosed in square braces. For example (paper A0 [portrait]) the page portrait setting is optional.\nCoordinates and Sizes All values are given in millimeters.\nExponential floating point values are not used for readability purposes.\nAll coordinates are relative to the origin of their containing object.\nCommon Syntax This section defines all syntax that is shared across the symbol library, footprint library, schematic, board, and work sheet file formats.\nLibrary Identifier The schematic symbol library and printed circuit board footprint library file formats use library identifiers. Library identifiers are defined as a quoted string using the \"LIBRARY_NICKNAME:ENTRY_NAME\" format where \"LIBRARY_NICKNAME\" is the nickname of the library in the symbol or footprint library table and \"ENTRY_NAME\" is the name of the symbol or footprint in the library separated by a colon.\nThe \"LIBRARY_NICKNAME\" is not stored in the library files because a library cannot know what the assigned library table nickname is in advance. Only the \"ENTRY_NAME\" is saved in the library files. Position Identifier The at token defines the positional coordinates and rotation of an object.\n(at X (1) Y (2) [ANGLE] (3) ) 1 The X attribute defines the horizontal position of the object. 2 The Y attribute defines the vertical position of the object. 3 The optional ANGLE attribute defines the rotational angle of the object. Not all objects have rotational position definitions. Symbol text ANGLEs are stored in tenth’s of a degree. All other ANGLEs are stored in degrees. Coordinate Point List The pts token defines a list of X/Y coordinate points.\n(pts (xy X Y) (1) ... (xy X Y) ) 1 The xy token defines a single X and Y coordinate pair. The number of points is determined by the object type. Stroke Definition The stroke token defines how the outlines of graphical objects are drawn.\n(stroke (width WIDTH) (1) (type TYPE) (2) (color R G B A) (3) ) 1 The width token attribute defines the line width of the graphic object. 2 The type token attribute defines the line style of the graphic object. Valid stroke line styles are: dash\ndash_dot\ndash_dot_dot (from version 7)\ndot\ndefault\nsolid\n3 The color token attributes define the line red, green, blue, and alpha color settings. Text Effects All text objects can have an optional effects section that defines how the text is displayed.\n(effects (font (1) [(face FACE_NAME)] (2) (size HEIGHT WIDTH) (3) [(thickness THICKNESS)] (4) [bold] (5) [italic] (6) [(line_spacing LINE_SPACING)] (7) ) [(justify [left | right] [top | bottom] [mirror])] (8)(9) [hide] (10) ) 1 The font token attributes define how the text is shown. 2 The optional face token indicates the font family. It should be a TrueType font family name or \"KiCad Font\" for the KiCad stroke font. (from version 7) 3 The size token attributes define the font height and width. 4 The thickness token attribute defines the line thickness of the font. 5 The bold token specifies if the font should be bold. 6 The italic token specifies if the font should be italicized. 7 The line_spacing token specifies the spacing between lines as a ratio of standard line-spacing. (Not yet supported) 8 The optional justify token attributes define if the text is justified horizontally right or left and/or vertically top or bottom and/or mirrored. If the justification is not defined, then the text is center justified both horizontally and vertically and not mirrored. 9 The mirror token is only supported in the PCB Editor and Footprints. 10 The optional hide token defines if the text is hidden. Page Settings The paper token defines the drawing page size and orientation.\n(paper PAPER_SIZE | WIDTH HEIGHT (1) [portrait] (2) ) 1 Valid pages sizes are A0, A1, A2, A3, A4, A5, A, B, C, D, and E or the WIDTH and HEIGHT attributes are used for custom user defined page sizes. 2 The portrait token defines if the page is shown in the portrait mode. If not defined, the landscape page layout mode is used. Title Block The title_block token defines the contents of the title block.\n(title_block (title \"TITLE\") (1) (date \"DATE\") (2) (rev \"REVISION\") (3) (company \"COMPANY_NAME\") (4) (comment N \"COMMENT\") (5) ) 1 The title token attribute is a quoted string that defines the document title. 2 The date token attribute is a quoted string that defines the document date using the YYYY-MM-DD format. 3 The rev token attribute is a quoted string that defines the document revision. 4 The company token attribute is a quoted string that defines the document company name. 5 The comment token attributes define the document comments where N is a number from 1 to 9 and COMMENT is a quoted string. Properties The property token defines a key value pair for storing user defined information.\n(property \"KEY\" (1) \"VALUE\" (2) ) 1 The property key attribute is a string that defines the name of the property. Property keys must be unique. 2 The property value attribute is a string associated with the key attribute. Universally Unique Identifier The uuid token defines an universally unique identifier.\n(uuid UUID (1)(2) ) 1 The UUID attribute is a Version 4 (random) UUID that should be globally unique. KiCad UUIDs are generated using the mt19937 Mersenne Twister algorithm. 2 Files converted from legacy versions of KiCad (prior to 6.0) have their locally-unique timestamps re-encoded in UUID format. Images The image token defines an embedded image. This section will not exist if no images are present.\n(image POSITION_IDENTIFIER (1) [(scale SCALAR)] (2) [(layer LAYER_DEFINITIONS)] (3) UNIQUE_IDENTIFIER (4) (data IMAGE_DATA) (5) ) 1 The POSITION_IDENTIFIER defines the X and Y coordinates of the image. 2 The optional scale token attribute defines the SCALE_FACTOR of the image. 3 The layer token attribute defines the associated board layer of the image using one canonical layer name. Only used by board and footprint images. 4 The UNIQUE_IDENTIFIER defines the universally unique identifier for the image. 5 The data token attribute defines the image data in the portable network graphics format (PNG) encoded with MIME type base64. Board Common Syntax This section defines all syntax that is shared across the footprint library and printed circuit board file formats.\nBoard Coordinates The minimum internal unit for printed circuit board and footprint files is one nanometer so there is maximum resolution of six decimal places or 0.000001 mm. Any precision beyond six places will be truncated.\nLayers All drawable board and footprint objects exist on a layer which is defined in the drawable item definition. All layers can be renamed by the user.\nInternally, all layer names are canonical. User defined layer names are only used for display and output purposes. (layer LAYER_DEFINITION (1) ) 1 Layer definitions can be specified as a list of one or more canonical layer names or with a '*' wildcard to represent all layers that match the rest of the wildcard. For instance, *.Cu represents all of the copper layers. This only applies to canonical layers names. Capacity 60 total layers.\n32 copper layers.\n8 paired technical layers for silk screen, solder mask, solder paste, and adhesive.\n4 user pre-defined layers for drawings, engineering change order (ECO), and comments.\n1 layer to define the board outline.\n1 layer to define the board margins.\n9 optional user definable layers.\nCanonical Layer Names The table below list all of the canonical layer names used in the file format.\nCanonical Name Description F.Cu\nFront copper layer\nIn1.Cu\nInner copper layer 1\nIn2.Cu\nInner copper layer 2\nIn3.Cu\nInner copper layer 3\nIn4.Cu\nInner copper layer 4\nIn5.Cu\nInner copper layer 5\nIn6.Cu\nInner copper layer 6\nIn7.Cu\nInner copper layer 7\nIn8.Cu\nInner copper layer 8\nIn9.Cu\nInner copper layer 9\nIn10.Cu\nInner copper layer 10\nIn11.Cu\nInner copper layer 11\nIn12.Cu\nInner copper layer 12\nIn13.Cu\nInner copper layer 13\nIn14.Cu\nInner copper layer 14\nIn15.Cu\nInner copper layer 15\nIn16.Cu\nInner copper layer 16\nIn17.Cu\nInner copper layer 17\nIn18.Cu\nInner copper layer 18\nIn19.Cu\nInner copper layer 19\nIn20.Cu\nInner copper layer 20\nIn21.Cu\nInner copper layer 21\nIn22.Cu\nInner copper layer 22\nIn23.Cu\nInner copper layer 23\nIn24.Cu\nInner copper layer 24\nIn25.Cu\nInner copper layer 25\nIn26.Cu\nInner copper layer 26\nIn27.Cu\nInner copper layer 27\nIn28.Cu\nInner copper layer 28\nIn29.Cu\nInner copper layer 29\nIn30.Cu\nInner copper layer 30\nB.Cu\nBack copper layer\nB.Adhes\nBack adhesive layer\nF.Adhes\nFront adhesive layer\nB.Paste\nBack solder paste layer\nF.Paste\nFront solder paste layer\nB.SilkS\nBack silk screen layer\nF.SilkS\nFront silk screen layer\nB.Mask\nBack solder mask layer\nF.Mask\nFront solder mask layer\nDwgs.User\nUser drawing layer\nCmts.User\nUser comment layer\nEco1.User\nUser engineering change order layer 1\nEco2.User\nUser engineering change order layer 2\nEdge.Cuts\nBoard outline layer\nF.CrtYd\nFootprint front courtyard layer\nB.CrtYd\nFootprint back courtyard layer\nF.Fab\nFootprint front fabrication layer\nB.Fab\nFootprint back fabrication layer\nUser.1\nUser definable layer 1\nUser.2\nUser definable layer 2\nUser.3\nUser definable layer 3\nUser.4\nUser definable layer 4\nUser.5\nUser definable layer 5\nUser.6\nUser definable layer 6\nUser.7\nUser definable layer 7\nUser.8\nUser definable layer 8\nUser.9\nUser definable layer 9\nFootprint The footprint token defines a footprint.\nPrior to version 6, the footprint token was referred to as module. (footprint [\"LIBRARY_LINK\"] (1) [locked] (2) [placed] (3) (layer LAYER_DEFINITIONS) (4) (tedit TIME_STAMP) (5) [(uuid UUID)] (6) [POSITION_IDENTIFIER] (7) [(descr \"DESCRIPTION\")] (8) [(tags \"NAME\")] (9) [(property \"KEY\" \"VALUE\") ...] (10) (path \"PATH\") (11) [(autoplace_cost90 COST)] (12) [(autoplace_cost180 COST)] (13) [(solder_mask_margin MARGIN)] (14) [(solder_paste_margin MARGIN)] (15) [(solder_paste_ratio RATIO)] (16) [(clearance CLEARANCE)] (17) [(zone_connect CONNECTION_TYPE)] (18) [(thermal_width WIDTH)] (19) [(thermal_gap DISTANCE)] (20) [ATTRIBUTES] (21) [(private_layers LAYER_DEFINITIONS)] (22) [(net_tie_pad_groups PAD_GROUP_DEFINITIONS)] (23) GRAPHIC_ITEMS... (24) PADS... (25) ZONES... (26) GROUPS... (27) 3D_MODEL (28) ) 1 The \"LIBRARY_LINK\" attribute defines the link to footprint library of the footprint. This only applies to footprints defined in the board file format. 2 The optional locked token defines a flag to indicate the footprint cannot be edited. 3 The optional placed token defines a flag to indicate that the footprint has not been placed. 4 The layer token defines the canonical layer the footprint is placed. 5 The tedit token defines a the last time the footprint was edited. 6 The uuid token defines the unique identifier for the footprint. This only applies to footprints defined in the board file format. 7 The POSITION_IDENTIFIER defines the X and Y coordinates and rotational angle of the footprint. This only applies to footprints defined in the board file format. 8 The optional tags token defines a string of search tags for the footprint. 9 The optional descr token defines a string containing the description of the footprint. 10 The optional property token defines a property for the footprint. 11 The path token defines the hierarchical path of the schematic symbol linked to the footprint. This only applies to footprints defined in the board file format. 12 The optional autoplace_cost90 token defines the vertical cost of when using the automatic footprint placement tool. Valid values are integers 1 through 10. This only applies to footprints defined in the board file format. 13 The optional autoplace_cost180 token defines the horizontal cost of when using the automatic footprint placement tool. Valid values are integers 1 through 10. This only applies to footprints defined in the board file format. 14 The optional solder_mask_margin token defines the solder mask distance from all pads in the footprint. If not set, the board solder_mask_margin setting is used. 15 The optional solder_paste_margin token defines the solder paste distance from all pads in the footprint. If not set, the board solder_paste_margin setting is used. 16 The optional solder_paste_ratio token defines the percentage of the pad size used to define the solder paste for all pads in the footprint. If not set, the board solder_paste_ratio setting is used. 17 The optional clearance token defines the clearance to all board copper objects for all pads in the footprint. If not set, the board clearance setting is used. 18 The optional zone_connect token defines how all pads are connected to filled zone. If not defined, then the zone connect_pads setting is used. Valid connection types are integers values from 0 to 3 which defines: 0 - Pads are not connect to zone.\n1 - Pads are connected to zone using thermal reliefs.\n2 - Pads are connected to zone using solid fill.\n19 The optional thermal_width token defined the thermal relief spoke width used for zone connections for all pads in the footprint. This only affects pads connected to zones with thermal reliefs. If not set, the zone thermal_width setting is used. 20 The optional thermal_gap is the distance from the pad to the zone of thermal relief connections for all pads in the footprint. If not set, the zone thermal_gap setting is used. If not set, the zone thermal_gap setting is used. 21 The optional attributes section defines the attributes of the footprint. 22 An optional list of canonical layer names which are private to the footprint. 23 An optional list of net-tie pad groups. 24 The graphic objects section is a list of one or more graphical objects in the footprint. At a minimum, the reference designator and value text objects are defined. All other graphical objects are optional. 25 The optional pads section is a list of pads in the footprint. 26 The optional zones section is a list of keep out zones in the footprint. 27 The optional groups section is a list of grouped objects in the footprint. 28 The 3D model section defines the 3D model object associated with the footprint. Footprint Attributes Footprint attr token defines the list of attributes of the footprint.\n(attr TYPE (1) [board_only] (2) [exclude_from_pos_files] (3) [exclude_from_bom] (4) ) 1 The TYPE token defines the type of footprint. Valid footprint types are smd and through_hole. 2 The optional board_only token indicates that the footprint is only defined in the board and has no reference to any schematic symbol. 3 The optional exclude_from_pos_files token indicates that the footprint position information should not be included when creating position files. 4 The optional exclude_from_bom token indicates that the footprint should be excluded when creating bill of materials (BOM) files. Net-tie Pad Groups A space-separated list of quoted strings, each containing a comma-separated list of pad names. Nets attached to pads within a single pad-group are allowed to short.\nFootprint Graphics Items Footprint graphical items define all of the drawing items that are used in the footprint definition. This includes text, text boxes, lines, rectangles, circles, arcs, polygons, curves, and dimensions.\nFootprint graphic items starting with fp_ are not valid outside of a footprint definition. Footprint Images See the images section. This section will not exist if there are no images on the footprint. Footprint images are not displayed on the PCB when a footprint is placed, only in the footprint editor.\nFootprint Text The fp_text token defines text in a footprint definition.\n(fp_text TYPE (1) \"TEXT\" (2) POSITION_IDENTIFIER (3) [unlocked] (4) (layer LAYER_DEFINITION) (5) [hide] (6) (effects TEXT_EFFECTS) (7) (uuid UUID) (8) ) 1 The TYPE attribute defines the type of text. Valid types are reference, value, and user. 2 The \"TEXT\" attribute is a quoted string that defines the text. 3 The POSITION_IDENTIFIER defines the X and Y position coordinates and optional orientation angle of the text. 4 The optional unlocked token indicates if the text orientation can be anything other than the upright orientation. 5 The layer token defines the canonical layer the text resides on. 6 The optional [hide] token, defines if the text is hidden. 7 The effects token defines how the text is displayed. 8 The uuid token defines the unique identifier of the text object. Footprint Text Box (from version 7)\nThe fp_text_box token defines a rectangle containing line-wrapped text.\n(fp_text_box [locked] (1) \"TEXT\" (2) [(start X Y)] (3) [(end X Y)] (4) [(pts (xy X Y) (xy X Y) (xy X Y) (xy X Y))] (5) [(angle ROTATION)] (6) (layer LAYER_DEFINITION) (7) (uuid UUID) (8) TEXT_EFFECTS (9) [STROKE_DEFINITION] (10) [(render_cache RENDER_CACHE)] (11) ) 1 The optional locked token specifies if the text box can be moved. 2 The content of the text box 3 The start token defines the top-left of a cardinally oriented text box. 4 The end token defines the bottom-right of a cardinally oriented text box. 5 The pts token defines the four corners of a non-cardianlly oriented text box. The corners must be in order, but the winding can be either direction. 6 The optional angle token defines the rotation of the text box in degrees. 7 The layer token defines the canonical layer the text box resides on. 8 The uuid token defines the unique identifier of the text box. 9 The TEXT_EFFECTS describe the style of the text in the text box. 10 The STROKE_DEFINITION describes the style of an optional border to be drawn around the text box. 11 If the TEXT_EFFECTS prescribe a TrueType font then a render cache should be given in case the font can not be found on the current system. If angle is not given, or is a cardinal angle (0, 90, 180 or 270), then the text box MUST have start and end tokens. If angle is given and is not a cardinal angle, then the text box MUST have a pts token (with 4 pts). Footprint Line The fp_line token defines a graphic line in a footprint definition.\n(fp_line (start X Y) (1) (end X Y) (2) (layer LAYER_DEFINITION) (3) (width WIDTH) (4) STROKE_DEFINITION (5) [(locked)] (6) (uuid UUID) (7) ) 1 The start token defines the coordinates of the beginning of the line. 2 The end token defines the coordinates of the end of the line. 3 The layer token defines the canonical layer the line resides on. 4 The width token defines the line width. (prior to version 7) 5 The STROKE_DEFINITION describes the width and style of the line. (from version 7) 6 The optional locked token defines if the line cannot be edited. 7 The uuid token defines the unique identifier of the line object. Footprint Rectangle The fp_rect token defines a graphic rectangle in a footprint definition.\n(fp_rect (start X Y) (1) (end X Y) (2) (layer LAYER_DEFINITION) (3) (width WIDTH) (4) STROKE_DEFINITION (5) [(fill yes | no)] (6) [(locked)] (7) (uuid UUID) (8) ) 1 The start token defines the coordinates of the upper left corner of the rectangle. 2 The end token defines the coordinates of the low right corner of the rectangle. 3 The layer token defines the canonical layer the rectangle resides on. 4 The width token defines the line width of the rectangle. (prior to version 7) 5 The STROKE_DEFINITION describes the line width and style of the rectangle. (from version 7) 6 The optional fill token defines if the rectangle is filled. If not defined, the rectangle is not filled. 7 The optional locked token defines if the rectangle cannot be edited. 8 The uuid token defines the unique identifier of the rectangle object. Footprint Circle The fp_circle token defines a graphic circle in a footprint definition.\n(fp_circle (center X Y) (1) (end X Y) (2) (layer LAYER_DEFINITION) (3) (width WIDTH) (4) STROKE_DEFINITION (5) [(fill yes | no)] (6) [(locked)] (7) (uuid UUID) (8) ) 1 The center token defines the coordinates of the center of the circle. 2 The end token defines the coordinates of the end of the radius of the circle. 3 The layer token defines the canonical layer the circle resides on. 4 The width token defines the line width of the circle. (prior to version 7) 5 The STROKE_DEFINITION describes the line width and style of the circle. (from version 7) 6 The optional fill token defines if the circle is filled. If not defined, the circle is not filled. 7 The optional locked token defines if the circle cannot be edited. 8 The uuid token defines the unique identifier of the circle object. Footprint Arc The fp_arc token defines a graphic arc in a footprint definition.\n(fp_arc (start X Y) (1) (mid X Y) (2) (end X Y) (3) (layer LAYER_DEFINITION) (4) (width WIDTH) (5) STROKE_DEFINITION (6) [(locked)] (7) (uuid UUID) (8) ) 1 The start token defines the coordinates of the start position of the arc radius. 2 The mid token defines the coordinates of the midpoint along the arc. 3 The end token defines the coordinates of the end position of the arc radius. 4 The layer token defines the canonical layer the arc resides on. 5 The width token defines the line width of the arc. (prior to version 7) 6 The STROKE_DEFINITION describes the line width and style of the arc. (from version 7) 7 The optional locked token defines if the arc cannot be edited. 8 The uuid token defines the unique identifier of the arc object. Footprint Polygon The fp_poly token defines a graphic polygon in a footprint definition.\n(fp_poly COORDINATE_POINT_LIST (1) (layer LAYER_DEFINITION) (2) (width WIDTH) (3) STROKE_DEFINITION (4) [(fill yes | no)] (5) [(locked)] (6) (uuid UUID) (7) ) 1 The COORDINATE_POINT_LIST defines the list of X/Y coordinates of the polygon outline. 2 The layer token defines the canonical layer the polygon resides on. 3 The width token defines the line width of the polygon. (prior to version 7) 4 The STROKE_DEFINITION describes the line width and style of the polygon. (from version 7) 5 The optional fill token defines if the polygon is filled. If not defined, the polygon is not filled. 6 The optional locked token defines if the polygon cannot be edited. 7 The uuid token defines the unique identifier of the polygon object. Footprint Curve The fp_curve token defines a graphic Cubic Bezier curve in a footprint definition.\n(fp_curve COORDINATE_POINT_LIST (1) (layer LAYER_DEFINITION) (2) (width WIDTH) (3) STROKE_DEFINITION (4) [(locked)] (5) (uuid UUID) (6) ) 1 The COORDINATE_POINT_LIST defines the four X/Y coordinates of each point of the curve. 2 The layer token defines the canonical layer the curve resides on. 3 The width token defines the line width of the curve. (prior to version 7) 4 The STROKE_DEFINITION describes the line width and style of the curve. (from version 7) 5 The optional locked token defines if the curve cannot be edited. 6 The uuid token defines the unique identifier of the curve object. Footprint Pad The pad token defines a pad in a footprint definition.\n(pad \"NUMBER\" (1) TYPE (2) SHAPE (3) POSITION_IDENTIFIER (4) [(locked)] (5) (size X Y) (6) [(drill DRILL_DEFINITION)] (7) (layers \"CANONICAL_LAYER_LIST\") (8) [(property PROPERTY)] (9) [(remove_unused_layer)] (10) [(keep_end_layers)] (11) [(roundrect_rratio RATIO)] (12) [(chamfer_ratio RATIO)] (13) [(chamfer CORNER_LIST)] (14) (net NUMBER \"NAME\") (15) (uuid UUID) (16) [(pinfunction \"PIN_FUNCTION\")] (17) [(pintype \"PIN_TYPE\")] (18) [(die_length LENGTH)] (19) [(solder_mask_margin MARGIN)] (20) [(solder_paste_margin MARGIN)] (21) [(solder_paste_margin_ratio RATIO)] (22) [(clearance CLEARANCE)] (23) [(zone_connect ZONE)] (24) [(thermal_width WIDTH)] (25) [(thermal_gap DISTANCE)] (26) [CUSTOM_PAD_OPTIONS] (27) [CUSTOM_PAD_PRIMITIVES] (28) ) 1 The \"NUMBER\" attribute is the pad number. 2 The pad TYPE can be defined as thru_hole, smd, connect, or np_thru_hole. 3 The pad SHAPE can be defined as circle, rect, oval, trapezoid, roundrect, or custom. 4 The POSITION_IDENTIFIER defines the X and Y coordinates and optional orientation angle of the pad. 5 The optional locked token defines if the footprint pad can be edited. 6 The size token defines the width and height of the pad. 7 The optional pad DRILL_DEFINITION defines the pad drill requirements. 8 The layers token defines the layer or layers the pad reside on. 9 The optional property token defines any special properties for the pad. Valid properties are pad_prop_bga, pad_prop_fiducial_glob, pad_prop_fiducial_loc, pad_prop_testpoint, pad_prop_heatsink, pad_prop_heatsink, and pad_prop_castellated. 10 The optional remove_unused_layer token specifies that the copper should be removed from any layers the pad is not connected to. 11 The optional keep_end_layers token specifies that the top and bottom layers should be retained when removing the copper from unused layers. 12 The optional roundrect_rratio token defines the scaling factor of the pad to corner radius for rounded rectangular and chamfered corner rectangular pads. The scaling factor is a number between 0 and 1. 13 The optional chamfer_ratio token defines the scaling factor of the pad to chamfer size. The scaling factor is a number between 0 and 1. 14 The optional chamfer token defines a list of one or more rectangular pad corners that get chamfered. Valid chamfer corner attributes are top_left, top_right, bottom_left, and bottom_right. 15 The optional net token defines the integer number and name string of the net connection for the pad. 16 The uuid token defines the unique identifier of the pad object. 17 The optional pinfunction token attribute defines the associated schematic symbol pin name. 18 The optional pintype token attribute defines the associated schematic pin electrical type. 19 The optional die_length token attribute defines the die length between the component pad and physical chip inside the component package. 20 The optional solder_mask_margin token attribute defines the distance between the pad and the solder mask for the pad. If not set, the footprint solder_mask_margin is used. 21 The optional solder_paste_margin token attribute defines the distance the solder paste should be changed for the pad. 22 The optional solder_paste_margin_ratio token attribute defines the percentage to reduce the pad outline by to generate the solder paste size. 23 The optional clearance token attribute defines the clearance from all copper to the pad. If not set, the footprint clearance is used. 24 The optional zone_connection token attribute defines type of zone connect for the pad. If not defined, the footprint zone_connection setting is used. Valid connection types are integers values from 0 to 3 which defines: 0 - Pad is not connect to zone.\n1 - Pad is connected to zone using thermal relief.\n2 - Pad is connected to zone using solid fill.\n25 The optional thermal_width token attribute defines the thermal relief spoke width used for zone connection for the pad. This only affects a pad connected to a zone with a thermal relief. If not set, the footprint thermal_width setting is used. 26 The optional thermal_gap token attribute defines the distance from the pad to the zone of the thermal relief connection for the pad. This only affects a pad connected to a zone with a thermal relief. If not set, the footprint thermal_gap setting is used. 27 The optional custom pad options defines the options when a custom pad is defined. 28 The optional custom pad primitives defines the drawing objects and options used to define a custom pad. Pad Drill Definition The drill token defines the drill attributes for a footprint pad.\n(drill [oval] (1) DIAMETER (2) [WIDTH] (3) [(offset X Y)] (4) ) 1 The optional oval token defines if the drill is oval instead of round. 2 The diameter attribute defines the drill diameter. 3 The optional width attribute defines the width of the slot for oval drills. 4 The optional offset token defines the drill offset coordinates from the center of the pad. Custom Pad Options The optional options token attributes define the settings used for custom pads. This token is only used when a custom pad is defined.\n(options (clearance CLEARANCE_TYPE) (1) (anchor PAD_SHAPE) (2) ) 1 The clearance token defines the type of clearance used for a custom pad. Valid clearance types are outline and convexhull. 2 The anchor token defines the anchor pad shape of a custom pad. Valid anchor pad shapes are rect and circle. Custom Pad Primitives The optional primitives token defines a list of graphical items used to define the outline of a custom pad shape. This token is only used when a custom pad is defined.\n(primitives GRAPHIC_ITEMS... (1) (width WIDTH) (2) [(fill yes)] (3) ) 1 The graphical items is a list of graphical lines, rectangles, arcs, circles, curves, polygons, and annotation bounding boxes that define the shape of the custom pad (annotation bounding boxes from version 7). The item definitions only include the geometrical information that defines the item. The annotation bounding box defines the location (and size) of the pad number and netname. 2 The width token defines the line width of the graphical items. 3 The optional fill token attribute yes indicates the geometry defined by the graphical items should be filled. Footprint 3D Model The model token defines the 3D model associated with a footprint.\n(model \"3D_MODEL_FILE\" (1) (at (xyz X Y Z)) (2) (scale (xyz X Y Z)) (3) (rotate (xyz X Y Z)) (4) ) 1 The 3D_MODEL_FILE attribute is the path and file name of the 3D model. 2 The at token specifies the 3D position coordinates of the model relative to the footprint. 3 The scale token specifies the model scale factor for each 3D axis. 4 The rotate token specifies the model rotation for each 3D axis relative to the footprint. Graphic Items The graphical items are footprint and board items that are outside of the connectivity items. This includes graphical items on technical, user, and copper layers. Graphical items are also used to define complex pad geometries.\nGraphical Text The gr_text token defines graphical text.\n(gr_text \"TEXT\" (1) POSITION_INDENTIFIER (2) (layer LAYER_DEFINITION [knockout]) (3) (uuid UUID) (4) (effects TEXT_EFFECTS) (5) ) 1 The \"TEXT\" attribute is a quoted string that defines the text. 2 The POSITION_IDENTIFER defines the X and Y coordinates and optional orientation angle of the text. 3 The layer token defines the canonical layer the text resides on. It is optionally followed by a knockout token indicating the text should be knocked out. 4 The uuid token defines the unique identifier of the text object. 5 The TEXT_EFFECTS defines how the text is displayed. Graphical Text Box (from version 7)\nThe gr_text_box token defines a rectangle containing line-wrapped text.\n(gr_text_box [locked] (1) \"TEXT\" (2) [(start X Y)] (3) [(end X Y)] (4) [(pts (xy X Y) (xy X Y) (xy X Y) (xy X Y))] (5) [(angle ROTATION)] (6) (layer LAYER_DEFINITION) (7) (uuid UUID) (8) TEXT_EFFECTS (9) [STROKE_DEFINITION] (10) [(render_cache RENDER_CACHE)] (11) ) 1 The optional locked token specifies if the text box can be moved. 2 The content of the text box 3 The start token defines the top-left of a cardinally oriented text box. 4 The end token defines the bottom-right of a cardinally oriented text box. 5 The pts token defines the four corners of a non-cardianlly oriented text box. The corners must be in order, but the winding can be either direction. 6 The optional angle token defines the rotation of the text box in degrees. 7 The layer token defines the canonical layer the text box resides on. 8 The uuid token defines the unique identifier of the text box. 9 The TEXT_EFFECTS describe the style of the text in the text box. 10 The STROKE_DEFINITION describes the style of an optional border to be drawn around the text box. 11 If the TEXT_EFFECTS prescribe a TrueType font then a render cache should be given in case the font can not be found on the current system. If angle is not given, or is a cardinal angle (0, 90, 180 or 270), then the text box MUST have start and end tokens. If angle is given and is not a cardinal angle, then the text box MUST have a pts token (with 4 pts). Graphical Line The gr_line token defines a graphical line.\n(gr_line (start X Y) (1) (end X Y) (2) [(angle ANGLE)] (3) (layer LAYER_DEFINITION) (4) (width WIDTH) (5) (uuid UUID) (6) ) 1 The start token defines the coordinates of the beginning of the line. 2 The end token defines the coordinates of the end of the line. 3 The optional angle token defines the rotational angle of the line. 4 The layer token defines the canonical layer the line resides on. 5 The width token defines the line width. 6 The uuid token defines the unique identifier of the line object. Graphical Rectangle The gr_rect token defines a graphical rectangle.\n(gr_rect (start X Y) (1) (end X Y) (2) (layer LAYER_DEFINITION) (3) (width WIDTH) (4) [(fill yes | no)] (5) (uuid UUID) (6) ) 1 The start token defines the coordinates of the upper left corner of the rectangle. 2 The end token defines the coordinates of the low right corner of the rectangle. 3 The layer token defines the canonical layer the rectangle resides on. 4 The width token defines the line width of the rectangle. 5 The optional fill token defines how the rectangle is filled. If not defined, the rectangle is not filled. 6 The uuid token defines the unique identifier of the rectangle object. Graphical Circle The gr_circle token defines a graphical circle.\n(gr_circle (center X Y) (1) (end X Y) (2) (layer LAYER_DEFINITION) (3) (width WIDTH) (4) [(fill yes | no)] (5) (uuid UUID) (6) ) 1 The center token defines the coordinates of the center of the circle. 2 The end token defines the coordinates of the end of the radius of the circle. 3 The layer token defines the canonical layer the circle resides on. 4 The width token defines the line width of the circle. 5 The optional fill token defines how the circle is filled. If not defined, the circle is not filled. 6 The uuid token defines the unique identifier of the circle object. Graphical Arc The gr_arc token defines a graphical arc.\n(gr_arc (start X Y) (1) (mid X Y) (2) (end X Y) (3) (layer LAYER_DEFINITION) (4) (width WIDTH) (5) (uuid UUID) (6) ) 1 The start token defines the coordinates of the start position of the arc radius. 2 The mid token defines the coordinates of the midpoint along the arc. 3 The end token defines the coordinates of the end position of the arc radius. 4 The layer token defines the canonical layer the arc resides on. 5 The width token defines the line width of the arc. 6 The uuid token defines the unique identifier of the arc object. Graphical Polygon The gr_poly token defines a graphical polygon.\n(gr_poly COORDINATE_POINT_LIST (1) (layer LAYER_DEFINITION) (2) (width WIDTH) (3) [(fill yes | no)] (4) (uuid UUID) (5) ) 1 The COORDINATE_POINT_LIST defines the list of X/Y coordinates of the polygon outline. 2 The layer token defines the canonical layer the polygon resides on. 3 The width token defines the line width of the polygon. 4 The optional fill token defines how the polygon is filled. If not defined, the polygon is not filled. 5 The uuid token defines the unique identifier of the polygon object. Graphical Curve The bezier token defines a graphic Cubic Bezier curve.\n(bezier COORDINATE_POINT_LIST (1) (layer LAYER_DEFINITION) (2) (width WIDTH) (3) (uuid UUID) (4) ) 1 The COORDINATE_POINT_LIST defines the list of X/Y coordinates of the four pointS of the curve. 2 The layer token defines the canonical layer the curve resides on. 3 The width token defines the line width of the curve. 4 The uuid token defines the unique identifier of the curve object. Annotation Bounding Box (from version 7)\nThe gr_bbox token defines a bounding box inside which annotations (such as pad numbers and netnames) will be shown.\n(gr_bbox (start X Y) (1) (end X Y) (2) ) 1 The start token defines the coordinates of the upper left corner of the rectangle. 2 The end token defines the coordinates of the low right corner of the rectangle. Dimension The dimension token defines a dimension object.\n(dimension [locked] (1) (type DIMENSION_TYPE) (2) (layer LAYER_DEFINITION) (3) (uuid UUID) (4) (pts (xy X Y) (xy X Y)) (5) [(height HEIGHT)] (6) [(orientation ORIENTATION)] (7) [(leader_length LEADER_LENGTH)] (8) [(gr_text GRAPHICAL_TEXT)] (9) [(format DIMENSION_FORMAT)] (10) (style DIMENSION_STYLE) (11) ) 1 The optional locked token specifies if the dimension can be moved. 2 The type token attribute defines the type of dimension. Valid dimension types are aligned, leader, center, orthogonal, and radial (radial from version 7). 3 The layer token defines the canonical layer the polygon resides on. 4 The uuid token defines the unique identifier of the dimension object. 5 The pts token attributes define the list of xy coordinates of the dimension. 6 The optional height token attribute defines the height of aligned dimensions. 7 The optional orientation token attribute defines the rotation angle for orthogonal dimensions. 8 The optional leader_length token attribute defines the distance from the marked radius to the knee for radial dimensions. 9 The optional gr_text token attributes define the dimension text formatting for all dimension types except center dimensions. 10 The optional format token attributes define the dimension formatting for all dimension types except center dimensions. 11 The style token attributes define the dimension style information. Dimension Format The format token attributes define the text formatting of the dimension.\n(format [(prefix \"PREFIX\")] (1) [(suffix \"SUFFIX\")] (2) (units UNITS) (3) (units_format UNITS_FORMAT) (4) (precision PRECISION) (5) [(override_value \"VALUE\")] (6) [(suppress_zeros yes | no)] (7) ) 1 The optional prefix token attribute defines the string to add to the beginning of the dimension text. 2 The optional suffix token attribute defines the string to add to the end of the dimension text. 3 The units token attribute defines the dimension units used to display the dimension text. Valid units are as follows: 0 - Inches.\n1 - Mils.\n2 - Millimeters.\n3 - Automatic.\n4 The units_format token attribute defines how the unit’s suffix is formatted. Valid units formats are as follows: 0 - No suffix.\n1 - Bare suffix.\n2 - Wrap suffix in parenthesis.\n5 The precision token attribute defines the number of significant digits to display. From version 7, a precision above 5 indicates a units-scaled precision: 6 - 0.00 in / 0 mils / 0.0 mm\n7 - 0.000 in / 0 mils / 0.00 mm\n8 - 0.0000 in / 0.0 mils / 0.000mm\n9 - 0.00000 in / 0.00 mils / 0.0000mm\n6 The optional override_value token attribute defines the text to substitute for the actual physical dimension. 7 The optional suppress_zeros token removes all trailing zeros from the dimension text. The only valid attributes are yes and no. Dimension Style (style (thickness THICKNESS) (1) (arrow_length LENGTH) (2) (text_position_mode MODE) (3) [(arrow_direction DIRECTION)] (4) [(extension_height HEIGHT)] (5) [(text_frame TEXT_FRAME_TYPE)] (6) [(extension_offset OFFSET)] (7) [(keep_text_aligned yes | no)] (8) ) 1 The thickness token attribute defines the line thickness of the dimension. 2 The arrow_length token attribute defines the length of the dimension arrows. 3 The text_position_mode token attribute defines the position mode of the dimension text. Valid position modes are as follows: 0 - Text is outside the dimension line.\n1 - Text is in line with the dimension line.\n2 - Text has been manually placed by the user.\n4 The arrow_direction token attribute defines the direction of the dimension arrows. Only aligned and orthogonal dimensions support this attribute. Valid directions are as follows: outward: The arrows face outward, pointing away from midpoint of the crossbar.\ninward: The arrows face inward, pointing towards the midpoint of the crossbar.\n5 The optional extension_height token attribute defines the length of the extension lines past the dimension crossbar. 6 The optional text_frame token attribute defines the style of the frame around the dimension text. This only applies to leader dimensions. Valid text frames are as follows: 0 - No text frame.\n1 - Rectangle.\n2 - Circle.\n3 - Rounded rectangle.\n7 The optional extension_offset token attribute defines the distance from feature points to extension line start. 8 The optional keep_text_aligned token indicates that the dimension text should be kept in line with the dimension crossbar. When not defined, the dimension text is shown horizontally regardless of the orientation of the dimension. Zone The zone token defines a zone on the board or footprint. Zones serve two purposes in KiCad: filled copper zones and keep out areas.\n(zone (net NET_NUMBER) (1) (net_name \"NET_NAME\") (2) (layer LAYER_DEFINITION) (3) (uuid UUID) (4) [(name \"NAME\")] (5) (hatch STYLE PITCH) (6) [(priority PRIORITY)] (7) (connect_pads [CONNECTION_TYPE] (clearance CLEARANCE)) (8) (min_thickness THICKNESS) (9) [(filled_areas_thickness no)] (10) [ZONE_KEEPOUT_SETTINGS] (11) ZONE_FILL_SETTINGS (12) (polygon COORDINATE_POINT_LIST) (13) [ZONE_FILL_POLYGONS...] (14) [ZONE_FILL_SEGMENTS...] (15) ) 1 The net token attribute defines by the net ordinal number which net in the nets section that the zone is part of. 2 The net_name token attribute defines the name of the net if the zone is not a keep out area. The net name attribute will be an empty string if the zone is a keep out area. 3 The layer token defines the canonical layer the zone resides on. 4 The uuid token defines the unique identifier of the zone object. 5 The optional name token attribute defines the name of the zone if one has been assigned. 6 The hatch token attributes define the zone outline display hatch style and pitch. Valid hatch styles are none, edge, and full. 7 The optional priority attribute defines the zone priority if it is not zero. 8 The connect_pads token attributes define the pad connection type and clearance. Valid pad connection types are thru_hole_only, full, and no. If the pad connection type is not defined, thermal relief pad connections are used. 9 The min_thickness token attributed defines the minimum fill width allowed in the zone. 10 The optional filled_areas_thickness attribute no specifies if the zone like width is not used when determining the zone fill area. This is to maintain compatibility with older board files that included the line thickness when performing zone fills when it is not defined. 11 The optional zone keep out settings section defines the keep out items if the zone defines as a keep out area. 12 The zone fill settings section defines how the zone is to be filled. 0 - All footprint pads are not connect to zone.\n1 - All footprint pads are connected to zone using thermal relief.\n2 - All footprint pads are connected to zone using solid fill.\n3 - Only footprint through hole pads are connected to zone using thermal relief. Surface mount pads are connected using solid fill.\n13 The polygon token attribute defines the COORDINATE_POINT_LIST of X/Y coordinates of corner points of the polygon outline. the corners of the zone outline polygon. 14 The optional zone fill polygons section defines all of the polygons used to fill the zone. This section will not exist if the zone has not been filled or is filled with segments. 15 The optional zone fill segments section defines a list of track segments used to fill the zone. This is only used when boards prior to version 4 of KiCad are loaded. Zone Keep Out Settings The optional keepout token attributes define which objects should be kept out of the zone. This section only applies to keep out zones.\n(keepout (tracks KEEPOUT) (1) (vias KEEPOUT) (2) (pads KEEPOUT) (3) (copperpour KEEPOUT) (4) (footprints KEEPOUT) (5) ) 1 The tracks token attribute defines whether or not tracks should be excluded from the keep out area. Valid attributes are allowed and not_allowed. 2 The vias token attribute defines whether or not vias should be excluded from the keep out area. Valid attributes are allowed and not_allowed. 3 The pads token attribute defines whether or not pads should be excluded from the keep out area. Valid attributes are allowed and not_allowed. 4 The copperpour token attribute defines whether or not copper pours should be excluded from the keep out area. Valid attributes are allowed and not_allowed. 5 The footprints token attribute defines whether or not footprints should be excluded from the keep out area. Valid attributes are allowed and not_allowed. Zone Fill Settings The fill token attributes define how the zone is to be filled.\n(fill [yes] (1) [(mode FILL_MODE)] (2) (thermal_gap GAP) (3) (thermal_bridge_width WIDTH) (4) [(smoothing STYLE)] (5) [(radius RADIUS)] (6) [(island_removal_mode MODE)] (7) [(island_area_min AREA)] (8) [(hatch_thickness THICKNESS)] (9) [(hatch_gap GAP)] (10) [(hatch_orientation ORIENTATION)] (11) [(hatch_smoothing_level LEVEL)] (12) [(hatch_smoothing_value VALUE)] (13) [(hatch_border_algorithm TYPE)] (14) [(hatch_min_hole_area AREA)] (15) ) 1 The yes token specifies if the zone should be filled. If not specified, the zone is not filled and no additional attributes are required. 2 The optional mode token attribute defines how the zone is filled. The only valid fill mode is hatched. When not defined, the fill mode is solid. 3 The optional thermal_gap token attribute defines the distance from the zone to all pad thermal relief connections to the zone. 4 The optional thermal_bridge_width token attribute defines the spoke width for all pad thermal relief connection to the zone. 5 The optional smoothing token attributes define the style of corner smoothing. Valid smoothing styles are chamfer and fillet. 6 The optional radius token defines the radius of the corner smoothing. 7 The optional island_removal_mode token attribute defines the island removal mode. Valid island removal modes are: 0 - Always remove islands.\n1 - Never remove islands.\n2 - Minimum area island to allow.\n8 The optional island_area_min token attribute defines the minimum allowable zone island. This only valid when the remove islands mode is set to 2. 9 The optional hatch_thickness token attribute defines the thickness for hatched fills. 10 The optional hatch_gap token attribute defines the distance between lines for hatched fills. 11 The optional hatch_orientation token attribute defines the line angle for hatched fills. 12 The optional hatch_smoothing_level token attribute defines how hatch outlines are smoothed. Valid hatch smoothing levels are: 0 - No smoothing.\n1 - Fillet.\n2 - Arc minimum.\n3 - Arc maximum.\n13 The optional hatch_smoothing_value token attribute defines the ratio between the hole and the chamfer/fillet size. 14 The optional hatch_border_algorithm token attribute defines the if the zone line thickness is used when performing a hatch fill. Valid values for the hatch border algorithm are: 0 - Use zone minimum thickness.\n1 - Use hatch thickness.\n15 The optional hatch_min_hole_area token attribute defines the minimum area a hatch file hole can be. Zone Fill Polygons The filled_polygon token defines the polygons used to fill the zone. This token will not exist if the zone has not been filled.\n(filled_polygon (layer LAYER_DEFINITION) (1) COORDINATE_POINT_LIST (2) ) 1 The layer token attribute defines the canonical layer the zone fill resides on. 2 The COORDINATE_POINT_LIST defines the list of polygon X/Y coordinates used to fill the zone. Zone Fill Segments The filled_segments token defines the segments used to fill the zone. This is only used when loading boards prior to version 4 which filled zones with segments. Once the zone has been refilled, it will be filled with polygons and this token will not exist.\n(fill_segments (layer LAYER_DEFINITION) (1) COORDINATED_POINT_LIST (2) ) 1 The layer token attribute defines the canonical layer the zone fill resides on. 2 The COORDINATE_POINT_LIST defines the list of X and Y coordinates of the segments used to fill the zone. Group The group token defines a group of items.\n(group \"NAME\" (1) (id UUID) (2) (members UUID1 ... UUIDN) (3) ) 1 The name attribute defines the name of the group. 2 The id token attribute defines the unique identifier of the group. 3 The members token attributes define a list of unique identifiers of the objects belonging to the group. Schematic and Symbol Library Common Syntax This section defines all syntax that is shared across the symbol library and schematic file formats.\nSchematic Coordinates The minimum internal unit for schematic and symbol library files is one nanometer so there is maximum resolution of four decimal places or 0.0001 mm. Any precision beyond four places will be truncated.\nSymbol Unit Identifier Symbol unit identifiers define how symbol units are identified. The unit identifier is a quoted string have the format \"NAME_UNIT_STYLE\". \"NAME\" is the parent symbol name. \"UNIT\" is an integer that identifies which unit the symbol represents. A \"UNIT\" value of zero (0) indicates that the symbol is common to all units. The \"STYLE\" indicates which body style the unit represents.\nThis identifier is a temporary solution until the full symbol inheritance model is implemented. KiCad only supports two body styles so the only valid values for the \"STYLE\" are 1 and 2. Fill Definition The fill token defines how schematic and symbol library graphical items are filled.\n(fill (type none | outline | background) (1) ) 1 The fill token attributes define how the arc is filled. The table below describes the fill type modes. The table below defines the schematic and symbol graphical object fill modes.\nToken Description none\nGraphic item not filled.\noutline\nGraphic item filled with the line color.\nbackground\nGraphic filled with the theme background color.\nSymbols The symbol token defines a symbol or sub-unit of a parent symbol. There can be zero or more symbol tokens in a symbol library file.\n(symbol \"LIBRARY_ID\" | \"UNIT_ID\" (1) [(extends \"LIBRARY_ID\")] (2) [(pin_numbers hide)] (3) [(pin_names [(offset OFFSET)] hide)] (4) (in_bom yes | no) (5) (on_board yes | no) (6) SYMBOL_PROPERTIES... (7) GRAPHIC_ITEMS... (8) PINS... (9) UNITS... (10) [(unit_name \"UNIT_NAME\")] (11) ) 1 Each symbol must have a unique \"LIBRARY_ID\" for each top level symbol in the library or a unique \"UNIT_ID\" for each unit embedded in a parent symbol. Library identifiers are only valid it top level symbols and unit identifiers are on valid as unit symbols inside a parent symbol. 2 The optional extends token attribute defines the \"LIBRARY_ID\" of another symbol inside the current library from which to derive a new symbol. Extended symbols currently can only have different SYMBOL_PROPERTIES than their parent symbol. 3 The optional pin_numbers token defines the visibility setting of the symbol pin numbers for the entire symbol. If not defined, the all of the pin numbers in the symbol are visible. 4 The optional pin_names token defines the attributes for all of the pin names of the symbol. The optional offset token defines the pin name offset for all pin names of the symbol. If not defined, the pin name offset is 0.508mm (0.020\"). If the pin_name token is not defined, the all symbol pins are shown with the default offset. 5 The in_bom token, defines if a symbol is to be include in the bill of material output. The only valid attributes are yes and no. 6 The on_board token, defines if a symbol is to be exported from the schematic to the printed circuit board. The only valid attributes are yes and no. 7 The SYMBOL_PROPERTIES is a list of properties that define the symbol. The following properties are mandatory when defining a parent symbol: \"Reference\", \"Value\", \"Footprint\", and \"Datasheet\". All other properties are optional. Unit symbols cannot have any properties. 8 The GRAPHIC ITEMS section is list of graphical arcs, circles, curves, lines, polygons, rectangles and text that define the symbol drawing. This section can be empty if the symbol has no graphical items. 9 The PINS section is a list of pins that are used by the symbol. This section can be empty if the symbol does not have any pins. 10 The optional UNITS can be one or more child symbol tokens embedded in a parent symbol. 11 The optional unit_name token defines the display name of a subunit in the symbol editor and symbol chooser. It is only permitted for child symbol tokens embedded in a parent symbol. Symbol Properties The property token defines a symbol property when used inside a symbol definition.\nSymbol properties are different than general purpose properties defined above. (property \"KEY\" (1) \"VALUE\" (2) (id N) (3) POSITION_IDENTIFIER (4) TEXT_EFFECTS (5) } 1 The \"KEY\" string defines the name of the property and must be unique. 2 The \"VALUE\" string defines the value of the property. 3 The id token defines an integer ID for the property and must be unique. 4 The POSITION_IDENTIFIER defines the X and Y coordinates and rotation angle of the property. 5 The TEXT_EFFECTS section defines how the text is displayed. Mandatory Symbol Properties The table below defines the mandatory properties for parent symbols.\nTable 1. Mandatory Properties Key Ordinal Description Empty Allowed Reference\n0\nSymbol reference designator\nNo\nValue\n1\nSymbol value string\nNo\nFootprint\n2\nSymbol footprint library identifier\nYes\nDatasheet\n3\nSymbol datasheet link\nYes\nReserved Symbol Property Keys The list below is the list of property keys reserve by KiCad and cannot be user for user defined properties.\nki_keywords\nki_description\nki_locked\nki_fp_filters\nSymbol Graphic Items This section documents the various graphical objects used in symbol definitions.\nSymbol Arc The arc token defines a graphical arc in a symbol definition.\n(arc (start X Y) (1) (mid X Y) (2) (end X Y) (3) STROKE_DEFINITION (4) FILL_DEFINITION (5) ) 1 The start token defines the coordinates of start point of the arc. 2 The mid token defines the coordinates of mid point of the arc. 3 The end token defines the coordinates of end point of the arc. 4 The STROKE_DEFINITION defines how the arc outline is drawn. 5 The fill token attributes define how the arc is filled. Symbol Circle The circle token defines a graphical circle in a symbol definition.\n(circle (center X Y) (1) (radius RADIUS) (2) STROKE_DEFINITION (3) FILL_DEFINITION (4) ) 1 The center token defines the coordinates of center point of the circle. 2 The radius token defines the length of the radius of the circle. 3 The STROKE_DEFINITION defines how the circle outline is drawn. 4 The FILL_DEFINTION defines how the circle is filled. Symbol Curve The bezier token defines a graphical . Qubic Bezier curve.\n(bezier COORDINATE_POINT_LIST (1) STROKE_DEFINITION (2) FILL_DEFINITION (3) ) 1 The COORDINATE_POINT_LIST defines the four X/Y coordinates of each point of the curve. 2 The STROKE_DEFINITION defines how the curve outline is drawn. 3 The FILL_DEFINTION defines how the curve is filled. Symbol Line The polyline token defines one or more graphical lines that may or may not define a polygon.\n(polyline COORDINATE_POINT_LIST (1) STROKE_DEFINITION (2) FILL_DEFINITION (3) ) 1 The COORDINATE_POINT_LIST defines the list of X/Y coordinates of the line(s). There must be a minimum of two points. 2 The STROKE_DEFINITION defines how the polygon formed by the lines outline is drawn. 3 The fill token attributes define how the polygon formed by the lines is filled. Symbol Rectangle The rectangle token defines a graphical rectangle in a symbol definition.\n(rectangle (start X Y) (1) (end X Y) (2) STROKE_DEFINITION (3) FILL_DEFINITION (4) ) 1 The start token attributes define the coordinates of the start point of the rectangle. 2 The end token attributes define the coordinates of the end point of the rectangle. 3 The STROKE_DEFINITION defines how the rectangle outline is drawn. 4 The FILL_DEFINTION defines how the rectangle is filled. Symbol Text The text token defines graphical text in a symbol definition.\n(text \"TEXT\" (1) POSITION_IDENTIFIER (2) (effects TEXT_EFFECTS) (3) ) 1 The \"TEXT\" attribute is a quoted string that defines the text. 2 The POSITION_IDENTIFIER defines the X and Y coordinates and rotation angle of the text. 3 The TEXT_EFFECTS defines how the text is displayed. Symbol Pin The pin token defines a pin in a symbol definition.\n(pin PIN_ELECTRICAL_TYPE (1) PIN_GRAPHIC_STYLE (2) POSITION_IDENTIFIER (3) (length LENGTH) (4) (name \"NAME\" TEXT_EFFECTS) (5) (number \"NUMBER\" TEXT_EFFECTS) (6) ) 1 The PIN_ELECTRICAL_TYPE defines the pin electrical connection. See table below for valid pin electrical connection types and descriptions. 2 The PIN_GRAPHICAL_STYLE defines the graphical style used to draw the pin. See table below for valid pin graphical styles and descriptions. 3 The POSITION_IDENTIFIER defines the X and Y coordinates and rotation angle of the connection point of the pin relative to the symbol origin position. The only supported rotation angles for pins are 0, 90, 180, and 270 degrees. 4 The length token attribute defines the LENGTH of the pin. 5 The name token defines a quoted string containing the NAME of the pin and the TEXT_EFFECTS defines how the text is displayed. 6 The number token defines a quoted string containing the NUMBER of the pin and the TEXT_EFFECTS defines how the text is displayed. The table below defines the pin electrical types.\nToken Description input\nPin is an input.\noutput\nPin is an output.\nbidirectional\nPin can be both input and output.\ntri_state\nPin is a tri-state output.\npassive\nPin is electrically passive.\nfree\nNot internally connected.\nunspecified\nPin does not have a specified electrical type.\npower_in\nPin is a power input.\npower_out\nPin is a power output.\nopen_collector\nPin is an open collector output.\nopen_emitter\nPin is an open emitter output.\nno_connect\nPin has no electrical connection.\nThe table below defines the pin graphical styles.\nToken Pin Image line\ninverted\nclock\ninverted_clock\ninput_low\nclock_low\noutput_low\nedge_clock_high\nnon_logic",
    "description": "",
    "tags": [],
    "title": "S-Expression Format",
    "uri": "/en/file-formats/sexpr-intro/index.html"
  },
  {
    "breadcrumb": "File Formats",
    "content": " Introduction This documents the s-expression footprint library file format for all versions of KiCad from 6.0.\nFootprint library files use the .kicad_mod extension.\nFootprint library files can only define a single footprint.\nFootprint libraries are defined a folder containing one or more footprint library files.\nThis file format was introduced with the launch of KiCad 4.0. Prior to version 6 of KiCad, strings were only quoted when necessary. Saving an older board file to the latest file format will result in these strings being quoted even though there is no functional change in the board itself. Layout A footprint library file includes the following sections:\nHeader\nFootprint Definition\nHeader Section The footprint token indicates that it is KiCad footprint library file. This section is required.\nThird party scripts should not use pcbnew as the generator identifier. Please use some other identifier so that bugs introduced by third party generators are not confused with a footprint library file created by KiCad. (footprint \"NAME\" (1) (version VERSION) (2) (generator GENERATOR) (3) ;; contents of the footprint library file... (4) ) 1 The footprint NAME is a quoted string that defines the name of the footprint. 2 The version token attribute defines the board version using the YYYYMMDD date format. 3 The generator token attribute defines the program used to write the file. 4 The footprint definition goes here. Footprint Section See the footprint in the s-expression board common definitions.",
    "description": "",
    "tags": [],
    "title": "Footprint Library File Format",
    "uri": "/en/file-formats/sexpr-footprint/index.html"
  },
  {
    "breadcrumb": "File Formats",
    "content": " Introduction This documents the s-expression board file format for all versions of KiCad from 6.0.\nPrinted circuit board files use the .kicad_pcb extension.\nThis file format was introduced with the launch of KiCad 4.0. Prior to version 6 of KiCad, strings were only quoted when necessary. Saving an older board file to the latest file format will result in these strings being quoted even though there is no functional change in the board itself. Layout A board file includes the following sections:\nHeader\nGeneral\nLayers\nSetup\nProperties\nNets\nFootprints\nGraphic Items\nImages\nTracks\nZones\nGroups\nThe section order is not critical other than the header must be the first token. Some sections can may omitted. Header Section The kicad_pcb token indicates that it is KiCad board file. This section is required.\nThird party scripts should not use pcbnew as the generator identifier. Please use some other identifier so that bugs introduced by third party generators are not confused with the board file created by KiCad. (kicad_pcb (version VERSION) (1) (generator GENERATOR) (2) ;; contents of board file... (3) ) 1 The version token attribute defines the board version using the YYYYMMDD date format. 2 The generator token attribute defines the program used to write the file. 3 The remaining sections of the board definition goes here. General Section The general token define general information about the board. This section is required.\nMost of the redundant information in the general section prior to version 6 has been removed. The removed information does not affect the board output. (general (thickness THICKNESS) (1) ) 1 The thickness token attribute defines the overall board thickness. Page Section See the page settings definition in the common s-expression section. This section is required.\nLayers Section The layers token defines all of the layers used by the board. This section is required.\n(layers ( ORDINAL (1) \"CANONICAL_NAME\" (2) TYPE (3) [\"USER_NAME\"] (4) ) ;; remaining layers... ) 1 The layer ORDINAL is an integer used to associate the layer stack ordering. This is mostly to ensure correct mapping when the number of layers is increased in the future. 2 The CANONICAL_NAME is the layer name defined for internal board use. 3 The layer TYPE defines the type of layer and can be defined as jumper, mixed, power, signal, or user. 4 The optional USER_NAME attribute defines the custom user name. Setup Section The setup token is used to store the current settings such as default item sizes and other options used by the board. This section is required.\n(setup [(STACK_UP_SETTINGS)] (1) (pad_to_mask_clearance CLEARANCE) (2) [(solder_mask_min_width MINIMUM_WIDTH)] (3) [(pad_to_paste_clearance CLEARANCE)] (4) [(pad_to_paste_clearance_ratio RATIO)] (5) [(aux_axis_origin X Y)] (6) [(grid_origin X Y)] (7) (PLOT_SETTINGS) (8) ) 1 The optional STACK_UP_SETTINGS define the parameters required to manufacture the board. 2 The pad_to_mask_clearance token defines the clearance between footprint pads and the solder mask. 3 The optional solder_mask_min_width defines the minimum solder mask width. If not defined, the minimum width is zero. 4 The optional pad_to_paste_clearance defines the clearance between footprint pads and the solder paste layer. If not defined, the clearance is zero. 5 The optional pad_to_paste_clearance_ratio is the percentage (from 0 to 100) of the footprint pad to make the solder paste. If not defined, the ratio is 100% (the same size as the pad). 6 The optional aux_axis_origin defines the auxiliary origin if it is set to anything other than (0,0). 7 The optional grid_origin defines the grid original if it is set to anything other than (0,0). 8 The PLOT_SETTINGS define how the board was last plotted. Stack Up Settings The optional stackup toke defines the board stack up settings and is defined in the setup section.\n(stackup (LAYER_STACK_UP_DEFINITIONS) (1) [(copper_finish \"FINISH\")] (2) [(dielectric_constraints yes | no)] (3) [(edge_connector yes | bevelled)] (4) [(castellated_pads yes)] (5) [(edge_plating yes)] (6) ) 1 The layer stack up definitions is a list of layer settings for each layer required to manufacture a board including the dielectric material between the actual layers defined in the board editor. 2 The optional copper_finish token is a string that defines the copper finish used to manufacture the board. 3 The optional dielectric_contraints token define if the board should meet all dielectric requirements. 4 The optional edge_connector token defines if the board has an edge connector and if the edge connector is bevelled. 5 The optional castellated_pads token defines if the board edges contain castellated pads. 6 The optional edge_plating token defines if the board edges should be plated. Stack Up Layer Settings The layer token defines the stack up setting of a single layer in the board stack up settings.\n(layer \"NAME\" | dielectric (1) NUMBER (2) (type \"DESCRIPTION\") (3) [(color \"COLOR\")] (4) [(thickness THICKNESS)] (5) [(material \"MATERIAL\")] (6) [(epsilon_r DIELECTRIC_RESISTANCE)] (7) [(loss_tangent LOSS_TANGENT)] (8) ) 1 The layer name attribute is either one of the canonical copper or technical layer names listed in the table above or dielectric ID if it is dielectric layer. 2 The layer number attribute defines the stack order of the layer. 3 The layer type token defines a string that describes the layer. 4 The optional layer color token defines a string that describes the layer color. This is only used on solder mask and silkscreen layers. 5 The optional layer thickness token defines the thickness of the layer where appropriate. 6 The optional layer material token defines a string that describes the layer material where appropriate. 7 The optional layer epsilon_r token defines the dielectric constant of the layer material. 8 The optional layer loss_tangent token defines the dielectric loss tangent of the layer Plot Settings The pcbplotparams toke defines the plotting and printing settings used for the last plot and is defined in the set up section.\n(pcbplotparams (layerselection HEXADECIMAL_BIT_SET) (1) (disableapertmacros true | false) (2) (usegerberextensions true | false) (3) (usegerberattributes true | false) (4) (usegerberadvancedattributes true | false) (5) (creategerberjobfile true | false) (6) (svguseinch true | false) (7) (svgprecision PRECISION) (8) (excludeedgelayer true | false) (9) (plotframeref true | false) (10) (viasonmask true | false) (11) (mode MODE) (12) (useauxorigin true | false) (13) (hpglpennumber NUMBER) (14) (hpglpenspeed SPEED) (15) (hpglpendiameter DIAMETER) (16) (dxfpolygonmode true | false) (17) (dxfimperialunits true | false) (18) (dxfusepcbnewfont true | false) (19) (psnegative true | false) (20) (psa4output true | false) (21) (plotreference true | false) (22) (plotvalue true | false) (23) (plotinvisibletext true | false) (24) (sketchpadsonfab true | false) (25) (subtractmaskfromsilk true | false) (26) (outputformat FORMAT) (27) (mirror true | false) (28) (drillshape SHAPE) (29) (scaleselection 1) (30) (outputdirectory \"PATH\") (31) ) 1 The layerselection token defines a hexadecimal bit set of the layers to plot. 2 The disableapertmacros token defines if aperture macros are to be used in gerber plots. 3 The usegerberextensions token defines if the Protel layer file name extensions are to be used in gerber plots. 4 The usegerberattributes token defines if the X2 extensions are used in gerber plots. 5 The usegerberadvancedattributes token defines if the netlist information should be included in gerber plots. 6 The creategerberjobfile token defines if a job file should be created when plotting gerber files. 7 The svguseinch token defines if inch units should be use when plotting SVG files. 8 The svgprecision token defines the units precision used when plotting SVG files. 9 The excludeedgelayer token defines if the board edge layer is plotted on all layers. 10 The plotframeref token defines if the border and title block should be plotted. 11 The viasonmask token defines if the vias are to be tented. 12 The mode token defines the plot mode. An attribute of 1 plots in the normal mode and an attribute of 2 plots in the outline (sketch) mode. 13 The useauxorigin token determines if all coordinates are offset by the defined user origin. 14 The hpglpennumber token defines the integer pen number used for HPGL plots. 15 The hpglpenspeed token defines the integer pen speed used for HPGL plots. 16 The hpglpendiameter token defines the floating point pen size for HPGL plots. 17 The dxfpolygonmode token defines if the polygon mode should be used for DXF plots. 18 The dxfimperialunits token defines if imperial units should be used for DXF plots. 19 The dxfusepcbnewfont token defines if the Pcbnew font (vector font) or the default font should be used for DXF plots. 20 The psnegative token defines if the output should be the negative for PostScript plots. 21 The psa4output token defines if the A4 page size should be used for PostScript plots. 22 The plotreference token defines if hidden reference field text should be plotted. 23 The plotvalue token defines if hidden value field text should be plotted. 24 The plotinvisibletext token defines if hidden text other than the reference and value fields should be plotted. 25 The sketchpadsonfab token defines if pads should be plotted in the outline (sketch) mode. 26 The subtractmaskfromsilk toke defines if the solder mask layers should be subtracted from the silk screen layers for gerber plots. 27 The outputformat token defines the last plot type. 0 - gerber\n1 - PostScript\n2 - SVG\n3 - DXF\n4 - HPGL\n5 - PDF\n28 The mirror token defines if the plot should be mirrored. 29 The drillshape token defines the type of drill marks used for drill files. 30 The scaleselection token defines DOCUMENT ME. 31 The outputdirectory token defines the path relative to the current project path where the plot files will be saved. Property Section See the properity definition in the s-expression common section. If no properties are defined, this section will not exist.\nNets Section The net token defines a net for the board. This section is required.\nThe net class section has been moved out of the board file into the design rules file. (net ORDINAL (1) \"NET_NAME\" (2) ) 1 The oridinal attribute is an integer that defines the net order. 2 The net name is a string that defines the name of the net. Footprint Section See the footprint in the s-expression board common definitions. This section will not exist if there are no footprints on the board.\nGraphic Items Section See the Graphic Items section in the s-expression board common definitions. This section will not exist if there are no graphics on the board.\nImages Section See the Images section in the s-expression board common definitions. This section will not exist if there are no images on the board.\nTracks Section This section lists all of segment, via, and arc objects that make up tracks on the board.\nTrack Segment The segment token defines a track segment.\n(segment (start X Y) (1) (end X Y) (2) (width WIDTH) (3) (layer LAYER_DEFINITION) (4) [(locked)] (5) (net NET_NUMBER) (6) (tstamp UUID) (7) ) 1 The start token defines the coordinates of the beginning of the line. 2 The end token defines the coordinates of the end of the line. 3 The width token defines the line width. 4 The layer token defines the canonical layer the track segment resides on. 5 The optional locked token defines if the line cannot be edited. 6 The net token defines by the net ordinal number which net in the net section that the segment is part of. 7 The tstamp token defines the unique identifier of the line object. Track Via The via token defines a track via.\n(via [TYPE] (1) [(locked)] (2) (at X Y) (3) (size DIAMETER) (4) (drill DIAMETER) (5) (layers LAYER1 LAYER2) (6) [(remove_unused_layers)] (7) [(keep_end_layers)] (8) [(free)] (9) (net NET_NUMBER) (10) (tstamp UUID) (11) ) 1 The optional type attribute specifies the via type. Valid via types are blind and micro. If no type is defined, the via is a through hole type. 2 The optional locked token defines if the line cannot be edited. 3 The at token attributes define the coordinates of the center of the via. 4 The size token attribute defines the diameter of the via annular ring. 5 The drill token attribute defines the drill diameter of the via. 6 The layers token attributes define the canonical layer set the via connects. 7 The optional remove_unused_layers token specifies DOCUMENT ME. 8 The optional keep_end_layers token specifies DOCUMENT ME. This token is only defined when the remove_unused_layers token is defined. 9 The optional free token indicates that the via is free to be moved outside it’s assigned net. 10 The net token attribute defines by net ordinal number which net in the net section that the segment is part of. 11 The tstamp token defines the unique identifier of the line object. Track Arc The arc token defines a track arc.\n(arc (start X Y) (1) (mid X Y) (2) (end X Y) (3) (width X Y) (4) (layer LAYER_DEFINITION) (5) [(locked)] (6) (net NET_NUMBER) (7) (tstamp UUID) (8) ) 1 The start token defines the coordinates of the beginning of the arc. 2 The mid toke defines the coordinates of the mid point of the radius of the arc. 3 The end token defines the coordinates of the end of the arc. 4 The width token defines the line width. 5 The layer token defines the canonical layer the track arc resides on. 6 The optional locked token defines if the line cannot be edited. 7 The net token defines by the net ordinal number which net in the net section that the segment is part of. 8 The tstamp token defines the unique identifier of the line object. Zones Section See the zone definition in the s-expression board common definitions. This section will not exist if there are no zones on the board.\nGroup Section See the group definition in the s-expression board common definitions. This section will not exist if there are no groups on the board.\nBoard Example: (kicad_pcb (version 3) (host pcbnew \"(2013-02-20 BZR 3963)-testing\") (general (links 2) (no_connects 0) (area 57.924999 28.924999 74.075001 42.075001) (thickness 1.6) (drawings 5) (tracks 5) (zones 0) (modules 2) (nets 3) ) (page A4) (layers (15 top_side.Cu signal) (2 Inner2.Cu signal) (1 Inner1.Cu signal) (0 bottom_side.Cu signal) (16 B.Adhes user) (17 F.Adhes user) (18 B.Paste user) (19 F.Paste user) (20 B.SilkS user) (21 F.SilkS user) (22 B.Mask user) (23 F.Mask user) (24 Dwgs.User user) (25 Cmts.User user) (26 Eco1.User user) (27 Eco2.User user) (28 Edge.Cuts user) ) (setup (last_trace_width 0.254) (trace_clearance 0.254) (zone_clearance 0.2) (zone_45_only no) (trace_min 0.254) (segment_width 0.2) (edge_width 0.15) (via_size 0.889) (via_drill 0.635) (via_min_size 0.889) (via_min_drill 0.508) (uvia_size 0.508) (uvia_drill 0.127) (uvias_allowed no) (uvia_min_size 0.508) (uvia_min_drill 0.127) (pcb_text_width 0.3) (pcb_text_size 1.5 1.5) (mod_edge_width 0.15) (mod_text_size 1.5 1.5) (mod_text_width 0.15) (pad_size 0.0005 0.0005) (pad_drill 0) (pad_to_mask_clearance 0.2) (aux_axis_origin 0 0) (visible_elements 7FFFFFFF) (pcbplotparams (layerselection 3178497) (usegerberextensions true) (excludeedgelayer true) (linewidth 50000) (plotframeref false) (viasonmask false) (mode 1) (useauxorigin false) (hpglpennumber 1) (hpglpenspeed 20) (hpglpendiameter 15) (hpglpenoverlay 2) (psnegative false) (psa4output false) (plotreference true) (plotvalue true) (plotothertext true) (plotinvisibletext false) (padsonsilk false) (subtractmaskfromsilk false) (outputformat 1) (mirror false) (drillshape 1) (scaleselection 1) (outputdirectory \"\")) ) (net 0 \"\") (net 1 /SIGNAL) (net 2 GND) (net_class Default \"Ceci est la Netclass par dÃ©faut\" (clearance 0.254) (trace_width 0.254) (via_dia 0.889) (via_drill 0.635) (uvia_dia 0.508) (uvia_drill 0.127) (add_net \"\") (add_net /SIGNAL) ) (net_class POWER \"\" (clearance 0.254) (trace_width 0.5) (via_dia 1.2) (via_drill 0.635) (uvia_dia 0.508) (uvia_drill 0.127) (add_net GND) ) (module R3 (layer top_side.Cu) (tedit 4E4C0E65) (tstamp 5127A136) (at 66.04 33.3502) (descr \"Resitance 3 pas\") (tags R) (path /5127A011) (autoplace_cost180 10) (fp_text reference R1 (at 0 0.127) (layer F.SilkS) hide (effects (font (size 1.397 1.27) (thickness 0.2032))) ) (fp_text value 330K (at 0 0.127) (layer F.SilkS) (effects (font (size 1.397 1.27) (thickness 0.2032))) ) (fp_line (start -3.81 0) (end -3.302 0) (layer F.SilkS) (width 0.2032)) (fp_line (start 3.81 0) (end 3.302 0) (layer F.SilkS) (width 0.2032)) (fp_line (start 3.302 0) (end 3.302 -1.016) (layer F.SilkS) (width 0.2032)) (fp_line (start 3.302 -1.016) (end -3.302 -1.016) (layer F.SilkS) (width 0.2032)) (fp_line (start -3.302 -1.016) (end -3.302 1.016) (layer F.SilkS) (width 0.2032)) (fp_line (start -3.302 1.016) (end 3.302 1.016) (layer F.SilkS) (width 0.2032)) (fp_line (start 3.302 1.016) (end 3.302 0) (layer F.SilkS) (width 0.2032)) (fp_line (start -3.302 -0.508) (end -2.794 -1.016) (layer F.SilkS) (width 0.2032)) (pad 1 thru_hole circle (at -3.81 0) (size 1.397 1.397) (drill 0.812799) (layers *.Cu *.Mask F.SilkS) (net 1 /SIGNAL) ) (pad 2 thru_hole circle (at 3.81 0) (size 1.397 1.397) (drill 0.812799) (layers *.Cu *.Mask F.SilkS) (net 2 GND) ) (model discret/resistor.wrl (at (xyz 0 0 0)) (scale (xyz 0.3 0.3 0.3)) (rotate (xyz 0 0 0)) ) ) (module CP4 (layer top_side.Cu) (tedit 5127A26C) (tstamp 5127A146) (at 66.1416 36.8808) (descr \"Condensateur polarise\") (tags CP) (path /50FD6D39) (fp_text reference C1 (at 0.508 0) (layer F.SilkS) (effects (font (size 1.27 1.397) (thickness 0.254))) ) (fp_text value 10uF (at 0.8584 2.1192) (layer F.SilkS) hide (effects (font (size 1.27 1.143) (thickness 0.254))) ) (fp_line (start 5.08 0) (end 4.064 0) (layer F.SilkS) (width 0.3048)) (fp_line (start 4.064 0) (end 4.064 1.016) (layer F.SilkS) (width 0.3048)) (fp_line (start 4.064 1.016) (end -3.556 1.016) (layer F.SilkS) (width 0.3048)) (fp_line (start -3.556 1.016) (end -3.556 -1.016) (layer F.SilkS) (width 0.3048)) (fp_line (start -3.556 -1.016) (end 4.064 -1.016) (layer F.SilkS) (width 0.3048)) (fp_line (start 4.064 -1.016) (end 4.064 0) (layer F.SilkS) (width 0.3048)) (fp_line (start -5.08 0) (end -4.064 0) (layer F.SilkS) (width 0.3048)) (fp_line (start -3.556 0.508) (end -4.064 0.508) (layer F.SilkS) (width 0.3048)) (fp_line (start -4.064 0.508) (end -4.064 -0.508) (layer F.SilkS) (width 0.3048)) (fp_line (start -4.064 -0.508) (end -3.556 -0.508) (layer F.SilkS) (width 0.3048)) (pad 1 thru_hole rect (at -5.08 0) (size 1.397 1.397) (drill 0.812799) (layers *.Cu *.Mask F.SilkS) (net 1 /SIGNAL) ) (pad 2 thru_hole circle (at 5.08 0) (size 1.397 1.397) (drill 0.812799) (layers *.Cu *.Mask F.SilkS) (net 2 GND) ) (model discret/c_pol.wrl (at (xyz 0 0 0)) (scale (xyz 0.4 0.4 0.4)) (rotate (xyz 0 0 0)) ) ) (gr_text TEST (at 62 31) (layer top_side.Cu) (effects (font (size 1.5 1.5) (thickness 0.3))) ) (gr_line (start 58 42) (end 58 29) (angle 90) (layer Edge.Cuts) (width 0.15)) (gr_line (start 74 42) (end 58 42) (angle 90) (layer Edge.Cuts) (width 0.15)) (gr_line (start 74 29) (end 74 42) (angle 90) (layer Edge.Cuts) (width 0.15)) (gr_line (start 58 29) (end 74 29) (angle 90) (layer Edge.Cuts) (width 0.15)) (segment (start 61.0616 36.8808) (end 61.0616 34.5186) (width 0.254) (layer bottom_side.Cu) (net 1)) (segment (start 61.0616 34.5186) (end 62.23 33.3502) (width 0.254) (layer bottom_side.Cu) (net 1) (tstamp 5127A159)) (segment (start 69.85 33.3502) (end 70.993 33.3502) (width 0.5) (layer bottom_side.Cu) (net 2)) (segment (start 71.2216 33.5788) (end 71.2216 36.8808) (width 0.5) (layer bottom_side.Cu) (net 2) (tstamp 5127A156)) (segment (start 70.993 33.3502) (end 71.2216 33.5788) (width 0.5) (layer bottom_side.Cu) (net 2) (tstamp 5127A155)) (zone (net 2) (net_name GND) (layer bottom_side.Cu) (tstamp 5127A1B2) (hatch edge 0.508) (connect_pads (clearance 0.2)) (min_thickness 0.1778) (fill (arc_segments 16) (thermal_gap 0.254) (thermal_bridge_width 0.4064)) (polygon (pts (xy 59 30) (xy 73 30) (xy 73 41) (xy 59 41) ) ) ) ) ",
    "description": "",
    "tags": [],
    "title": "Board File Format",
    "uri": "/en/file-formats/sexpr-pcb/index.html"
  },
  {
    "breadcrumb": "File Formats",
    "content": " Introduction This documents the s-expression symbol library file format for all versions of KiCad from 6.0.\nSymbol library files use the .kicad_sym extension.\nSymbol library files can define one or more symbols.\nLayout A symbol library file includes the following sections:\nHeader\nSymbol Definition\nHeader Section The kicad_symbol_lib token indicates that it is KiCad symbol library file. This section is required.\nThird party scripts should not use kicad_symbol_editor as the generator identifier. Please use some other identifier so that bugs introduced by third party generators are not confused with a footprint library file created by KiCad. (kicad_symbol_lib (version VERSION) (1) (generator GENERATOR) (2) ;; contents of the symbol library file... (3) ) 1 The version token attribute defines the symbol library version using the YYYYMMDD date format. 2 The generator token attribute defines the program used to write the file. 3 The symbol definitions go here. Symbol library files can have zero or more symbols. Symbol Section The symbol token defines a symbol in the library.\n[SYMBOL_DEFINITION] (1) ... 1 The SYMBOL_DEFINITION defines the symbol(s) in the library file. ",
    "description": "",
    "tags": [],
    "title": "Symbol Library File Format",
    "uri": "/en/file-formats/sexpr-symbol-lib/index.html"
  },
  {
    "breadcrumb": "File Formats",
    "content": " Introduction This documents the s-expression schematic file format for all versions of KiCad from 6.0.\nSchematic files use the .kicad_sch extension.\nInstance Path Because KiCad schematics can support multiple instances of the same schematic using hierarchical sheets, information for shared sheets is done using paths consisting of the universally unique identifiers that represent the hierarchical path for the sheet the instance separated by a forward slash ('/'). A typical instance path would look like:\n\"/00000000-0000-0000-0000-00004b3a13a4/00000000-0000-0000-0000-00004b617b88\" The first identifier must be the root sheet which is the same identifier as the root schematic file. Label and Pin Shapes The table below defines the valid shape tokens global labels, hierarchical labels, and hierarchical sheet pins.\nToken Definition Image input\nLabel or pin is an input shape\noutput\nLabel or pin is an output shape\nbidirectional\nLabel or pin is a bidirectional shape\ntri_state\nLabel or pin is a tri-state shape\npassive\nLabel or pin is a tri-state shape\nLayout A schematic file includes the following sections:\nHeader\nUnique Identifier\nPage Settings\nTitle Block Section\nSymbol Library Symbol Definition\nJunction Section\nNo Connect Section\nWire and Bus Section\nImage Section\nGraphical Line Section\nGraphical Text Section\nLocal Label Section\nGlobal Label Section\nSymbol Section\nHierarchical Sheet Section\nRoot Sheet Instance Section\nHeader Section The kicad_sch token indicates that it is KiCad schematic file. This section is required.\nThird party scripts should not use eeschema as the generator identifier. Please use some other identifier so that bugs introduced by third party generators are not confused with a schematic file created by KiCad. (kicad_sch (version VERSION) (1) (generator GENERATOR) (2) ;; contents of the schematic file... (3) ) 1 The version token attribute defines the schematic version using the YYYYMMDD date format. 2 The generator token attribute defines the program used to write the file. 3 The schematic sections go here. Unique Identifier Section The uuid token defines the globally unique identifier that identifies the schematic.\nUNIQUE_IDENTIFIER (1) NOTE Only the root schematic identifier is used as the virtual root sheet identifier. All other identifiers are belong to hierarchical sheet objects.\n1 The UNIQUE_IDENTIFIER defines the universally unique identifier for the schematic file. This identifier is used when creating hierarchical sheet paths which are used to reference symbol instance data and hierarchical sheet instance information. Library Symbol Section The lib_symbols token defines a symbol library contain all of the symbols used in the schematic.\n(lib_symbols SYMBOL_DEFINITIONS... (1) ) 1 A list of 0 or more symbols. Junction Section The junction token defines a junction in the schematic. The junction section will not exist if there are no junctions in the schematic.\n(junction POSITION_IDENTIFIER (1) (diameter DIAMETER) (2) (color R G B A) (3) UNIQUE_IDENTIFIER (4) ) 1 The POSITION_IDENTIFIER defines the X and Y coordinates of the junction. 2 The diameter token attribute defines the DIAMETER of the junction. A diameter of 0 is the default diameter in the system settings. 3 The color token attributes define the Red, Green, Blue, and Alpha transparency of the junction. If all four attributes are 0, the default junction color is used. 4 The UNIQUE_IDENTIFIER defines the universally unique identifier for the junction. No Connect Section The no_connect token defines a unused pin connection in the schematic. The no connect section will not exist if there are not any no connects in the schematic.\n(no_connect POSITION_IDENTIFIER (1) UNIQUE_IDENTIFIER (2) ) 1 The POSITION_IDENTIFIER defines the X and Y coordinates of the no connect. 2 The UNIQUE_IDENTIFIER defines the universally unique identifier for the no connect. Bus Entry Section The bus_entry token defines a bus entry in the schematic. The bus entry section will not exist if there are no bus entries in the schematic.\n(bus_entry POSITION_IDENTIFIER (1) (size X Y) (2) STROKE_DEFINITION (3) UNIQUE_IDENTIFIER (4) ) 1 The POSITION_IDENTIFIER defines the X and Y coordinates of the bus entry. 2 The size token attributes define the X and Y distance of the end point from the position of the bus entry. 3 The STROKE_DEFINITION defines how the bus entry is drawn. 4 The UNIQUE_IDENTIFIER defines the universally unique identifier for the bus entry. Wire and Bus Section The wire and bus tokens define wires and buses in the schematic. This section will not exist if there are no wires or buses in the schematic.\n(wire | bus COORDINATE_POINT_LIST (1) STROKE_DEFINITION (2) UNIQUE_IDENTIFIER (3) ) 1 The COORDINATE_POINT_LIST defines the list of X and Y coordinates of start and end points of the wire or bus. 2 The STROKE_DEFINITION defines how the wire or bus is drawn. 3 The UNIQUE_IDENTIFIER defines the universally unique identifier for the wire or bus. Image Section See common Images section.\nGraphical Line Section The polyline token defines one or more lines that may or may not represent a polygon. This section will not exist if there are no lines in the schematic.\n(polyline COORDINATE_POINT_LIST (1) STROKE_DEFINITION (2) UNIQUE_IDENTIFIER (3) ) 1 The COORDINATE_POINT_LIST defines the list of X/Y coordinates of to draw line(s) between. A minimum of two points is required. 2 The STROKE_DEFINITION defines how the graphical line is drawn.. 3 The UNIQUE_IDENTIFIER defines the universally unique identifier for the graphical line. Graphical Text Section The text token defines graphical text in a schematic.\n(text \"TEXT\" (1) POSITION_IDENTIFIER (2) TEXT_EFFECTS (3) UNIQUE_IDENTIFIER (4) ) 1 The TEXT is a quoted string that defines the text. 2 The POSITION_IDENTIFIER defines the X and Y coordinates and rotation angle of the text. 3 The TEXT_EFFECTS section defines how the text is drawn. 4 The UNIQUE_IDENTIFIER defines the universally unique identifier for the graphical text. Local Label Section The label token defines an wire or bus label name in a schematic.\n(label \"TEXT\" (1) POSITION_IDENTIFIER (2) TEXT_EFFECTS (3) UNIQUE_IDENTIFIER (4) ) 1 The TEXT is a quoted string that defines the label. 2 The POSITION_IDENTIFIER defines the X and Y coordinates and rotation angle of the label. 3 The TEXT_EFFECTS section defines how the label text is drawn. 4 The UNIQUE_IDENTIFIER defines the universally unique identifier for the label. Global Label Section The global_label token defines a label name that is visible across all schematics in a design. This section will not exist if no global labels are defined in the schematic.\n(global_label \"TEXT\" (1) (shape SHAPE) (2) [(fields_autoplaced)] (3) POSITION_IDENTIFIER (4) TEXT_EFFECTS (5) UNIQUE_IDENTIFIER (6) PROPERTIES (7) ) 1 The TEXT is a quoted string that defines the global label. 2 The shape token attribute defines the way the global label is drawn. See table below for global label shapes. 3 The optional fields_autoplaced is a flag that indicates that any PROPERTIES associated with the global label have been place automatically. 4 The POSITION_IDENTIFIER defines the X and Y coordinates and rotation angle of the label. 5 The TEXT_EFFECTS section defines how the global label text is drawn. 6 The UNIQUE_IDENTIFIER defines the universally unique identifier for the global label. 7 The PROPERTIES section defines the properties of the global label. Currently, the only supported property is the inter-sheet reference. Hierarchical Label Section The hierarchical_label section defines labels that are used by hierarchical sheets to define connections between sheet in hierarchical designs. This section will not exist if no global labels are defined in the schematic.\n(hierarchical_label \"TEXT\" (1) (shape SHAPE) (2) POSITION_IDENTIFIER (3) TEXT_EFFECTS (4) UNIQUE_IDENTIFIER (5) ) 1 The TEXT is a quoted string that defines the hierarchical label. 2 The shape token attribute defines the way the hierarchical label is drawn. See table below for hierarchical label shapes. 3 The POSITION_IDENTIFIER defines the X and Y coordinates and rotation angle of the label. 4 The TEXT_EFFECTS section defines how the hierarchical label text is drawn. 5 The UNIQUE_IDENTIFIER defines the universally unique identifier for the hierarchical label. Symbol Section The symbol token in the symbol section of the schematic defines an instance of a symbol from the library symbol section of the schematic.\n(symbol \"LIBRARY_IDENTIFIER\" (1) POSITION_IDENTIFIER (2) (unit UNIT) (3) (in_bom yes|no) (4) (on_board yes|no) (5) UNIQUE_IDENTIFIER (6) PROPERTIES (7) (pin \"1\" (uuid e148648c-6605-4af1-832a-31eaf808c2f8)) (8) (instances (9) (project \"PROJECT_NAME\" (10) (path \"PATH_INSTANCE\" (11) (reference \"REFERENCE\") (12) (unit UNIT) (13) ) ;; Optional symbol instances for this `project`... ) ;; Optional symbol instances for other `project`... ) ) 1 The LIBRARY_IDENTIFIER defines which symbol in the library symbol section of the schematic that this schematic symbol references. 2 The POSITION_IDENTIFIER defines the X and Y coordinates and angle of rotation of the symbol. 3 The unit token attribute defines which unit in the symbol library definition that the schematic symbol represents. 4 The in_bom token attribute determines whether the schematic symbol appears in any bill of materials output. 5 The on_board token attribute determines if the footprint associated with the symbol is exported to the board via the netlist. 6 The UNIQUE_IDENTIFIER defines the universally unique identifier for the symbol. This is used to map the symbol the symbol instance information. 7 The PROPERTIES section defines a list of symbol properties of the schematic symbol. 8 The pin token attributes define ???. 9 The instances token defines a list of symbol instances grouped by project. Every symbol will have a least one instance. 10 The project token attribute defines the name of the project to which the instance data belongs. There can be instance data from other project when schematics are shared across multiple projects. The projects will be sorted by the PROJECT_NAME in alphabetical order. 11 The path token attribute is the path to the sheet instance for the instance data. 12 The reference token attribute is a string that defines the reference designator for the symbol instance. 13 The unit token attribute is a integer ordinal that defines the symbol unit for the symbol instance. For symbols that do not define multiple units, this will always be 1. Hierarchical Sheet Section The sheet token defines a hierarchical sheet of the schematic.\n(sheet POSITION_IDENTIFIER (1) (size WIDTH HEIGHT) (2) [(fields_autoplaced)] (3) STROKE_DEFINITION (4) FILL_DEFINITION (5) UNIQUE_IDENTIFIER (6) SHEET_NAME_PROPERTY (7) FILE_NAME_PROPERTY (8) HIERARCHICAL_PINS (9) (instances (10) (project \"PROJECT_NAME\" (11) (path \"PATH_INSTANCE\" (12) (page \"PAGE_NUMBER\") (13) ) ;; Optional sheet instances for this `project`... ) ;; Optional sheet instances for other `project`... ) ) 1 The POSITION_IDENTIFIER defines the X and Y coordinates and angle of rotation of the sheet in the schematic. 2 The size token attributes define the WIDTH and HEIGHT of the sheet. 3 The optional fields_autoplaced token indicates if the properties have been automatically placed. 4 The STROKE_DEFINITION defines how the sheet outline is drawn. 5 The FILL_DEFINITION defines how the sheet is filled. 6 The UNIQUE_IDENTIFIER defines the universally unique identifier for the sheet. This is used to map the sheet symbol instance information and sheet instance information. 7 The SHEET_PROPERTY_NAME is a property that defines the name of the sheet. This property is mandatory. 8 The FILE_NAME_PROPERTY is a property that defines the file name of the sheet. This property is mandatory. 9 The HIERARCHICAL_PINS section is a list of hierarchical pins that map a hierarchical label defined in the associated schematic file. 10 The instances token defines a list of sheet instances grouped by project. Every sheet will have a least one instance. 11 The project token attribute defines the name of the project to which the instance data belongs. There can be instance data from other project when schematics are shared across multiple projects. The projects will be sorted by the PROJECT_NAME in alphabetical order. 12 The path token attribute is the path to the sheet instance for the sheet instance data. 13 The page token attribute is a string that defines the page number for the sheet instance. Hierarchical Sheet Pin Definition The pin token in a sheet object defines an electrical connection between the sheet in a schematic with the hierarchical label defined in the associated schematic file.\n(pin \"NAME\" (1) input | output | bidirectional | tri_state | passive (2) POSITION_IDENTIFIER (3) TEXT_EFFECTS (4) UNIQUE_IDENTIFIER (5) ) 1 The \"NAME\" attribute defines the name of the sheet pin. It must have an identically named hierarchical label in the associated schematic file. 2 The electrical connect type token defines the type of electrical connect made by the sheet pin. 3 The POSITION_IDENTIFIER defines the X and Y coordinates and angle of rotation of the pin in the sheet. 4 The TEXT_EFFECTS section defines how the pin name text is drawn. 5 The UNIQUE_IDENTIFIER defines the universally unique identifier for the pin. Root Sheet Instance Section (path \"/\" (1) (page \"PAGE\") (2) ) 1 The instance path is always empty (\"/\") since there are no sheets pointing to the root sheet. 2 The page token defines the page number of the root sheet. Page numbers can be any valid string. ",
    "description": "",
    "tags": [],
    "title": "Schematic File Format",
    "uri": "/en/file-formats/sexpr-schematic/index.html"
  },
  {
    "breadcrumb": "File Formats",
    "content": " Introduction This documents the s-expression work sheet file format for all versions of KiCad from 6.0. Work sheet files are used to change the default border and title block for schematics and boards.\nWork sheet files use the .kicad_wks extension.\nWork Sheet Coordinates The minimum internal unit for work sheet files is 1 micrometer so there is maximum resolution of three decimal places or 0.001 mm. Any precision beyond three places will be truncated.\nObject Incrementing All graphical objects can be drawn multiple times with a given repeat count and X and/or Y incremental distances. The direction of the increment is controlled by defining a start corner and/or end corner depending on the graphical object type. The table below defines the corner tokens and their meaning.\nToken Description ltcorner\nTop left corner of the start or end point.\nlbcorner\nBottom left corner of the start or end point.\nrbcorner\nBottom right corner of the start or end point.\nrtcorner\nTop right corner of the start or end point.\nLayout A work sheet file includes the following sections:\nHeader\nSet Up Section\nDrawing Object Section\nHeader Section The kicad_wks token indicates that it is KiCad work sheet file. This section is required.\nThird party scripts should not use pl_editor as the generator identifier. Please use some other identifier so that bugs introduced by third party generators are not confused with a work sheet file created by KiCad. (kicad_wks (version VERSION) (1) (generator GENERATOR) (2) ;; contents of the schematic file... (3) ) 1 The version token attribute defines the work sheet version using the YYYYMMDD date format. 2 The generator token attribute defines the program used to write the file. 3 The work sheet sections go here. Set Up Section The setup token defines the configuration information for the work sheet.\n(setup (textsize WIDTH HEIGHT) (1) (linewidth WIDTH) (2) (textlinewidth WIDTH) (3) (left_margin DISTANCE) (4) (right_margin DISTANCE) (5) (top_margin DISTANCE) (6) (bottom_margin DISTANCE) (7) ) 1 The textsize token attributes define the default WIDTH and HEIGHT of text. 2 The linewidth token attribute defines the default WIDTH of lines. 3 The textlinewidth token attribute define the default WIDTH of the lines used to draw text. 4 The left_margin token attributed defines the DISTANCE from the left edge of the page. 5 The right_margin token attributed defines the DISTANCE from the right edge of the page. 6 The top_margin token attributed defines the DISTANCE from the top edge of the page. 7 The bottom_margin token attributed defines the DISTANCE from the bottom edge of the page. Drawing Object Section The drawing object section can contain zero or more title block text, graphical line, graphical rectangle, graphical polygon, or image. The objects are ordered as they are added to the work sheet.\nTitle Block Text The tbtext token attributes define text used in the title block of a work sheet.\n(tbtext \"TEXT\" (1) (name \"NAME\") (2) (pos X Y [CORNER]) (3) (font [(size WIDTH HEIGHT)] [bold] [italic]) (4) [(repeat COUNT)] (5) [(incrx DISTANCE)] (6) [(incry DISTANCE)] (7) [(comment \"COMMENT\")] (8) ) 1 The tbtext token attribute defines the TEXT string. 2 The name token attribute defines the NAME of the text object. 3 The pos token attributes define the X and Y coordinates the text. The optional CORNER attribute is used to define the initial corner for repeating incremental text. 4 The font token attributes define how the text is drawn. The optional size token attributes define the size of the font used to draw the text. If not defined, the default text size defined in the set up section is used. The optional bold token indicates the text be drawn with a bold font. The optional italic token indicates the text be drawn italicized. 5 The optional repeat token attribute defines the COUNT for repeated incremental text. 6 The optional incrx token attribute defines the repeat DISTANCE on the X axis. 7 The optional incry token attribute defines the repeat DISTANCE on the Y axis. 8 The optional comment token attribute is a comment for the text object. Graphical Line The line token attributes define how a line is drawn in the work sheet.\n(line (name \"NAME\") (1) (start X Y [CORNER]) (2) (end X Y [CORNER]) (3) [(repeat COUNT)] (4) [(incrx DISTANCE)] (5) [(incry DISTANCE)] (6) [(comment \"COMMENT\")] (7) ) 1 The name token attribute defines the NAME of the line object. 2 The start token attributes define the X and Y coordinates of the start point of the line. The optional CORNER attribute defines the initial corner for repeating incremental lines. 3 The end token attributes define the X and Y coordinates of the end point of the line. The optional CORNER attribute defines the end corner for repeating incremental lines. 4 The optional repeat token attribute defines the COUNT for repeated incremental lines. 5 The optional incrx token attribute defines the repeat DISTANCE on the X axis. 6 The optional incry token attribute defines the repeat DISTANCE on the Y axis. 7 The optional comment token attribute is a comment for the line object. Graphical Rectangle The rect token attributes define how a rectangle is drawn in the work sheet.\n(rect (name \"NAME\") (1) (start X Y [CORNER]) (2) (end X Y [CORNER]) (3) [(repeat COUNT)] (4) [(incrx DISTANCE)] (5) [(incry DISTANCE)] (6) [(comment \"COMMENT\")] (7) ) 1 The name token attribute defines the NAME of the rectangle object. 2 The start token attributes define the X and Y coordinates of the start point of the rectangle. The optional CORNER attribute defines the initial corner for repeating incremental rectangles. 3 The end token attributes define the X and Y coordinates of the end point of the rectangle. The optional CORNER attribute defines the end corner for repeating incremental rectangles. 4 The optional repeat token attribute defines the COUNT for repeated incremental rectangles. 5 The optional incrx token attribute defines the repeat DISTANCE on the X axis. 6 The optional incry token attribute defines the repeat DISTANCE on the Y axis. 7 The optional comment token attribute is a comment for the rectangle object. Graphical Polygon The polygon token defines a graphical polygon. This section will not exist if there are no polygons in the work sheet.\n(polygon (name \"NAME\") (1) (pos X Y [CORNER]) (2) [(rotate ANGLE)] (3) [(linewidth WIDTH)] (4) COORDINATE_POINT_LIST (5) [(repeat COUNT)] (6) [(incrx DISTANCE)] (7) [(incry DISTANCE)] (8) [(comment \"COMMENT\")] (9) ) 1 The name token attribute defines the NAME of the polygon object. 2 The pos token attributes define the X and Y coordinates the text. The optional CORNER attribute is used to define the initial corner for repeating incremental polygons. 3 The optional rotate token attribute defines the rotation angle of the polygon object. 4 The optional linewidth token attribute defines the width of all of the polygons. If not defined, the default line width in the set up section is used. 5 The COORDINATE_POINT_LIST defines the list of X/Y coordinates of to draw line(s) between. A minimum of two points is required. 6 The optional repeat token attribute defines the COUNT for repeated incremental polygons. 7 The optional incrx token attribute defines the repeat DISTANCE on the X axis. 8 The optional incry token attribute defines the repeat DISTANCE on the Y axis. 9 The optional comment token attribute is a comment for the polygon object. Image The image token defines one or more embedded images. This section will not exist if no images are in the work sheet.\n(bitmap (name \"NAME\") (1) (pos X Y ) (2) (scale SCALAR) (3) [(repeat COUNT)] (4) [(incrx DISTANCE)] (5) [(incry DISTANCE)] (6) [(comment \"COMMENT\")] (7) (pngdata IMAGE_DATA) (8) ) 1 The name toke attribute defines the NAME of the image. 2 The pos token attributes define the X and Y coordinates of the image. The optional CORNER attribute defines the start corner for repeating incremental images. 3 The scale token attribute defines the SCALE_FACTOR of the image. 4 The optional repeat token attribute defines the COUNT for repeated incremental image. 5 The optional incrx token attribute defines the repeat DISTANCE on the X axis. 6 The optional incry token attribute defines the repeat DISTANCE on the Y axis. 7 The optional comment token attribute is a comment for the image object. 8 The pngdata token attribute defines the IMAGE_DATA in the portable network graphics format (PNG). Image Data The data token defines the raw image data.\n(data XX1 ... XXN ) (1) ... 1 The data token attributes define the hexadecimal byte data separated by a space. A maximum of 32 bytes will be defined for each data token. The data tokens are defined until all of the image data is defined. ",
    "description": "",
    "tags": [],
    "title": "Work Sheet File Format",
    "uri": "/en/file-formats/sexpr-worksheet/index.html"
  },
  {
    "breadcrumb": "File Formats",
    "content": " Legacy Format (4.0 up to 6.0 ) Older documentation for the non-s-expression schematic file format and older printed circuit board s-expression format is available here.\nThe old printed circuit board file format document is not up to date and should not be used as a reference. ",
    "description": "",
    "tags": [],
    "title": "Legacy Formats (4.0 up to 6.0)",
    "uri": "/en/file-formats/legacy-4-to-6/index.html"
  },
  {
    "breadcrumb": "File Formats",
    "content": " This is for the PCB file format before the S expression format introduced in KiCad 4.0. This documentation is a mostly verbatim copy of what was written back then and the quality may be poor. This is only included as a reference and is not maintained. Information about V1 version: Board files ( *.brd files ) are in ASCII format.\nDimensions are in 1/10000 inch, except for the page size (in 1/1000 inch).\nFirst line is something as: PCBNEW-BOARD Version 1 date 02/04/2011 15:04:20 All the following descriptions are like this:\n$DESCRIPTION some data … $endDESCRIPTION When \u003cDESCRIPTION\u003e is an identifier which gives the meaning of the data between $DESCRIPTION and $endDESCRIPTION.\nExample:\n$GENERAL encoding utf-8 LayerCount 2 Ly 1FFF8001 Links 66 NoConn 0 Di 24940 20675 73708 40323 Ndraw 16 Ntrack 267 Nzone 1929 Nmodule 29 Nnets 26 $EndGENERAL $SHEETDESCR Sheet A4 11700 8267 Title \"\" Date \"23 feb 2004\" Rev \"\" Comp \"\" Comment1 \"\" Comment2 \"\" Comment3 \"\" Comment4 \"\" $EndSHEETDESCR Information about V2 version: The file format is exactly the same format, and the extension is still .brd. However, dimensions are in mm (floating notation), except for the page size (in 1/1000 inch). Because the internal Pcbnew unit is now 1nm, the integer coordinates in 1/10000 inch cannot be used in files. Of course, the Pcbnew versions which are in nm are able to read the V1 version files, but can only write files in V2 version. The V2 version should be seen as a temporary way to store boards without loss of resolution.\nFirst line is something as:\nPCBNEW-BOARD Version 2 date 22/02/2013 15:04:20\nAll the following descriptions are like this:\n$DESCRIPTION some data … $endDESCRIPTION Example:\nPCBNEW-BOARD Version 2 date 22/02/2013 10:33:30 # Created by Pcbnew(2013-02-20 BZR 3963)-testing $GENERAL encoding utf-8 Units mm LayerCount 2 EnabledLayers 1FFF8001 Links 200 NoConn 0 Di 69.241669 24.89454 202.336401 196.2404 Ndraw 19 Ntrack 779 Nzone 0 BoardThickness 1.6002 Nmodule 25 Nnets 111 $EndGENERAL Information about new “S expression” version: For Pcbnew versions in nanometers, the default file format is now using “S expressions”. This new format uses mm for coordinates, fixes issues (like spaces in names) in V1 and V2 versions, and is more human readable than the older format. The new file extension is .kicad_pcb\nHere is a sample:\n(kicad_pcb (version 3) (host pcbnew \"(2013-01-12 BZR 3902)-testing\") (general (links 200) (no_connects 0) (area 69.241669 24.89454 202.336401 196.2404) (thickness 1.6002) (drawings 19) (tracks 779) (zones 0) (modules 25) (nets 111) ) (page A4) (title_block (title Demo) (rev 2.C) (company Kicad) ) Layer numbering: Tracks and other items (texts, drawings …​) use one layer. Pads and vias use several layers. There are 16 copper layers and 13 technical layers. The layer parameter used in descriptions has the value:\nvalue\nlayer name\n0\nCopper layer\n\"Copper\" layers\n1 to 14\nInner layers\n15\nComponent layer\n16\nCopper side adhesive layer\n\"Technical\" layers\n17\nComponent side adhesive layer\n18\nCopper side Solder paste layer\n19\nComponent Solder paste layer\n20\nCopper side Silk screen layer\n21\nComponent Silk screen layer\n22\nCopper side Solder mask layer\n23\nComponent Solder mask layer\n24\nDraw layer (Used for general drawings)\n25\nComment layer (Other layer used for general drawings)\n26\nECO1 layer (Other layer used for general drawings)\n27\nECO2 layer (Other layer used for general drawings)\n28\nEdge layer. Items on Edge layer are seen on all layers\n29\nNot yet used\n30\nNot yet used\n31\nNot yet used\nMask layer: Sometimes, a mask layer parameter is used. It is a 32 bits mask used to indicate a layer group usage (0 up to 32 layers). A mask layer parameter is given in hexadecimal form. Bit 0 is the copper layer, bit 1 is the inner 1 layer, and so on…​(Bit 27 is the Edge layer). Mask layer is the ORed mask of the used layers\nFirst line of description: Format:\nPCBNEW-BOARD Version \u003cversion number\u003e date \u003cdate\u003e-\u003ctime\u003e\nDate and time are useful only for information (not used by pcbnew).\n$GENERAL This data is useful only when loading file. It is used by Pcbnew for displaying activity when loading data.\n$GENERAL\nStart description\nLy 1FFF8001\nObsolete (used for old pcbnew compatibility)\nLinks 66\nTotal number of connections\nNoConn 0\nRemaining connections\nDi 24940 20675 73708 40323\nBounding box coordinates: X_start Y_start X_end Y_end\nNdraw 16\nNumber of draw items like edge segments, texts…​\nNtrack 267\nNumber of track segments\nNzone 1929\nNumber of zone segments\nNmodule 29\nNumber of modules\nNnets 26\nNumber of nets\n$EndGENERAL\nEnd description\n$SHEETDESCR This the page size and texts.\n$SHEETDESCR\nStart description\nSheet A4 11700 8267\n\u003cPage size\u003e X_size Y_size in mils (1/1000 inch)\nTitle \"\"\nTitle text\nDate \"23 feb 2004\"\nDate text\nRev \"\"\nRevision text\nComp \"\"\nCompany name text\nComment1 \"\"\nComment text, line 1\nComment2 \"\"\nComment text, line 2\nComment3 \"\"\nComment text, line 3\nComment4 \"\"\nComment text, line 4\n$EndSHEETDESCR\nEnd description\n$SETUP block: This data bock is used for design settings This is useful only for board edition. Example:\n$SETUP InternalUnit 0.000100 INCH Layers 2 Layer[0] Cuivre signal Layer[15] Composant signal TrackWidth 250 TrackWidthHistory 25 TrackWidthHistory 170 TrackWidthHistory 250 TrackClearence 110 ZoneClearence 150 DrawSegmWidth 150 EdgeSegmWidth 50 ViaSize 600 ViaDrill 250 ViaSizeHistory 600 MicroViaSize 200 MicroViaDrill 80 MicroViasAllowed 0 TextPcbWidth 170 TextPcbSize 600 800 EdgeModWidth 150 TextModSize 600 600 TextModWidth 120 PadSize 1500 2500 PadDrill 1200 AuxiliaryAxisOrg 29500 55500 $EndSETUP $SETUP\nStart block \"SETUP\"\nInternalUnit 0.000100 INCH\nInternal unit for Pcbnew, all coordinates are in this unit\nLayers 2\nNumber of layers (2 = double sided board) must be 1 to 16\nLayer[0] Cuivre signal\nlayer name and type name = name given to the layer by the user (here: \"cuivre\" type = signal (not current used in Pcbnew)\nLayer[15] Composant signal\nTrackWidth 250\nCurrent track width\nTrackWidthHistory 170\nLast used track widths\nTrackWidthHistory 250\nTrackWidthHistory 400\nTrackClearence 100\nIsolation for DRC (Design rules check)\nZoneClearence 200\nIsolation used in zone filling\nDrawSegmWidth 120\nCurrent segment width for drawings on technical layers\nEdgeSegmWidth 120\nCurrent segment width for drawings on \"edge layer\"\nViaSize 700\nCurrent via size\nViaDrill 250\nVia drill for this board\nViaSizeHistory 450\nLast used via sizes\nViaSizeHistory 650\nViaSizeHistory 700\nTextPcbWidth 120\nCurrent text width for texts on copper or technical layers. This is not for text on footprints\nTextPcbSize 600 600\nCurrent text X Y size\nEdgeModWidth 120\nCurrent Segment width for footprint edition\nTextModSize 120 600\nCurrent text XY size for texts for footprint edition\nTextModWidth 120\nCurrent text width for texts for footprint edition\nPadSize 700 700\nCurrent X Y pad size (footprint edition)\nPadDrill 320\nCurrent pad drill\nAuxiliaryAxisOrg 0 0\nAuxiliary axis position (Auxiliary axis is the reference coordinate (0 0 coordinate) for EXCELLON drilling files\n$EndSETUP\nEnd block \"SETUP\"\n$EQUIPOT $EQUIPOT describes a net name.\n$EQUIPOT\nStart block\nNa 2 \"N-000026\"\nNa \u003cinternal net number\u003e « net name »\nSt ~\n$EndEQUIPOT\nEnd block\nNote1: Internal net number is an arbitrary number. It is computed by Pcbnew when compiling netlist. Note2: Net 0 is not a real net. Net 0 is the net number used internally by Pcbnew for all the no connected pads.\nExample:\n$EQUIPOT; Na 0 \"\" St ~ $EndEQUIPOT $EQUIPOT Na 1 \"DONE\" St ~ $EndEQUIPOT $EQUIPOT Na 2 \"N-000026\" St ~ $EndEQUIPOT $EQUIPOT Na 3 \"TD0/PROG\" St ~ $EndEQUIPOT $MODULE Description start by: $MODULE \u003cmodule name\u003e`\nAnd ends with $EndMODULE \u003cmodule name\u003e`\nModule description has four sections:\nGeneral description (fixed size)\nField description (variable size)\nDrawing description (variable size)\nPad description. (variable size)\n3D shape information.\nNote: All coordinates are relative to the module position. Its means the coordinates of segments, pads, texts …​ are given for a module in position 0, rotation 0. If a module is rotated or mirrored, real coordinates must be computed according to the real position and rotation.\nGeneral description: $MODULE bornier6\n$MODULE \u003cmodule lib name\u003e\nPo 62000 30500 2700 15 3EC0C28A 3EBF830C ~~\nPo Xpos Ypos Orientation(0.1deg) Layer TimeStamp Attribut1Attribut2 Attribut1 = ~or 'F' for autoplace (F = Fixed, ~= moveable) Attribut2 = ~or 'P' for autoplace (P = autoplaced)\nLi bornier6\nLi \u003cmodule lib name\u003e\nCd Bornier d’alimentation 4 pins\nCd comment description (displayed when browsing libraries)\nKw DEV\nKw Keyword1 Keyword2 …​ (for footprint selection by keywords)\nSc 3EBF830C\nSc TimeStampOp\nOp 0 0 0\nOp \u003crotation cost 90 deg\u003e \u003crotation cost 180 deg\u003e for auto place. rotation cost = 0 (no rotation allowed) to 10 (null cost)\nNote: Usually, components are on layer 15 (component layer) or 0 (copper layer). If the component is on layer 0, it is\"mirrored\". The \"mirror axis is the X axis\nField Description: There are 2 to 12 fields\nField 0 = component reference (U1, R5 …​) (required) Field 1 = component value (10K, 74LS02 …​) (required) Other fields (optional) are comments. Format:\nT\u003cfield number\u003e \u003cXpos\u003e \u003cYpos\u003e \u003cXsize\u003e \u003cYsize\u003e \u003crotation\u003e \u003cpenWidth\u003e N \u003cvisible\u003e \u003clayer\u003e \"text\"`\nField\nUnits\nMeaning\nfield number\nenumeration\n0⇒reference, 1⇒value, etc.\nXpos\ntenths of mils (.0001 inches)\nThe horizontal offset relative to the module’s overall position\nYpos\ntenths of mils (.0001 inches)\nThe vertical offset relative to the module’s overall position\nXsize\ntenths of mils (.0001 inches)\nThe horizontal size of the character 'M'\nYsize\ntenths of mils (.0001 inches)\nThe vertical size of the character 'M'\nrotation\ntenths of degrees\nAngular rotation from horizontal, counterclockwise\npenWidth\ntenths of mils (.0001 inches)\nWidth of the pen used to draw characters\nN\nnone\nflag for the parser?\nvisible\nboolean\nI⇒ invisible, V⇒ visible\nlayer\nenumeration\nsee layer numbers above\nExamples:\nT0 500 -3000 1030 629 2700 120 N V 21 \"P1\"\nT0 ⇒ reference\nT1 0 3000 1201 825 2700 120 N V 21 \"CONN_6\"\nT1 ⇒ value\nDrawings: Tells how to draw module shape. They cannot be on a copper layer (DRC ignore them) Drawings are segment, circle, arc, polygon.\nDraw segment: DS -6000 -1500 -6000 1500 120 21\nDS is a Draw Segment DS Xstart Ystart Xend Yend Width Layer\nDS 6000 1500 6000 -1500 120 21\nAn other Draw Segment\nCircle: DC Xcentre Ycentre Xpoint Ypoint Width Layer\nDC is a Draw Circle Xpoint, Ypoint is a point on the circle.\nArc: DA Xcentre Ycentre Xstart_point Ystart_point angle width layer\nDA is a Draw Arc angle is the arc angle in 0.1 degrees\nPolygon: DP 0 0 0 0 corners_count width layer\nDraw Polygon First line of a polygon. The polygon should be closed, otherwise this is a poly-line. width is the thickness of outlines.\nDl corner_posx corner_posy\nCorner coordinate ( corners_count lines like this)\nPad Descriptions: All the pads of this footprint are listed here (Many $PAD/$EndPAD sections here).. See $PAD description.\n$SHAPE3D 3D shape information: The real shape description is a vrml file, build by Wings3d. This shape can be scaled, moved and rotated. This is because a single 3D shape can be used for many footprints (for instance, we use the shape resistor.wrl for several resistor footprints, by tuning the X, Y, Z scale of the 3D shape according to the different size of resistor footprints). Some smd footprints are using this feature. For the same reasons, the 3D shape can be moved (by the move factor) and/or rotated. Real shape unit is 0.1 inch (1 unit vrml = 0.1 inch = 2.54 millimeter). An other reason exists: when a footprint is very big ( a big connector) or very small (a small SMD resistor) we must create a 3D shape small or bigger than real size, in order to use easily the 3D modeler.\n$SHAPE3D\nStart description\nNa \"device/bornier_6.wrl\"\nFileName (default path is kicad/modules/packages3d/)\nSc 1.000000 1.000000 1.000000\nX Y Z scale factor\nOf 0.000000 0.000000 0.000000\nX Y Z offset (move vector, in 3D units (0.1 inch))\nRo 0.000000 0.000000 0.000000\nX Y Z rotation (in degree)\n$EndSHAPE3D\nEnd description\nThe 3D shape coordinates are relative to the footprint coordinates. The 3D shape must be scale, moved and rotated according to the parameters Sc Of and Ro, and after moved and rotated according to the footprint coordinates and rotation. If the footprint is « inverted » (that is, located on copper side) the 3D shape must be « inverted » too.\nA footprint may have several 3D shapes (for instance an integrated circuit and his socket). $PAD Pads have different shapes and attributes. Pad shapes are: * Circle. * Oblong(or oval). * Rectangular (Square is like a rectangle). * Trapeze.\nPad attributes are:\nNormal (Has usually a hole)\nSmd (used for Surface Mounted Devices). Has no hole.\nConnector (used for connectors like a PC Board Bus connector)\nMechanical. (Like a hole for mechanical use)\nAnd shape can be draw with an offset related to the drilling hole. The hole shale is round or oblong\n$PAD\nStart description\nSh \"2\" C 1500 1500 0 0 2700\nShape: \u003cpad name\u003e shape Xsize Ysize Xdelta Ydelta Orientation\nDr 600 0 0 or (oblong hole) Dr 600 0 0 O 600 650\nDrill \u003cPad drill\u003e Xoffset Yoffset (round hole) or (oblong hole) Drill \u003cPad drill.x\u003e Xoffset Yoffset \u003cHole shape\u003e \u003cPad drill.x\u003e \u003cPad drill.y\u003e\nAt STD N 00E0FFFF\nAttributs: \u003cPad type\u003e N \u003clayer mask\u003e\nNe 8 \"GND\"\nNet reference of the pad: \u003cnetnumber\u003e \u003cnet name\u003e\nPo -3000 0\nX_pos Y_pos (relative to the module position)\n$EndPAD\nEnd description\nNote: \u003cPad type\u003e is the Pad Attribute. It is one of: \"STD\" \"SMD\" \"CONN\" \"HOLE\" \"MECA\". Shape is one of:\nC (circle)\nR (Rectangular).\nO (Oblong)\nT (Trapèze) Hole shape = O (O for Oblong)\nExample:\n$PAD Sh \"3\" C 1500 1500 0 0 2700 Dr 600 0 0 At STD N 00E0FFFF Ne 10 \"TD0_1\" Po -1000 0 $EndPAD Graphic items: There are drawing items like segments, circles, texts, targets and cotations.\n$DRAWSEGMENT Draw segments are:\nsegments (strait line)\ncircles\narcs\nLine: $DRAWSEGMENT\nStart description\nPo 0 67500 39000 65500 39000 120\nPosition shape Xstart Ystart Xend Yend width\nDe 28 0 900 0 0\nDescription layer type angle timestamp status\n$EndDRAWSEGMENT\nEnd description\nNote:\nshape = 0\nAngle is used only for arc segments (unused for line, left for compatibility).\nCircle: $DRAWSEGMENT\nStart description\nPo 1 67500 39000 65500 39000 120\nPosition shape Xcentre Ycentre Xend Yend width\nDe 28 0 900 0 0\nDescription layer type angle timestamp status\n$EndDRAWSEGMENT\nEnd description\nNote: * shape = 1 * Angle is used only for arc segments (unused for circle, left for compatibility). * End is a point of this circle. (If Xend or Yend is 0, the other coordinate is the radius)\nArc: $DRAWSEGMENT\nStart description\nPo 2 67500 39000 65500 39000 120\nPosition shape Xstart Ystart Xend Yend width\nDe 28 0 900 0 0\nDescription layer type angle timestamp status\n$EndDRAWSEGMENT\nEnd description\nNote:\nshape = 2\nstart and end are the 2 points of the arc. angle is the arc angle (in 0.1 degree). Center coordinates are computed by pcbnew from start, end and angle.\nCurrently, only 90 degrees arcs are supported.(thereby, angle = 900)\nExample:\n$DRAWSEGMENT Po 0 67500 34000 67500 39000 120 De 28 0 900 0 $EndDRAWSEGMENT $TEXTPCB $TEXTPCB\nStart description\nTe \"TDI\"\nText \"string\"\nPo 57250 35750 600 600 150 0\nPosition Xstart Ystart Xsize Ysize Width rotation\nDe 15 1 B98C Normal\nDescription layer normal timestamp style normal = 0 : text is mirrored. normal = 1 : text is normal. style = Normal or Italic\n$EndTEXTPCB\nEnd description\nExample:\n$TEXTPCB Te \"TCK\" Po 57250 33500 600 600 150 0 De 15 1 B98C Normal $EndTEXTPCB $MIRE shape 1 shape 0 $MIREPCB\nStart description\nPo 0 28 28000 51000 5000 150 00000000\nPosition shape Xpos Ypos size width timestamp\n$EndMIREPCB\nEnd description\n$COTATION $COTATION\nStart description\nGe 0 24 0\nGeneral shape layer timestamp currently, shape = 0.\nTe \"4,5500''\"\nText \"string\" string is the cotation value in inches or millimeters\nPo 50250 5791 600 800 170 0 1\nPosition (for text) Xpos Ypos Xsize Ysize width orient normal\nSb 0 27500 6501 73000 6501 150\nCoordinates of segments (axis, arrows…​)\nSd 0 73000 9000 73000 5081 150\nSg 0 27500 9000 27500 5081 150\nS1 0 73000 6501 72557 6731 150\nS2 0 73000 6501 72557 6271 150\nS3 0 27500 6501 27943 6731 150\nS4 0 27500 6501 27943 6271 150\n$EndCOTATION\nEnd description\nTrack, vias and Zone section: $TRACK Track section decribes tracks and vias on copper layers. Each track (or via) has a two line description: For a track segment:\nPosition shape Xstart Ystart Xend Yend width Description layer 0 netcode timestamp status Shape parameter is set to 0 (reserved for future changes).\nFor a via: Position shape Xstart Ystart Xend Yend diameter Description layer 1 netcode timestamp status\nFor a via, layer parameter gives : On the 4 less significant bits: the starting layer of the via On the 4 next bits: the ending layer.\nFor instance, a via starting at copper kayer (layer 0) end ending at component layer (layer 15 has the layer parameter set to F0 hexadecimal or 240 decimal. + Shape parameter is the via type (through = 3, blind = 2, buried = 1) + Timestamp parameters are set to 0 (reserved for future changes). Status parameter can be set to 0 (Used internally for routing information).\n$TRACK\nStart description\nPo 0 36750 37000 36550 37000 250\nPosition shape Xstart Ystart Xend Yend width width = diameter for a via\nDe 15 0 1 0 400\nDescription layer type netcode timestamp status type = 0 for a track segment. type = 1 for a via\nPo 0 39000 36750 38750 37000 250\nAn other track\nDe 15 0 1 0 0\nPo 3 53500 27000 53500 27000 650\nThis is a via (via \"through\") from layer 15 (component) to layer 0 (copper)\nDe 15 1 14 0 0\n$EndTRACK\nEnd description\n$ZONE Zone section is like track section. (There is no via in Zone section). It is used to handle a zone filling, from a zone outline.\n$ZONE\nStart description\nPo 0 67100 33700 67100 38600 100\nSame as track description\nDe 0 0 2 3EDDB09D 0\n$EndZONE\nEnd description\n$CZONE_OUTLINE Describes the main outlines of a zone and the outlines of filled areas (solid polygons) inside the zone main outlines. Outlines of filled areas can be missing (if the zone is not currently filled). Because a zone handles thermal reliefs, there are options to describe pads in zones options and thermal reliefs parameters.\nExample:\n$CZONE_OUTLINE ZInfo 47868246 1 \"GND\" ZLayer 0 ZAux 4 E ZClearance 150 T ZMinThickness 190 ZOptions 0 32 F 200 200 ZCorner 74750 51750 0 ZCorner 74750 13250 0 ZCorner 29750 13250 0 ZCorner 29750 51750 1 .... $POLYSCORNERS 74655 51655 0 0 74655 13345 0 0 ... $endPOLYSCORNERS $endCZONE_OUTLINE $CZONE_OUTLINE\nStart description\nZInfo 478E3FC8 1 \"/aux_sheet/INPUT\"\t\u003cTime stamp\u003e \u003cinternal netcode\u003e \"net name\"\nZLayer 0\tLayer (0 = copper, 15 = component, 1 ..14 = inner layers)\nZAux 4 E\t\u003ccorners count\u003e \u003czone hatching option\u003e\nzone hatching option = N (none), E (edge hatching) or F (full hatching)\nZClearance 200 T\t\u003cZone clearance\u003e \u003cpads option = I, T or X\u003e\nI = pads in zone\nT = Thermal reliefs\nX = pads not in zone.\nZMinThickness 190\t\u003cZone min thickness (for copper zone)\u003e\nZOptions 0 32 F 200 200\t\u003cfill mode\u003e \u003carc approx\u003e \u003cantipad thickness\u003e \u003cthermal stubs width\u003e\nfill mode = 0 (use solid polygons) or 1 (use segments)\narc approx = 16 or 32 (segments count to approximate a 360 arc)\nZCorner 49450 19150 0\tFirst corner (external outline)\nZCorner 40600 19150 0\tNext corner\nZCorner 40600 22850 0\nZCorner 49450 22850 1\tEnd corner (flag = 1)\n$POLYSCORNERS\tStart of filled areas outlines\n74655 51655 0 0\tFirst corner (first filled area outline)\n74655 13345 0 0\tNext corner\n$endPOLYSCORNERS\n$endCZONE_OUTLINE\nEnd description\nOther example:\n$CZONE_OUTLINE\tStart description of an other outline ZInfo 47B3E800 3 \"VCC\" ZLayer 1 ZAux 8 F ZClearance 200 T ZMinThickness 190\tZone min thickness (for copper zone) ZOptions 0 32 F 200 200 ZCorner 49704 23032 0\tFirst corner (external outline) ZCorner 49704 18940 0 ZCorner 46140 19024 0 ZCorner 46148 20000 0 ZCorner 45250 20000 0 ZCorner 44750 21250 0 ZCorner 43750 22250 0 ZCorner 46176 23068 1\tEnd corner (flag = 1) ZCorner 48450 19900 0\tFirst corner (this is a hole) ZCorner 48450 20800 0 ZCorner 47350 20800 0 ZCorner 47250 19900 1\tEnd corner (flag = 1) $endCZONE_OUTLINE\tEnd description $EndBOARD $EndBOARD terminates the whole board description. Must be the last line.",
    "description": "",
    "tags": [],
    "title": "Legacy Board Format (pre 4.0)",
    "uri": "/en/file-formats/legacy-pcb/index.html"
  },
  {
    "breadcrumb": "",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/en/categories/index.html"
  },
  {
    "breadcrumb": "Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag | Linux",
    "uri": "/en/tags/linux/index.html"
  },
  {
    "breadcrumb": "Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag | Macos",
    "uri": "/en/tags/macos/index.html"
  },
  {
    "breadcrumb": "",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/en/tags/index.html"
  },
  {
    "breadcrumb": "Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag | Windows",
    "uri": "/en/tags/windows/index.html"
  }
]
